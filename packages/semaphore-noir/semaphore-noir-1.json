{
  "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
  "hash": 8225587512003534708,
  "abi": {
    "parameters": [
      { "name": "secretKey", "type": { "kind": "field" }, "visibility": "private" },
      { "name": "indexes", "type": { "kind": "field" }, "visibility": "private" },
      {
        "name": "hashPath",
        "type": { "kind": "array", "length": 1, "type": { "kind": "field" } },
        "visibility": "private"
      },
      {
        "name": "merkleProofLength",
        "type": { "kind": "integer", "sign": "unsigned", "width": 32 },
        "visibility": "private"
      },
      { "name": "merkleTreeRoot", "type": { "kind": "field" }, "visibility": "public" },
      { "name": "hashedScope", "type": { "kind": "field" }, "visibility": "public" },
      { "name": "hashedMessage", "type": { "kind": "field" }, "visibility": "public" }
    ],
    "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" },
    "error_types": {
      "2920182694213909827": { "error_kind": "string", "string": "attempt to subtract with overflow" },
      "5019202896831570965": { "error_kind": "string", "string": "attempt to add with overflow" },
      "6485997221020871071": { "error_kind": "string", "string": "call to assert_max_bit_size" },
      "16761564377371454734": { "error_kind": "string", "string": "Array index out of bounds" },
      "17843811134343075018": { "error_kind": "string", "string": "Stack too deep" }
    }
  },
  "bytecode": "H4sIAAAAAAAA/+y9B7xdVbX2vUggFJWmdOm9CKsXQLp0VIoFbKyqgljARrECNooFbAGiRogaIWiEqAGiRgkaJWCUqAgBowaMGooaFCV8zzh3nu89Ozdey3nG+s352+z7nnd5DsnKmGs8Y4z/GHOevdfw/ue1fFPPm/S0//nfa+Br4pjrdvha0/t//23V1+jPDjJXf3yvgHgvf8IYO9cx13VXXaT8h3ev8rN1zc/GviYqLjTy0zhus7ANoqD0w6LKEz9OqjQP8iDJkybMo6jN4zwrqiLziyCO2qBLiqgzN1vn379X/S/uFazLW6O/pnmeE7x//vp3/61/ZffYe7JFuQ7xmYwNovW8VYS3nve/o2xV4THF8i9sDf7Ff/fXI9r1NJ4Y/LHPVO77buVnui7xXsxn+vT/4Jn+q39r7DN9unmmzAAvq6htmyqPitBvW79MsywssqbG90GYdk4G+DNGjR19cM/w3ArwZxDtWp8nhoEAX99zK8CZz3SD/+CZ+qlf50XdggHSKPaTKPNLP6/SBqEfVn419plu4P2/AJ/guYt+YuOB5n9viK+N8LUxvp6Jr2fhaxN8gX69zfC1Ob62wNeW+NoKX8/G19b42gZf23r/g8Lb42sHfO2Ir53wtTO+dsHXrvjaDV+742sPfO2Jr73w9Rx87Y2vfWRN+JJFhuJ3fMX4SvCV4ivDV46vAl/74ms/fO2Pr+fi6wCzhoPwdTC+DsHXofg6DF/Pw9fh+DoCX0fi6yh8HY2vY/B1LL6Ow9fzzfpfMPpARp38Au9/O/bgVZw6XoEOODX0x/XacOy9xnmzjQbuNb6bbTx4r3Hd7Jmr3Gs8N3vWqvcax802+V/3+u9vtun/vtd/fbPNVnOv//Zmm6/uXv/lzbZY7b3+u5ttufp7/Vc32+qf3Ou/udmz/9m9/oubbf1P7/Wf32ybf36v//hm2/4f9/pPb7bd/3Wv//Bm2/+f9/rPbrbD/32v/+hmO/6Le/0nN9vpX93rP7jZzv/yXv/+zXb51/f6t2+2679xr3/3Zrv9O/f6N2+2+791r3/vZnv8e/f6t2625795r3/nZnv9u/f6N272nH/7Xv/6Znv/+/f6lzfb5z+417+82X9yr39xs+A/utf/fbPwP7vX/3mz6D+81/91s/g/vdf/cbPkP77XP79Z+p/f65/eLPsv7vXPbpb/N/f6Jzcr/qt7rf5m+/5391rtzfb7L++1upvt/9/eazU3e+5/fa//fbMD/vt7/a+bHTiOe616s4PGc69VbnbwuO41eLNDxnevgZsdOs57jb3ZYeO915ibPW/c9/p/Nzt8/Pf6/292BOFeozc7knEvc7OjKPf6n5sdzbnXyM2OId1LbnYs61642XG0e/nh8z3e/OsFY+4Vju9e4djZnczCRndfRn+20Wp+tvFqfvbM1fzsWav52Sar+dmmq/nZZqv52ear+dkWq/nZlqv52Var+dmzV/OzrVfzs21W87NtV/Oz7Vbzs+1X87MdVvOzHVfzs51W87OdV/OzXVbzs11X87PdVvOz3Vfzsz1W87M9V/OzvVbzs+es5md7r+Zn+6zmZ/5qfhas5mfhan4WreZn8Wp+lqzmZ+lqfpat5mf5an5WrOZn+67mZ/ut5mf7r+Znz13Nzw5Yzc8OXM3PDlrNzw5ezc8OWc3PDl3Nzw5bzc+et5qfHb6anx2xmp8duZqfHbWanx29mp8ds5qfHbuanx23mp893/t/541GX2uY60HmOt6c/MIx9wqjKKv9ImmjpEzLqKvKrMO+WBAXWRfWVdbF+Ld8v+6yNq2jMm6iyM/SOCrwL/hdVWjaefxYO8u8iv2oDv0o8Yuyjjvs5SVl5PtVWudtWUdxl+dZFERhluRd1Pq4aRgWbRS0uGeuaecJ3tjaW6LxLfAVJnHddG3WdlXk57WflHhuRRmWZYq/GVZZ2uRxm1ZpGhZhVGR1HmF3UtPOE8c+z6Srm7qt26iO6yyM/aCssB2e5EEQ+k3QYuc58su28+ssKJMmKvK0SsK8Tcs0TJss1LTzpLHPM+ryJOjg56asws5vkjbI46wr4i5Nq66p4zjD04viJotrv0nLJq3Kqo6boAiauvM17XzRmHsFmR/GHVRZVX7mJ2kdp1VbB3GY51VW5GWM0EmqLAmaqCszGJsXTZVlVd4FrR8HjaadLx7r9zLOozKq/S5ti64scj/NqqZtkQCiPG99xHtZIsDaNPGDJMAC2iT22zzrqjwP6kjTzpeMtTMu6yb2c7/sohABnhZlVITwfhy0Ettdk1WBH2d4kHHeNVVQxa0fFE0E+/OuUvX7S8fqs4IXS5Fd1GZRASvKugphYZOGWVYHYVnlTS6RFcHAKg1z3Cfq0qoqEugk0LTz5LF2pgHUGKUNfIhJkx9lLdJlnYeIHCT3OorqIs7KpojSIqly/G1IOS6rTJ5xG7Wadp4y5l5BkQZdF0b4i0HYNSEyeZwgayKnJ03bhE3TpnndREmdFXVeFV0Vy+3y1Mc9qzbWtPNlY/VZI/vUWdci1tsmytswRbhH+P/ysq2TDnKo6xgpEwmqRFUtUsn+NaI9bbE6Vb+/fKzf5ehQkCddk9ZN4eMuZRLHCB0/7eIqapGY/KZJirSJs7qskGQzYADqQFI0RZh3mna+Yuzz7PCgihb+9WuEStH4qV+EZYMIwgMLojzJizxOUDHjEP8jbPKsqmtEUA5+ydJE085Xjn2eCZ5iG6VIoDV82qSIIhTOKPdr5J0sTGEgHnaSpkUYZMgCSEhplJZ+3QbwhSovvWqsnQ2yZoPQbposSpDq8WCbJEhgaBhWZYJ478o8qvKgCUtwQOZXQdYlflLj4se58KgcItrQ3E+YUXhMWEc4Qmq01D+pLZK3JSdKvpFYljgRDYp/5dm9ytxjgrf6k5IHjdo8ztc/e67++F7Bhg7YeKqCjZ6GSMuxhjZtjgiBIps0KeMkqeMoL1H4SxBeDooL4gCRlKRhWwXITknWJn6OfywsQdOJalGqxtwrLNKoKmIkcYQLwCQVQAobtBZJUFVRhNgKiyACn0ZlUNdtXlcFyKrA3bCsTDXZ1wN2VkibLW7VBU0ZgevCpEVhDOoQhsVJKrWqTYMs8NsmQ4qPmhT/YNVUNSA/V7Wz8cYW+azrpGLHKXJSjQ4IzU9XZEicVdbkMBK0V7WwLm/rNET6hzAktXZZgnWoNnPtWDtLlJYsaTr0PCjpbRACnzLQSBWhbUtylE7gZhSiES7RMJeNj3yK3qQKCpB0qPo8u7F+D7KmKPwMpRAg13aIqiqJ4V/0w+hKmqbI6zxNMzxkv8nBV3XddWhNAz8sizotNe189YCdTZp2fou+PCnbAiCCNg5olxddEQVFXYPimy5Dxw5ERgNVFm2cRvhhBNyvC9Ui/5qxdiZZkWHS0GWlX4VxESaJ3LhuAkBf0TZd3WJHGrxZ4F+L0INUGEwkWZlnYQP9VlI85Wu0eMoDlnwisSpxIBoT/8mzeY35erX5WWv+TG3+zqhzJnj/71T32NdB5uqP8/XPnqs/vpcTxfO1TBvXNI6a5P3vlytVf1jtpArBQTs9np0Yana14r3zscnwNHM93Vxfp/DgRxZ0Ku5xqsevPmd4XIdqCE6+JpDvewbxGb5e+RmO1z4Rp9hI/k3q8HTivWz2xwSSP0CXI69TjaZZWj7N+Nfj+tfvEyhO89wogK7YefqQ2+nx7OwVKN5orm8y1zMVHvzIgkTIp3n8YnOWZzdQiODkiw0UZxGf4Zs9u4FCxCk2soHiTcR72ewPNlCcZjTN0vIbjX89rn97BYo3em4UQFfsfNOQ2+nx7OwVKN5qrm8z17crPPiRBYmQ3+jxi83Znt1AIYKTLzZQnE18hud4dgOFiFNsZAPF24j3stkfbKB4o9E0S8tvNf71uP7tFSje6rlRAF2x821DbqfHs7NXoDjPXN9hru9UePAjCxIhv9XjF5t3eXYDhQhOvthA8S7iM3y3ZzdQiDjFRjZQvIN4L5v9wQaKtxpNs7R8nvGvx/XvyNvXTfD+94v5bFend398r2AjB2x8L9NGV08lueCo85k29ono5yk8XA07qZGgaOc7HLGTKtjVvAj37hXRLzDXC831fVoPXgLuvR4f397vcR2qERjnK6z7Q+R1s9+N+Tyzbtb93mH0Q1jzSBBcYMTO9vcFynocB143aeMXF5p1sz8r40Keb+r3WxwnbL3IWj/k8fPD+4jr7hPM2PEz7HZe6A23nR7Pzl7B7CJzvdhcL1F48CMLEiFf4PET0KWe3YlXBCdf7NnppcRn+GHPTpgYtU/EKTayZ6cXE+9lsz/Ys9MLjKZZWr7I+Nfj+rdXoLjIc6MAumLnxUNup8ezs1eg+Ki5fsxcL1N48CMLEiFf5PGLzeWe3UAhgpMvNlBcTnyGH/fsBgoRp9jIBoqPEe9lsz/YQHGR0TRLyx81/vW4/u0VKD7quVEAXbHzY0Nup8ezs1eg+KS5fspcP63w4EcWJEL+qMcvNpM9u4FCBCdfbKCYTHyGV3h2A4WIU2xkA8WniPey2R9soPio0TRLy580/vW4/u0VKD7puVEAXbHzU0Nup8ezs1eguMpcp5jrZxQe/MiCRMif9PjF5rOe3UAhgpMvNlB8lvgMP+fZDRQiTrGRDRRTiPf6rMX+YAPFJ42mWVq+yvjX4/rX2ePiGztg4+eZNoqTXDwu7oKjrmba2CeiX6XwcDXspEaCop1THLGTKtjVvAj37hXRrzHXaeb6Ba0HLwH3eY+Pb1/0uA7VCIyrFdb9ZfK62cfFrzLrZt1vitEPYc0jQXCNETvb39co63G8x8WnmXWzj4tP4/mm/qLFccLWi6z1yx4/P3yBuO4+wYwdP8Nu5zRvuO30eHb2CmbXmut15jpD4cGPLEiEfI3HT0DXe3YnXhGcfLFnp9cTn+FXPDthYtQ+EafYyJ6dXke8l83+YM9OrzGaZmn5WuNfj+vfXoHiWs+NAuiKndcNuZ0ez85egWKmuX7NXG9QePAjCxIhX+vxi82Nnt1AIYKTLzZQ3Eh8hrM8u4FCxCk2soHia8R72ewPNlBcazTN0vJM41+P699egWKm50YBdMXOrw25nR7Pzl6B4hvm+k1zna3w4EcWJEKe6fGLzU2e3UAhgpMvNlDcRHyGN3t2A4WIU2xkA8U3ifey2R9soJhpNM3S8jeMfz2uf3sFim94bhRAV+z85pDb6fHs7BUo5pjrt8z12woPfmRBIuRvePxi8x3PbqAQwckXGyi+Q3yGcz27gULEKTaygeJbxHvZ7A82UHzDaJql5TnGvx7Xv84eF3+mAzZ+j2mjOMnF4+IuOOpWpo19IvochYerYSc1EhTt/JYjdlIFu5oX4d69Ivo8c73NXL+v9eAl4L7n8fHtBx7XoRqBcavCun9EXjf7uPgcs27W/b5l9ENY80gQzDNiZ/t7nrIex3tc/DazbvZx8dt4vql/YHGcsPUia/2Rx88P3yeuu08wY8fPsNt5mzfcdno8O3sFs9vNdYG53qHw4EcWJEKe5/ET0J2e3YlXBCdf7NnpncRn+GPPTpgYtU/EKTayZ6cLiPey2R/s2ek8o2mWlm83/vW4/u0VKG733CiArti5YMjt9Hh29goUPzHXn5rrXQoPfmRBIuTbPX6xWeTZDRQiOPliA8Ui4jP8mWc3UIg4xUY2UPyUeC+b/cEGituNplla/onxr8f1b69A8RPPjQLoip0/HXI7PZ6dvQLFL8z1bnP9pcKDH1mQCPknHr/Y3OPZDRQiOPliA8U9xGd4r2c3UIg4xUY2UNxNvJfN/mADxU+Mplla/oXxr8f1b69A8QvPjQLoip13D7mdHs/OXoHiPnO931x/pfDgRxYkQv6Fxy82Szy7gUIEJ19soFhCfIa/9uwGivtxD7GRDRT3E+9lsz/YQPELo2mWlu8z/vW4/nX2uPizHLDxt0wbxUkuHhd3wVFLmTb2iej3KTxcDTupkaBo5/2O2EkV7GpehHv3iugPmOuD5vo7rQcvAfdbj49vyzyuQzUCY6nCuv9IXjf7uPh9Zt2s+91v9ENY80gQPGDEzvb3A8p6HO9x8QfNutnHxR/k+aZeZnGcsPUia/2jx88PvyOuu08wY8fPsNv5oDfcdno8O3sFs+Xm+pC5Pqzw4EcWJEJ+wOMnoEc8uxOvCE6+2LPTR4jP8FHPTpgYtU/EKTayZ6cPEe9lsz/Ys9MHjKZZWl5u/Otx/dsrUCz33CiArtj50JDb6fHs7BUo/myufzHXFQoPfmRBIuTlHr/YPObZDRQiOPliA8VjxGf4V89uoBBxio1soPgL8V42+4MNFMuNplla/rPxr8f1b69A8WfPjQLoip1/GXI7PZ6dvQLF4+b6d3P9h8KDH1mQCPnPHr/YPOHZDRQiOPliA8UTxGe40rMbKEScYiMbKP5OvJfN/mADxZ+Npllaftz41+P6t1egeNxzowC6Yuffh9xOj2dnr0Ax+oDXMNcJa3j0Bz+yIBHy4x6/2Excw26gEMHJFxsoxq57vM9wzTXsBgoRp9jIBoo1eOsObfYHGygeN5pmadkz/vW4/nX2uPgmDtg4ialRcZKLx8VdcNTaTEf1iejeGvyHq2HnJEfsXMMRO9dWstPj2dkroq9jHvC65rqeAqLLayTgRMxsfHua5YgugbG2wrrXJ6+bfVzcM+tm3W8Nox9WEIjw11uD7+91LG13Ro+Lr2vWzT4uvi7PN/XT1rA3Tth6kbWur5Af1iOuu08wY8fPsNu57pDb6fHs7BXMNjAPeENz3UhrdipCXkchAW1seeIVwckXe3a6MbF4PdPy2amI85kKs9MNibNTm/3Bnp2uYzTN0vIGxr8e17+9AsUGjhRAV+zccMjt9Hh29goUm5gHvKm5bqYFFCLkDRSAYnPLgUIEt6ECUGxOLGBbWA4UIs4tFIBiUyJQ2OwPNlBsYDTN0vImxr8e17+9AsUmjhRAV+zcdMjt9Hh29goUW5kH/Gxz3VoLKETImygAxTaWA4UIblMFoNiGWMC2tRwoRJzbKgDFs4lAYbM/2ECxidE0S8tbGf96XP/2ChRbOVIAXbHz2UNup8ezs1eg2N484B3MdUctoBAhb6UAFDtZDhQiuGcrAMVOxAK2s+VAIeLcWQEodiAChc3+YAPFVkbTLC1vb/zrcf3r7HHxTR2wcVemRsVJLh4Xd8FRuzEd1Seib+8IUu7qiJ07OGLnbkp2ejw7e0X03c0D3sNc91RAdHmNBNyuCoi+l+WILoGxm8K69yGvm31cfHuzbtb9djD6YQWBCH/PNfj+3t3Sdmf0uPgeZt3s4+J78HxT77WGvXHC1ousdR+F/LAncd19ghk7fobdzj2G3E6PZ2evYOabBxyYa6g1OxUh766QgCLLE68Ibg+F2WlELF6x5bNTEWesMDsNiLNTm/3Bnp3ubjTN0rJv/Otx/dsrUPiOFEBX7AyG3E6PZ2evQJGaB5yZa64FFCJkXwEoCsuBQgQXKABFQSxg+1oOFCLOfRWAIiMChc3+YAOFbzTN0nJq/Otx/dsrUKSOFEBX7MyG3E6PZ2evQLG/ecDPNdcDtIBChJwqAMWBlgOFCC5TAIoDiQXsIMuBQsR5kAJQPJcIFDb7gw0UqdE0S8v7G/96XP/2ChT7O1IAXbHzuUNup8ezs1egOMQ84EPN9TAtoBAh768AFM+zHChEcM9VAIrnEQvY4ZYDhYjzcAWgOJQIFDb7gw0U+xtNs7R8iPGvx/Wvs8fFN3PAxiOZGhUnuXhc3AVHHcV0VJ+IfogjSHmkI3Ye6oidRynZ6fHs7BXRjzYP+BhzPVYB0eU1EnBHKiD6cZYjugTGUQrrfiF53ezj4oeYdbPud6jRDysIRPjHrsH399GWtjujx8WPMetmHxc/hueb+rg17I0Ttl5krS9UyA/HEtfdJ5ix42fY7TxmyO30eHb2CmbHmwd8grmeqDU7FSEfrZCATrI88YrgjlGYnZ5ELF4vsnx2KuJ8kcLs9ATi7NRmf7Bnp0cbTbO0fLzxr8f1b69AcbwjBdAVO08Ycjs9np29AsVLzAN+qbmerAUUIuTjFYDiFMuBQgR3ggJQnEIsYC+zHChEnC9TAIqXEoHCZn+wgeJ4o2mWll9i/Otx/dsrULzEkQLoip0vHXI7PZ6dvQLFK8wDfqW5vkoLKETIL1EAilMtBwoR3EsVgOJUYgErLQcKEWepABSvJAKFzf5gA8VLjKZZWn6F8a/H9W+vQPEKRwqgK3a+csjt9Hh29goUtXnAjbm2WkAhQn6FAlB0lgOFCO6VCkDREQvYqy0HChHnqxWAoiEChc3+YAPFK4ymWVqujX89rn+dPS6+uQM2vpapUXGSi8fFXXDUaUxH9YnotSNI+VpH7GwcsfM0JTs9np29Ivrp5gG/zlzPUEB0eY0E3GsVEP31liO6BMZpCut+E3nd7OPitVk3636N0Q8rCET4Z6zB9/fplrY7o8fFX2fWzT4u/jqeb+rXr2FvnLD1Imt9k0J+OIO47j7BjB0/w27n64bcTo9nZ69gdqZ5wGeZ65u1Zqci5NMVEtBbLE+8IrjXKcxO30IsXm+1fHYq4nyrwuz0LOLs1GZ/sGenpxtNs7R8pvGvx/Vvr0BxpiMF0BU7zxpyOz2enb0CxdvNAz7bXM/RAgoR8pkKQHGu5UAhgjtLASjOJRaw8ywHChHneQpAcTYRKGz2BxsozjSaZmn57ca/Hte/vQLF2x0pgK7YefaQ2+nx7OwVKN5pHvC7zPXdWkAhQn67AlC8x3KgEMGdrQAU7yEWsPdaDhQizvcqAMW7iEBhsz/YQPF2o2mWlt9p/Otx/dsrULzTkQLoip3vGnI7PZ6dvQLFBeYBX2iu79MCChHyOxWA4v2WA4UI7l0KQPF+YgH7gOVAIeL8gAJQXEgECpv9wQaKdxpNs7R8gfGvx/Wvs8fFt3DAxg8xNSpOcvG4uAuOuojpqD4R/QJHkPJDjth5oSN2XqRkp8ezs1dEv9g84EvM9VIFRJfXSMB9SAHRP2w5oktgXKSw7o+R180+Ln6BWTfrfhca/bCCQIR/6Rp8f19sabszelz8ErNu9nHxS3i+qT+8hr1xwtaLrPVjCvnhUuK6+wQzdvwMu52XDLmdHs/OXsHsMvOALzfXj2vNTkXIFyskoE9YnnhFcJcozE4/QSxen7R8diri/KTC7PRy4uzUZn+wZ6cXG02ztHyZ8a/H9W+vQHGZIwXQFTsvH3I7PZ6dvQLFp80DnmyuV2gBhQj5MgWguNJyoBDBXa4AFFcSC9hVlgOFiPMqBaCYTAQKm/3BBorLjKZZWv608a/H9W+vQPFpRwqgK3ZOHnI7PZ6dvQLFZ8wD/qy5fk4LKETIn1YAiqmWA4UIbrICUEwlFrDPWw4UIs7PKwDFZ4lAYbM/2EDxaaNplpY/Y/zrcf3bK1B8xpEC6Iqdnx1yOz2enb0CxTXmAU8z1y9oAYUI+TMKQPFFy4FCBPdZBaD4IrGAfclyoBBxfkkBKKYRgcJmf7CB4jNG0ywtX2P863H96+xx8S0dsPHLTI2Kk1w8Lu6Co65lOqpPRL/GEaT8siN2TnPEzmuV7PR4dvaK6NeZBzzDXK9XQHR5jQTclxUQ/SuWI7oExrUK6/4aed3s4+LXmHWz7jfN6Iew5pEgEOFfvwbf39dZ2u6MHhefYdbNPi4+g+eb+itr2BsnbL3IWr+mkB+uJ667TzBjx8+w2zljyO30eHb2CmY3mAd8o7nO0pqdipCvU0hAX7c88YrgZijMTr9OLF7fsHx2KuL8hsLs9Ebi7NRmf7Bnp9cZTbO0fIPxr8f1b69AcYMjBdAVO28ccjs9np29AsVs84BvMtebtYBChHyDAlDcYjlQiOBuVACKW4gFbI7lQCHinKMAFDcRgcJmf7CB4gajaZaWZxv/elz/9goUsx0pgK7YedOQ2+nx7OwVKL5tHvB3zHWuFlCIkGcrAMV3LQcKEdxNCkDxXWIB+57lQCHi/J4CUHyHCBQ2+4MNFLONplla/rbxr8f1b69A8W1HCqArdn5nyO30eHb2ChTzzAO+zVy/rwUUIuRvKwDFDywHChHcdxSA4gfEAjbfcqAQcc5XAIrbiEBhsz/YQPFto2mWlucZ/3pc/zp7XHwrB2z8EVOj4iQXj4u74KjbmY7qE9HnOYKUP3LEztscsfN2JTs9np29IvoC84DvMNc7FRBdXiMB9yMFRP+x5YgugXG7wrp/Sl43+7j4PLNu1v1uM/phBYEI/841+P5eYGm7M3pc/A6zbvZx8Tt4vql/vIa9ccLWi6z1pwr54U7iuvsEM3b8DLuddwy5nR7Pzl7B7C7zgBeZ68+0Zqci5AUKCejnlideEdwdCrPTnxOL1y8sn52KOH+hMDtdRJyd2uwP9ux0gdE0S8t3Gf96XP/2ChR3OVIAXbFz0ZDb6fHs7BUofmke8D3meq8WUIiQ71IAisWWA4UIbpECUCwmFrD7LAcKEed9CkBxDxEobPYHGyjuMppmafmXxr8e17+9AsUvHSmArth5z5Db6fHs7BUofmUe8BJz/bUWUIiQf6kAFL+xHChEcPcoAMVviAXst5YDhYjztwpAsYQIFDb7gw0UvzSaZmn5V8a/Hte/vQLFrxwpgK7YuWTI7fR4dvYKFA+YB/yguf5OCyhEyL9SAIpllgOFCG6JAlAsIxaw31sOFCLO3ysAxYNEoLDZH2yg+JXRNEvLDxj/elz/Ontc/NkO2PhHpkbFSS4eF3fBUcuZjuoT0R9wBCn/6IidDzpi53IlOz2enb0i+kPmAT9sro8oILq8RgLujwqI/qjliC6BsVxh3X8hr5t9XPwBs27W/R40+mEFgQj/kTX4/n7I0nZn9Lj4w2bd7OPiD/N8Uz+6hr1xwtaLrPUvCvnhEeK6+wQzdvwMu50PD7mdHs/OXsFshXnAj5nrX7VmpyLkhxQS0N8sT7wiuIcVZqd/Ixavxy2fnYo4H1eYnT5GnJ3a7A/27PQho2mWllcY/3pc//YKFCscKYCu2PnYkNvp8ezsFSj+YR7wE+a6UgsoRMgrFIDiScuBQgT3mAJQPEksYGKc5jMcr30j4pzAB4oniEBhsz/YQLHCaJql5X+s4Q3smrLW3idQ/MORAuiKnU8MuZ0ez85egWKCieOJ5rrmBP6DH1mQCPkfCkCxlnIx9Mf3GhHcEwpAMXbd432GkywHChHnJAWgmMhbd2izP9hA8Q+jaZaWJxj/elz/9goUEya4UQBdsXPikNvp8ezsFSjWMXG8rrmupwUUImT5Yhebp1kOFCI4+WIDxdOIBezplgOFiPPpCkCxLhEobPYHGygmGE2ztLyO8a/H9a+zx8W3dsDG9ZkaFSe5eFzcBUdtwHRUn4i+jiNIub4jdq7riJ0bKNnp8ezsFdE3NCVsI3PdWAHR5TUScOsrIPozLUd0CYwNFNa9KXnd7OPi65h1s+63rtEPKwhE+BtP4Pt7Q0vbndHj4huZdbOPi2/E8039zAn2xglbL7LWTRXyw8bEdfcJZuz4GXY7NxpyOz2enb2C2WYGxDY31y0m8B/8yIJEyBsqJKAtLU+8IriNFGanWxKL11aWz05FnFspzE43J85ObfbHBJI/RmenGxpNs7S8mfGvx/Vvr0CxmSMF0BU7Nx9yOz2enb0CxdYmjrcx1221gEKEvJkCUGxnOVCI4DZXAIrtiAVse8uBQsS5vQJQbEMECpv9wQaKzYymWVre2vjX4/q3V6DY2pEC6Iqd2wy5nR7Pzl6BYkcTxzuZ685aQCFC3loBKHaxHChEcNsoAMUuxAK2q+VAIeLcVQEodiIChc3+YAPF1kbTLC3vaPzrcf3bK1Ds6EgBdMXOnYbcTo9nZ69AsbuJ4z3MdU8toBAh76gAFHtZDhQiuJ0UgGIvYgF7juVAIeJ8jgJQ7EEECpv9wQaKHY2mWVre3fjX4/rX2ePi2zhg4z5MjYqTXDwu7oKjfKaj+kT03R1Byn0csXMPR+z0lez0eHb2iuiBKWGhuUYKiC6vkYDbRwHRY8sRXQLDV1h3Rl43+7j47mbdrPvtYfTDCgIRfjSB7+/A0nZn9Lh4aNbNPi4e8nxTxxPsjRO2XmStmUJ+iIjr7hPM2PEz7HaGQ26nx7OzVzDLDYgV5rrvBP6DH1mQCDlQSED7WZ54RXChwux0P2Lx2t/y2amIc3+F2WlBnJ3a7I8JJH+Mzk4Do2mWlnPjX4/r316BInekALpiZzHkdno8O3sFigNMHB9orgdpAYUIOVcAioMtBwoRXKEAFAcTC9ghlgOFiPMQBaA4kAgUNvuDDRS50TRLywcY/3pc//YKFAc4UgBdsfPAIbfT49nZK1AcZuL4eeZ6uBZQiJAPUACKIywHChHcgQpAcQSxgB1pOVCIOI9UAIrnEYHCZn+wgeIAo2mWlg8z/vW4/u0VKA5zpAC6YufzhtxOj2dnr0BxtInjY8z1WC2gECEfpgAUx1kOFCK45ykAxXHEAvZ8y4FCxPl8BaA4hggUNvuDDRSHGU2ztHy08a/H9a+zx8W3dcDGFzI1Kk5y8bi4C446numoPhH9aEeQ8oWO2HmMI3Yer2Snx7OzV0Q/wZSwE831JAVEl9dIwL1QAdFfZDmiS2Acr7Dul5LXzT4ufrRZN+t+xxj9sIJAhH/SBL6/T7C03Rk9Ln6iWTf7uPiJPN/UL5pgb5yw9SJrfalCfjiJuO4+wYwdP8Nu54lDbqfHs7NXMDvZgNgp5vqyCfwHP7IgEfIJCgno5ZYnXhHciQqz05cTi9crLJ+dijhfoTA7PYU4O7XZHxNI/hidnZ5gNM3S8snGvx7Xv70CxcmOFEBX7DxlyO30eHb2ChSvMnF8qrmWWkAhQj5ZASgqy4FCBHeKAlBUxAJWWw4UIs5aAShOJQKFzf5gA8XJRtMsLb/K+Nfj+rdXoHiVIwXQFTtPHXI7PZ6dvQJFa+K4M9dXawGFCPlVCkDxGsuBQgR3qgJQvIZYwF5rOVCIOF+rABQdEShs9gcbKF5lNM3Scmv863H92ytQtI4UQFfs7IbcTo9nZ69AcbqJ49eZ6xlaQCFCbhWA4vWWA4UIrlMAitcTC9gbLAcKEecbFIDidUSgsNkfbKBojaZZWj7d+Nfj+tfZ4+LbOWDjm5gaFSe5eFx8OwdsPJPpqD4R/XRHkPJNjtj5OkfsPFPJTo9nZ6+IfpYpYW8217coILq8RgLuTQqI/lbLEV0C40yFdZ9NXjf7uPjpZt2s+73O6IcVBCL8t0zg+/ssS9ud0ePibzbrZh8XfzPPN/VbJ9gbJ2y9yFrPVsgPbyGuu08wY8fPsNv55iG30+PZ2SuYnWNA7FxzPW8C/8GPLEiEfJZCAnqH5YlXBPdmhdnpO4jF652Wz05FnO9UmJ2eS5yd2uyPCSR/jM5OzzKaZmn5HONfj+vfXoHiHEcKoCt2njvkdno8O3sFinebOH6Pub5XCyhEyOcoAMX5lgOFCO5cBaA4n1jALrAcKEScFygAxXuIQGGzP9hAcY7RNEvL7zb+9bj+7RUo3u1IAXTFzvcMuZ0ez85egeJ9Jo7fb64f0AIKEfK7FYDig5YDhQjuPQpA8UFiAfuQ5UAh4vyQAlC8nwgUNvuDDRTvNppmafl9xr8e17+9AsX7HCmArtj5/iG30+PZ2StQXGzi+BJzvVQLKETI71MAig9bDhQiuPcrAMWHiQXsI5YDhYjzIwpAcQkRKGz2Bxso3mc0zdLyxca/Hte/zh4X394BGz/G1Kg4ycXj4i446jKmo/pE9IsdQcqPOWLnJY7YeZmSnR7Pzl4R/XJTwj5urp9QQHR5jQTcxxQQ/ZOWI7oExmUK655MXjf7uPjFZt2s+11i9MMKAhH+Jybw/X25pe3O6HHxj5t1s4+Lf5znm/qTE+yNE7ZeZK2TFfLDJ4jr7hPM2PEz7HZ+fMjt9Hh29gpmVxgQu9Jcr5rAf/AjCxIhX66QgKZYnnhFcB9XmJ1OIRavz1g+OxVxfkZhdnolcXZqsz8mkPwxOju93GiapeUrjH89rn97BYorHCmArth55ZDb6fHs7BUoPmfieKq5fl4LKETIVygAxdWWA4UI7koFoLiaWMCusRwoRJzXKADFVCJQ2OwPNlBcYTTN0vLnjH89rn97BYrPOVIAXbFz6pDb6fHs7BUovmDi+Ivm+iUtoBAhf04BKKZbDhQiuKkKQDGdWMC+bDlQiDi/rAAUXyQChc3+YAPF54ymWVr+gvGvx/Vvr0DxBUcKoCt2fnHI7fR4dvYKFNeZOJ5hrtdrAYUI+QsKQPEVy4FCBPdFBaD4CrGAfdVyoBBxflUBKGYQgcJmf7CB4gtG0ywtX2f863H96+xx8R0csPFrTI2Kk1w8Lu6Co25gOqpPRL/OEaT8miN2znDEzhuU7PR4dvaK6DeaEjbLXL+ugOjyGgm4rykg+jcsR3QJjBsU1n0Ted3s4+LXmXWz7jfD6IcVBCL8r0/g+/tGS9ud0ePis8y62cfFZ/F8U39jgr1xwtaLrPUmhfzwdeK6+wQzdvwMu52zhtxOj2dnr2B2swGxW8x1zgT+gx9ZkAj5RoUE9C3LE68IbpbC7PRbxOL1bctnpyLObyvMTm8hzk5t9scEkj9GZ6c3Gk2ztHyz8a/H9W+vQHGzIwXQFTtvGXI7PZ6dvQLFXBPH3zXX72kBhQj5ZgWguNVyoBDB3aIAFLcSC9g8y4FCxDlPASi+SwQKm/3BBoqbjaZZWp5r/Otx/dsrUMx1pAC6Yud3h9xOj2dnr0DxfRPHPzDX+VpAIUKeqwAUP7QcKERw31UAih8SC9iPLAcKEeePFIDiB0SgsNkfbKCYazTN0vL3jX89rn97BYrvO1IAXbHzB0Nup8ezs1egWGDi+A5zvVMLKETI31cAih9bDhQiuB8oAMWPiQVsoeVAIeJcqAAUdxCBwmZ/sIHi+0bTLC0vMP71uP519rj4jg7Y+FOmRsVJLh4Xd8FRdzEd1SeiL3AEKX/qiJ13OGLnXUp2ejw7e0X0RaaE/cxcf66A6PIaCbifKiD6LyxHdAmMuxTWfQ953ezj4gvMuln3u8PohxUEIvyfT+D7e5Gl7c7ocfGfmXWzj4v/jOeb+hcT7I0Ttl5krfco5IefE9fdJ5ix42fY7fzZkNvp8ezsFczuNSC22Fzvm8B/8CMLEiEvUkhA91ueeEVwP1OYnd5PLF6/snx2KuL8lcLsdDFxdmqzPyaQ/DE6O11kNM3S8r3Gvx7Xv70Cxb2OFEBX7Fw85HZ6PDt7BYpfmzj+jbn+VgsoRMj3KgDFUsuBQgS3WAEolhIL2AOWA4WI8wEFoPgNEShs9gcbKO41mmZp+dfGvx7Xv70Cxa8dKYCu2PmbIbfT49nZK1D8zsTxMnP9vRZQiJB/rQAUf7AcKERwv1EAij8QC9gfLQcKEecfFYBiGREobPYHGyh+bTTN0vLvjH89rn97BYrfOVIAXbFz2ZDb6fHs7BUoHjJx/LC5PqIFFCLk3ykAxaOWA4UIbpkCUDxKLGB/shwoRJx/UgCKh4lAYbM/2EDxO6NplpYfMv71uP519rj4Tg7Y+BemRsVJLh4Xd8FRK5iO6hPRH3IEKf/iiJ0PO2LnCiU7PZ6dvSL6Y6aE/dVc/6aA6PIaCbi/KCD645YjugTGCoV1P0FeN/u4+ENm3az7PWz0wwoCEf7fJvD9/Zil7c7ocfG/mnWzj4v/leeb+vEJ9sYJWy+y1icU8sPfiOvuE8zY8TPsdv51yO30eHb2CmYrDYg9aa7/f8Jmz05FyI8pJKA1JtqdeEVwf1WYnY5d93if4YSJdsLEqH0iTrGRPTt9kjg7tdkf7NnpY0bTLC2vNP71uP7tFShWOlIAXbHzySG30+PZ2StQrGm+WctcJ2kBhQh5pQJQrG05UIjgnlQAirWJBWwdy4FCxLmOAlCsxVt3aLM/2ECx0miapeU1jX89rn97BYo1J7pRAF2xc60ht9Pj2dkrUKxnvnmauT5dCyhEyPLFLjbPsBwoRHDyxQaKZxAL2PqWA4WIc30FoHgaEShs9gcbKNY0mmZpeT3jX4/r316BYj1HCqArdj5tyO30eHb2ChQbmm82MteNtYBChLyeAlA803KgEME9TQEonkksYM+yHChEnM9SAIqNiEBhsz/YQLGe0TRLyxsa/3pc/zp7XHxnB2zclKlRcdLEpxylYuNmTEf1iegbOoKUmzpi50aO2LmZkp0ez85eEX1z880W5rqlAqLLayTgNlVA9K0sR3QJjM0U1r0Ned3s4+IbmnWz7reR0Q8rCET4W07k+3tzS9ud0ePiW5h1s4+Lb8HzTb3VRHvjhK0XWes2CvlhS+K6+wSzzR0BCVfs3GLI7fR4dvYKZtuab7Yz1+21Zqci5M0VEtAOlideEdwWCrPTHYjFa0fLZ6cizh0VZqfbEWenNvuDPTvd3GiapeVtjX89rn97BYptHSmArti53ZDb6fHs7BUodjbf7GKuu2oBhQh5WwWg2M1yoBDBbacAFLsRC9julgOFiHN3BaDYhQgUNvuDDRTbGk2ztLyz8a/H9W+vQLGzIwXQFTt3GXI7PZ6dvQLFnuabvcz1OVpAIULeWQEo9rYcKERwuygAxd7EAraP5UAh4txHASj2IgKFzf5gA8XORtMsLe9p/Otx/dsrUOzpSAF0xc69htxOj2dnr0ARmG9Cc420gEKEvKcCUMSWA4UIbi8FoIiJBSyxHChEnIkCUIREoLDZH2yg2NNomqXlwPjX4/rX2ePiuzhgY8bUqDhp4lOOUrExZzqqT0QPHEHKzBE7Q0fszJXs9Hh29orohflmX3PdTwHR5TUScJkCou9vOaJLYOQK6z6QvO6JZPsCs27W/UKjH1YQiPD3m8j3d2FpuzN6XHxfs25yuxPsy/NNvf9Ee+OErRdZ64EK+WE/4rr7BLPCEZBwxc59h9xOj2dnr2B2kPnmYHM9RGt2KkIuFBLQoZYnXhHcvgqz00OJxeswy2enIs7DFGanBxNnpzb7gz07LYymWVo+yPjX4/q3V6A4yJEC6IqdBw+5nR7Pzl6B4nDzzRHmeqQWUIwIWQEojrIcKERwBysAxVHEAna05UAh4jxaASiOIAKFzf5gA8VBRtMsLR9u/Otx/dsrUBzuSAF0xc4jhtxOj2dnr0BxrPnmOHN9vhZQiJAPVwCKF1gOFCK4IxSA4gXEAvZCy4FCxPlCBaA4jggUNvuDDRSHG02ztHys8a/H9W+vQHGsIwXQFTuPG3I7PZ6dvQLFCeabE831JC2gECEfqwAUL7IcKERwxykAxYuIBezFlgOFiPPFCkBxIhEobPYHGyiONZpmafkE41+P619nj4vv6oCNL2VqVJw08SlHqdh4MtNRfSL6CY4g5UsdsfNER+w8WclOj2dnr4h+ivnmZeb6cgVEl9dIwL1UAdFfYTmiS2CcrLDuU8nrnki27wSzbtb9TjT6YQWBCP/lE/n+PsXSdmf0uPjLzLrJ7U7wMp5v6ldMtDdO2HqRtZ6qkB9eTlx3n2B2iiMg4YqdLxtyOz2enb2CWWm+qcy11pqdipBPUUhAjeWJVwT3MoXZaUMsXq3ls1MRZ6swO62Is1Ob/cGenZ5iNM3Scmn863H92ytQlI4UQFfsrIbcTo9nZ69A8WrzzWvM9bVaQCFCLhWA4jTLgUIEVykAxWnEAna65UAh4jxdASheQwQKm/3BBorSaJql5Vcb/3pc//YKFK92pAC6YudrhtxOj2dnr0Bxhvnm9eb6Bi2gECG/WgEo3mg5UIjgXqMAFG8kFrA3WQ4UIs43KQDF64lAYbM/2EDxaqNplpbPMP71uP7tFSjOcKQAumLn64fcTo9nZ69AcZb55s3m+hYtoBAhn6EAFG+1HChEcK9XAIq3EgvY2ywHChHn2xSA4s1EoLDZH2ygOMNomqXls4x/Pa5/nT0uvpsDNp7N1Kg4aeJTjlKx8Rymo/pE9LMcQcqzHbHzzY7YeY6SnR7Pzl4R/VzzzXnm+g4FRJfXSMCdrYDo77Qc0SUwzlFY93vI655Itu8ss27W/d5s9MMKAhH+Oyby/X2upe3O6HHx88y6ye1OcB7PN/U7J9obJ2y9yFrfo5Af3kFcd59gdq4jIOGKnecNuZ0ez85ewey95pvzzfUCrdmpCPlchQR0oeWJVwR3nsLs9EJi8Xqf5bNTEef7FGan5xNnpzb7gz07PddomqXl9xr/elz/9goU73WkALpi5/lDbqfHs7NXoPiA+eaD5vohLaAQIb9XASgushwoRHDnKwDFRcQCdrHlQCHivFgBKD5IBAqb/cEGivcaTbO0/AHjX4/r316B4gOOFEBX7PzgkNvp8ezsFSguNd982Fw/ogUUIuQPKADFRy0HChHcBxWA4qPEAvYxy4FCxPkxBaD4MBEobPYHGyg+YDTN0vKlxr8e17+9AsWljhRAV+z88JDb6fHs7BUoLjfffNxcP6EFFCLkSxWA4pOWA4UI7sMKQPFJYgH7lOVAIeL8lAJQfJwIFDb7gw0UlxpNs7R8ufGvx/Wvs8fFd3fAxslMjYqTJj7lKBUbr2A6qk9Ev9wRpJzsiJ0fd8TOK5Ts9Hh29oroV5pvrjLXKQqILq+RgJusgOifsRzRJTCuUFj3VPK6J5Ltu9ysm3W/jxv9sIJAhD9lIt/fV1ra7oweF7/KrJvc7gRX8XxTf2aivXHC1ousdapCfphCXHefYHalIyDhip1XDbmdHs/OXsHs8+abq831Gq3ZqQj5SoUENM3yxCuCu0phdjqNWLy+YPnsVMT5BYXZ6dXE2anN/mDPTq80mmZp+fPGvx7Xv70CxecdKYCu2Hn1kNvp8ezsFSi+ZL6Zbq5f1gIKEfLnFYDiWsuBQgR3tQJQXEssYNdZDhQizusUgGI6EShs9gcbKD5vNM3S8peMfz2uf3sFii85UgBdsXP6kNvp8ezsFSiuN998xVy/qgUUIuQvKQDFTMuBQgQ3XQEoZhIL2NcsBwoR59cUgOIrRKCw2R9soPiS0TRLy9cb/3pc//YKFNc7UgBdsfMrQ26nx7OzV6C40Xwzy1y/rgUUIuTrFYDiG5YDhQjuKwpA8Q1iAfum5UAh4vymAlDMIgKFzf5gA8X1RtMsLd9o/Otx/evscfE9HLDxJqZGxUkTn3KUio03Mx3VJ6Lf6AhS3uSInbMcsfNmJTs9np29Ivot5ps55votBUSX10jA3aSA6N+2HNElMG5WWPd3yeueSLbvRrNu1v1mGf2wgkCE/62JfH/fYmm7M3pcfI5ZN7ndCebwfFN/e6K9ccLWi6z1uwr54VvEdfcJZrc4AhKu2DlnyO30eHb2CmbfM9/caq7ztGanIuRbFBLQbZYnXhHcHIXZ6W3E4vV9y2enIs7vK8xObyXOTm32B3t2eovRNEvL3zP+9bj+7RUovudIAXTFzluH3E6PZ2evQDHffPNDc/2RFlCIkL+nABS3Ww4UIrhbFYDidmIBW2A5UIg4FygAxQ+JQGGzP9hA8T2jaZaW5xv/elz/9goU8x0pgK7Y+cMht9Pj2dkrUNxpvvmxuS7UAgoR8nwFoPiJ5UAhgvuhAlD8hFjAfmo5UIg4f6oAFD8mAoXN/mADxXyjaZaW7zT+9bj+7RUo7nSkALpi54+H3E6PZ2evQLHIfPMzc/25FlCIkO9UAIpfWA4UIrgfKwDFL4gF7G7LgULEebcCUPyMCBQ2+4MNFHcaTbO0vMj41+P619nj4ns6YOM9TI2KkyY+5SgVG+9lOqpPRF/kCFLe44idP3PEznuV7PR4dvaK6IvNN/eZ6/0KiC6vkYC7RwHRf2U5oktg3Kuw7t+Q1z2RbN8is27W/X5m9MMKAhH+/RP5/l5sabszelz8PrNucrsT3MfzTf2rifbGCVsvstbfKOSH+4nr7hPMFjsCEq7Yed+Q2+nx7OwVzH5rvllqrg9ozU5FyIsVEtCDlideEdx9CrPTB4nF63eWz05FnL9TmJ0uJc5ObfYHe3a62GiapeXfGv96XP/2ChS/daQAumLn0iG30+PZ2StQ/N588wdz/aMWUIiQf6sAFMstBwoR3FIFoFhOLGAPWQ4UIs6HFIDiD0SgsNkfbKD4rdE0S8u/N/71uP7tFSh+70gBdMXOPwy5nR7Pzl6B4hHzzaPm+ictoBAh/14BKP5sOVCI4P6gABR/Jhawv1gOFCLOvygAxaNEoLDZH2yg+L3RNEvLjxj/elz/9goUjzhSAF2x89Eht9Pj2dkrUDxmvvmruf5NCyhEyI8oAMXjlgOFCO5RBaB4nFjA/m45UIg4/64AFH8lAoXN/mADxSNG0ywtP2b863H96+xx8b0csPEJpkbFSROfcpSKjSuZjuoT0R9zBCmfcMTOvzpi50olOz2enb0i+pOj36xpnveaSg9eAu4JBUSfsKbdiC6BsVJh3WuR1z2RbN9jZt2s+/3V6IcVBCJ8ETvb309a2u6MHheXQJd1k9udwFuTl/zGxrRtccLWi6x1rTX5+WEN4rr7BLMnHQEJV+z01hxuOz2enb2C2SQDYmub6zoKYDayIBHykwqAsq7liXeEeNfkz07XJRav9da0EyZG7RNxrseHiXBt3rpDm/3Bnp2OdHM8G4NJxr8e17+9AsUkRwqgK3auPeR2ejw7ewWKp5s4foa5rq8FFCLkSQodzQaWA4UIbm0FoNiAWMA2tBwoRJwbKgDFM4hAYbM/2EAxyWiapeWnG/96XP/2ChRPd6QAumLnM4bcTo9nZ69AsbGJ42ea67O0gEKE/HQFoNjEcqAQwT1DASg2IRawTS0HChHnpgpA8UwiUNjsDzZQPN1omqXljY1/Pa5/ewWKjR0pgK7Y+cwht9Pj2dkrUGxu4ngLc91SCyhEyBsrAMVWlgOFCO6ZCkCxFbGAPdtyoBBxPlsBKLYgAoXN/mADxcZG0ywtb27863H96+xx8ec4YOM2TI2Kk1w8Lu6Co7ZlOqpPRN/cEaTcxhE7t3DEzm2V7PR4dvaK6NuZyri9ue6ggOjyGgm4bRQQfUfLEV0CY1uFde9i+XHxzc26WffbwuiHFQQi/B3W5Pt7O0vbndHj4tubdbOPi29PPC6+45r2xglbL7LWXRTyww6OHhffzhGQcMXO7YfcTo9nZ69gtqsBsd3MdXet2akIeTuFBLSH5YlXBLe9wux0D2Lx2tPy2amIc0+F2eluxNmpzf5gz063M5pmaXlX41+P699egWJXRwqgK3buNuR2ejw7ewWK55g43ttc99ECChHyrgpA4VsOFCK43RSAwicWsMByoBBxBgpAsTcRKGz2BxsodjWaZmn5Oca/Hte/vQLFcxwpgK7YufeQ2+nx7OwVKCITx7G5JlpAIUJ+jgJQpJYDhQhubwWgSIkFLLMcKEScmQJQxESgsNkfbKB4jtE0S8uR8a/H9W+vQBE5UgBdsTMecjs9np29AkVh4nhfc91PCyhEyJECUOxvOVCI4GIFoNifWMCeazlQiDifqwAU+xKBwmZ/sIEiMppmabkw/vW4/nX2uPjeDth4IFOj4iQXj4u74KiDXD0uXjiClAc6Yue+jth5kJKdHs/OXhH9YFMZDzHXQxUQXV4jAXegAqIfZjmijwSGwrqPIK+bfVy8MOtm3W9fox9WEIjwD12T7++DLW13Ro+LH2LWzT4ufgjxuPhha9obJ2y9yFqPUMgPhzp6XPxgR0DCFTsPGXI7PZ6dvYLZkQbEjjLXo7VmpyLkgxUS0DGWJ14R3CEKs9NjiMXrWMtnpyLOYxVmp0cRZ6c2+4M9Oz3YaJql5SONfz2uf3sFiiMdKYCu2HnUkNvp8ezsFSieb+L4Beb6Qi2gECEfqQAUx1sOFCK4oxSA4nhiATvBcqAQcZ6gABQvIAKFzf5gA8WRRtMsLT/f+Nfj+rdXoHi+IwXQFTtfMOR2ejw7ewWKk0wcv8hcX6wFFCLk5ysAxUssBwoR3AsUgOIlxAL2UsuBQsT5UgWgeBERKGz2Bxsonm80zdLySca/Hte/vQLFSY4UQFfsfNGQ2+nx7OwVKE4xcfwyc325FlCIkE9SAIpXWA4UIrgXKQDFK4gF7JWWA4WI85UKQPEyIlDY7A82UJxkNM3S8inGvx7Xv84eF9/HARtPZWpUnOTicXEXHFW6elz8FEeQ8lRH7HyZI3aWSnZ6PDt7RfTKVMbaXBsFRJfXSMCdqoDoreWILoFRKqz7NeR1s4+Ln2LWzbrfy4x+WEEgwm/W5Pu7srTdGT0uXpt1s4+L18Tj4u2a9sYJWy+y1tco5IfG0ePilSMg4Yqd9ZDb6fHs7BXMXmtA7DRzPV1rdipCrhQS0OssT7wiuFphdvo6YvE6w/LZqYjzDIXZ6WnE2anN/mDPTiujaZaWX2v863H92ytQvNaRAuiKnacNuZ0ez85egeINJo7faK5v0gIKEfJrFYDiTMuBQgR3mgJQnEksYGdZDhQizrMUgOKNRKCw2R9soHit0TRLy28w/vW4/u0VKN7gSAF0xc43DrmdHs/OXoHiLSaO32qub9MCChHyGxSA4u2WA4UI7o0KQPF2YgE723KgEHGerQAUbyUChc3+YAPFG4ymWVp+i/Gvx/Vvr0DxFkcKoCt2vnXI7fR4dvYKFOeaOD7PXN+hBRQi5LcoAMU7LQcKEdxbFYDincQC9i7LgULE+S4FoDiPCBQ2+4MNFG8xmmZp+VzjX4/rX2ePi/sO2PgepkbFSS4eF3fBUe919bj4uY4g5XscsfM8R+x8r5KdHs/OXhH9fFMZLzDXCxUQXV4jAfceBUR/n+WILoHxXoV1f5C8bvZx8XPNuln3O8/ohxUEIvwL1+T7+3xL253R4+IXmHWzj4tfQDwu/r417Y0Ttl5krR9UyA8XOnpc/HxHQMIVOy8Ycjs9np29gtmHDIhdZK4Xa81ORcjnKySgSyxPvCK4CxRmp5cQi9ells9ORZyXKsxOLyLOTm32B3t2er7RNEvLHzL+9bj+7RUoPuRIAXTFzouG3E6PZ2evQPERE8cfNdePaQGFCPlDCkBxmeVAIYK7SAEoLiMWsMstBwoR5+UKQPFRIlDY7A82UHzIaJql5Y8Y/3pc//YKFB9xpAC6YudHh9xOj2dnr0DxCRPHnzTXT2kBhQj5IwpA8WnLgUIE91EFoPg0sYBNthwoRJyTFYDik0SgsNkfbKD4iNE0S8ufMP71uP7tFSg+4UgBdMXOTw65nR7Pzl6B4koTx1eZ6xQtoBAhf0IBKD5jOVCI4D6pABSfIRawz1oOFCLOzyoAxVVEoLDZH2yg+ITRNEvLVxr/elz/OntcPHDAxqlMjYqTXDwu7oKjPu/qcfErHUHKqY7YeZUjdn5eyU6PZ2eviH61qYzXmOs0BUSX10jATVVA9C9YjugSGJ9XWPd08rrZx8WvNOtm3e8qox9WEIjwp63J9/fVlrY7o8fFrzHrZh8Xv4Z4XPwLa9obJ2y9yFqnK+SHaY4eF7/aEZBwxc5rhtxOj2dnr2D2ZQNi15rrdVqzUxHy1QoJaIbliVcEd43C7HQGsXhdb/nsVMR5vcLs9Fri7NRmf7Bnp1cbTbO0/GXjX4/r316B4suOFEBX7Lx2yO30eHb2ChRfNXE801y/pgUUIuQvKwDFDZYDhQjuWgWguIFYwG60HChEnDcqAMVMIlDY7A82UHzZaJql5a8a/3pc//YKFF91pAC6YufMIbfT49nZK1B83cTxN8z1m1pAIUL+qgJQzLYcKERwMxWAYjaxgN1kOVCIOG9SAIpvEIHCZn+wgeKrRtMsLX/d+Nfj+rdXoPi6IwXQFTu/MeR2ejw7ewWKW0wczzHXb2kBhQj56wpA8W3LgUIE9w0FoPg2sYB9x3KgEHF+RwEo5hCBwmZ/sIHi60bTLC3fYvzrcf3r7HHx0AEbv8vUqDjJxePiLjjqe64eF7/FEaT8riN2znHEzu8p2enx7OwV0W81lXGeud6mgOjyGgm47yog+vctR3QJjO8prPuH5HWzj4vfYtbNut8cox9WEIjwb1uT7+9bLW13Ro+LzzPrZh8Xn0c8Lv79Ne2NE7ZeZK0/VMgPtzl6XPxWR0DCFTvnDbmdHs/OXsHsRwbEbjfXBVqzUxHyrQoJ6A7LE68Ibp7C7PQOYvG60/LZqYjzToXZ6e3E2anN/mDPTm81mmZp+UfGvx7Xv70CxY8cKYCu2Hn7kNvp8ezsFSgWmjj+ibn+VAsoRMg/UgCKuywHChHc7QpAcRexgC2yHChEnIsUgOInRKCw2R9soPiR0TRLywuNfz2uf3sFioWOFEBX7PzJkNvp8ezsFSh+buL4F+Z6txZQiJAXKgDFLy0HChHcTxSA4pfEAnaP5UAh4rxHASh+QQQKm/3BBoqFRtMsLf/c+Nfj+rdXoPi5IwXQFTt/MeR2ejw7ewWKxSaO7zPX+7WAQoT8cwWg+JXlQCGC+4UCUPyKWMCWWA4UIs4lCkBxHxEobPYHGyh+bjTN0vJi41+P619nj4tHDtj4G6ZGxUkuHhd3wVG/dfW4+GJHkPI3jth5nyN2/lbJTo9nZ6+IvtRUxgfM9UEFRJfXSMD9RgHRf2c5oktg/FZh3X8gr5t9XHyxWTfrfvcZ/bCCQIT/4Jp8fy+1tN0ZPS7+gFk3+7j4A8Tj4r9b0944YetF1voHhfzwoKPHxZc6AhKu2PnAkNvp8ezsFcz+aEBsubk+pDU7FSEvVUhAD1ueeEVwDyjMTh8mFq9HLJ+dijgfUZidLifOTm32B3t2utRomqXlPxr/elz/9goUf3SkALpi5/Iht9Pj2dkrUPzJxPGfzfUvWkAhQv6jAlCssBwoRHDLFYBiBbGAPWY5UIg4H1MAij8TgcJmf7CB4o9G0ywt/8n41+P6t1eg+JMjBdAVO/885HZ6PDt7BYq/mTh+3Fz/rgUUIuQ/KQDFPywHChHcnxWA4h/EAvaE5UAh4nxCASgeJwKFzf5gA8WfjKZZWv6b8a/H9W+vQPE3RwqgK3Y+PuR2ejw7ewWKJ0fjeC3zvNfiP/iRBYmQ/6YAFBPWshsoRHCPKwDF2HWP9xlOXMtuoBBxio1soPB46w5t9gcbKP5mNM3SsiShiaOJh+dfZ4+Lxw7YuBZTo+IkF4+Lu+CoSUxH9YnoTzqClGut5YadniN2TlKy0+PZ2Suir20q4zrmuq4CostrJOBEzGx8W89yRJfAmKSw7meQ180+Li7+nkTEVnmOpGQ4EgQi/HXX4vt7bUvbndHj4uuYdbOPi6/D80293lr2xglbL7LWZyjkh3WJ6+4TzNZ2BCRcsXOdIbfT49nZK5itb0BsA3PdUGt2KkJeWyEBbWR54hXByRd7droRsXhtbPnsVMS5scLsdAPi7NRmf7Bnp2sbTbO0vL7xr8f1b69Asb4jBdAVOzcYcjs9np29AsWzTBxvYq6bagGFCHl9BaDYzHKgEMFtoAAUmxEL2OaWA4WIc3MFoNiECBQ2+4MNFOsbTbO0/CzjX4/r316B4lmOFEBX7NxkyO30eHb2ChRbmjjeylyfrQUUIuRnKQDF1pYDhQhuEwWg2JpYwLaxHChEnNsoAMVWRKCw2R9soHiW0TRLy1sa/3pc//YKFFs6UgBdsXOrIbfT49nZK1BsZ+J4e3PdQQsoRMhbKgDFjpYDhQhuKwWg2JFYwHayHChEnDspAMX2RKCw2R9soNjSaJql5e2Mfz2uf509Lp44YOMuTx0Xd8NRu7p6XHw7R5ByF0fs3N4RO3d9CtEHEH03Uxl3N9c9FBBdXiMBt4sCou9pOaJLYOyqsO69LT8uvp1ZN+t+2xv9sIJAhL/HWnx/72ZpuzN6XHx3s272cfHdicfF91zL3jhh60XWurdCftjD0ePiuzkCEq7YufuQ2+nx7OwVzPYxIOaba6A1OxUh76aQgELLE68IbneF2WlILF6R5bNTEWekMDv1ibNTm/3Bnp3uZjTN0vI+xr8e17+9AsU+jhRAV+z0h9xOj2dnr0CRmDhOzTXTAgoR8j4KQJFbDhQiOF8BKHJiASssBwoRZ6EAFCkRKGz2Bxso9jGaZmk5Mf71uP7tFSgSRwqgK3amQ26nx7OzV6DYz8Tx/ub6XC2gECEnCkBxgOVAIYJLFYDiAGIBO9ByoBBxHqgAFPsTgcJmf7CBIjGaZml5P+Nfj+vfXoFiP0cKoCt27j/kdno8O3sFioNNHB9irodqAYUIeT8FoDjMcqAQwe2vABSHEQvY8ywHChHn8xSA4hAiUNjsDzZQ7Gc0zdLywca/Hte/zh4XTx2w8Yinjou74agjXT0ufrAjSHmEI3Ye4oidRz6F6AOIfpSpjEeb6zEKiC6vkYA7QgHRj7Uc0SUwjlRY9wssPy5+sFk3636HGP2wgkCEf8xafH8fZWm7M3pc/GizbvZx8aOJx8WPXcveOGHrRdb6AoX8cIyjx8WPcgQkXLHz6CG30+PZ2SuYvdCA2PHmeoLW7FSEfJRCAjrR8sQrgjtaYXZ6IrF4nWT57FTEeZLC7PR44uzUZn+wZ6dHGU2ztPxC41+P699egeKFjhRAV+w8fsjt9Hh29goULzZx/BJzfakWUIiQX6gAFCdbDhQiuOMVgOJkYgE7xXKgEHGeogAULyEChc3+YAPFC42mWVp+sfGvx/Vvr0DxYkcKoCt2vmTI7fR4dvYKFC83cfwKc32lFlCIkF+sABSvshwoRHAvUQCKVxEL2KmWA4WI81QFoHgFEShs9gcbKF5sNM3S8suNfz2uf3sFipc7UgBdsfMVQ26nx7OzV6CoTBzX5tpoAYUI+eUKQNFaDhQiuFcoAEVLLGCd5UAh4uwUgKImAoXN/mADxcuNpllarox/Pa5/nT0unjlg42ueOi7uhqNe6+px8coRpHyNI3bWjtj52qcQfQDRTzOV8XRzfZ0CostrJOBeo4DoZ1iO6BIYr1VY9xstPy5emXWz7lcb/bCCQIT/urX4/j7N0nZn9Lj46Wbd7OPipxOPi5+xlr1xwtaLrPWNCvnhdY4eFz/NEZBwxc7Th9xOj2dnr2D2JgNiZ5rrWVqzUxHyaQoJ6M2WJ14R3OkKs9M3E4vXWyyfnYo436IwOz2TODu12R/s2elpRtMsLb/J+Nfj+rdXoHiTIwXQFTvPHHI7PZ6dvQLF20wcv91cz9YCChHymxSA4hzLgUIEd6YCUJxDLGDnWg4UIs5zFYDi7USgsNkfbKB4k9E0S8tvM/71uP7tFSje5kgBdMXOtw+5nR7Pzl6B4h0mjt9pru/SAgoR8tsUgOLdlgOFCO7tCkDxbmIBe4/lQCHifI8CULyTCBQ2+4MNFG8zmmZp+R3Gvx7Xv70CxTscKYCu2PnOIbfT49nZK1Ccb+L4AnO9UAsoRMjvUACK91kOFCK4dyoAxfuIBez9lgOFiPP9CkBxAREobPYHGyjeYTTN0vL5xr8e17/OHhfPHbDxg08dF3fDUR9y9bj4+Y4g5QcdsfMCR+z80FOIPoDoF5nKeLG5XqKA6PIaCbgPKiD6pZYjugTGhxTW/VHLj4ufb9bNut8FRj+sIBDhX7IW398XWdrujB4Xv9ism31c/GLicfFL17I3Tth6kbV+VCE/XOLocfGLHAEJV+y8eMjt9Hh29gpmHzMgdpm5Xq41OxUhX6SQgD5ueeIVwV2sMDv9OLF4fcLy2amI8xMKs9PLiLNTm/3Bnp1eZDTN0vLHjH89rn97BYqPOVIAXbHzsiG30+PZ2StQfMrE8afNdbIWUIiQP6YAFFdYDhQiuMsUgOIKYgG70nKgEHFeqQAUnyYChc3+YAPFx4ymWVr+lPGvx/Vvr0DxKUcKoCt2fnrI7fR4dvYKFFNMHH/GXD+rBRQi5E8pAMXnLAcKEdynFYDic8QCNtVyoBBxTlUAis8QgcJmf7CB4lNG0ywtTzH+9bj+7RUopjhSAF2x8zNDbqfHs7NXoLjaxPE15jpNCyhEyFMUgOILlgOFCO4zCkDxBWIB+6LlQCHi/KICUFxDBAqb/cEGiilG0ywtX23863H96+xx8cIBG6c/dVzcDUd92dXj4lc7gpTTHbHzGkfs/PJTiD6A6Neayniduc5QQHR5jQTcdAVEv95yRJfA+LLCumdaflz8arNu1v2uMfphBYEIf8ZafH9fa2m7M3pc/DqzbvZx8euIx8WvX8veOGHrRdY6UyE/zHD0uPi1joCEK3ZeN+R2ejw7ewWzrxkQu8Fcb9SanYqQr1VIQLMsT7wiuOsUZqeziMXr65bPTkWcX1eYnd5AnJ3a7A/27PRao2mWlr9m/Otx/dsrUHzNkQLoip03DLmdHs/OXoHimyaOZ5vrTVpAIUL+mgJQ3Gw5UIjgblAAipuJBewWy4FCxHmLAlDMJgKFzf5gA8XXjKZZWv6m8a/H9W+vQPFNRwqgK3bOHnI7PZ6dvQLFt0wcf9tcv6MFFCLkbyoAxVzLgUIEN1sBKOYSC9h3LQcKEed3FYDi20SgsNkfbKD4ptE0S8vfMv71uP7tFSi+5UgBdMXObw+5nR7Pzl6B4lYTx/PM9TYtoBAhf0sBKL5vOVCI4L6tABTfJxawH1gOFCLOHygAxTwiUNjsDzZQfMtomqXlW41/Pa5/nT0uvq8DNv7wqePibjjqR64eF7/VEaT8oSN2znPEzh89hegDiH67qYwLzPUOBUSX10jA/VAB0e+0HNElMH6ksO6fWH5c/Fazbtb95hn9sIJAhH/HWnx/325puzN6XHyBWTf7uPgC4nHxO9eyN07YepG1/kQhP9zh6HHx2x0BCVfsXDDkdno8O3sFs58aELvLXBdpzU5FyLcrJKCfWZ54RXALFGanPyMWr59bPjsVcf5cYXZ6F3F2arM/2LPT242mWVr+qfGvx/Vvr0DxU0cKoCt23jXkdno8O3sFirtNHP/SXO/RAgoR8k8VgOJey4FCBHeXAlDcSyxgiy0HChHnYgWg+CURKGz2Bxsofmo0zdLy3ca/Hte/vQLF3Y4UQFfs/OWQ2+nx7OwVKO43cfwrc12iBRQi5LsVgOLXlgOFCO6XCkDxa2IB+43lQCHi/I0CUPyKCBQ2+4MNFHcbTbO0fL/xr8f1b69Acb8jBdAVO3815HZ6PDt7BYqlJo4fMNcHtYBChHy/AlD8znKgEMH9SgEofkcsYMssBwoR5zIFoHiACBQ2+4MNFPcbTbO0vNT41+P619nj4vs5YOMfnjou7oaj/ujqcfGljiDlHxyx8wFH7PzjU4g+gOjLTWV8yFwfVkB0eY0E3B8UEP0RyxFdAuOPCuv+s+XHxZeadbPu94DRDysIRPgPr8X393JL253R4+IPmXWzj4s/RDwu/sha9sYJWy+y1j8r5IeHHT0uvtwRkHDFzoeG3E6PZ2evYPYXA2IrzPUxrdmpCHm5QgL6q+WJVwT3kMLs9K/E4vU3y2enIs6/KcxOVxBnpzb7gz07XW40TbIx+Ivxr8f1b69A8RdHCqArdq4Ycjs9np29AsXfTRz/w1yf0AIKEfJfFIBipeVAIYJboQAUK4kF7EnLgULE+aQCUPyDCBQ2+4MNFH8xmmZp+e/Gvx7Xv70Cxd8dKYCu2PmPIbfT49nZK1CsYYJtgrlOnMR/8CMLEiH/XQEo1pxkN1CI4P6hABRj1z3eZ7jWJLuBQsQpNrKBYgJv3aHN/mADxd+NpllaXsP41+P6t1egWGOSGwXQFTsnDLmdHs/OXoFibRNs65jrulpAIUIe+VrlvuNNvutZDhQiuJEv8n3XIxawp1kOFCLOpykAxTpEoLDZH2ygWMNomqXltY1/Pa5/nT0uvr8DNj6DqVFxkovHxV1w1PpMR/WJ6Gs7gpTPcMTOdRyxc30lOz2enb0i+gYm2DY0140UEF1eIwH3DAVE39hyRJfAWF9h3ZuQ180+Lr62WTfrfusY/bCCQIS/0SS+vzewtN0ZPS6+oVk3+7j4hjzf1BtPsjdO2HqRtW6ikB82Iq67TzDbwBGQcMXODYfcTo9nZ69gtqkJts3MdXOt2akIeQOFBLSF5YlXBLehwux0C2Lx2tLy2amIc0uF2elmxNmpzf5gz043MJpmaXlT41+P699egWJTRwqgK3ZuNuR2ejw7ewWKZ5tg29pct9ECChHypgpAsa3lQCGC20wBKLYlFrDtLAcKEed2CkCxNREobPYHGyg2NZpmafnZxr8e17+9AsWzHSmArti59ZDb6fHs7BUodjDBtqO57qQFFCLkZysAxc6WA4UIbmsFoNiZWMB2sRwoRJy7KADFjkSgsNkfbKB4ttE0S8s7GP96XP/2ChQ7OFIAXbFzxyG30+PZ2StQ7GaCbXdz3UMLKETIOygAxZ6WA4UIbkcFoNiTWMD2shwoRJx7KQDF7kSgsNkfbKDYwWiapeXdjH89rn+dPS7+XAds3JupUXGSi8fFXXDUPq4eF9/NEaTc2xE7d3fEzn2U7PR4dvaK6L4JtsBcQwVEl9dIwO2tgOiR5YgugbGPwrpT8rrZx8V3M+tm3W93ox9WEIjww0l8f/uWtjujx8UDs272cfGAeFw8mmRvnLD1ImtNFfJD6Ohxcd8RkHDFzmDI7fR4dvYKZpkJttxcC63ZqQjZV0hA+1qeeEVwgcLsdF9i8drP8tmpiHM/hdlpTpyd2uwP9uzUN5pmaTkz/vW4/u0VKDJHCqArduZDbqfHs7NXoHiuCbYDzPVALaAQIWcKQHGQ5UAhgssVgOIgYgE72HKgEHEerAAUBxCBwmZ/sIEiM5pmafm5xr8e17+9AsVzHSmArth5wJDb6fHs7BUoDjXBdpi5Pk8LKETIz1UAisMtBwoR3AEKQHE4sYAdYTlQiDiPUACKw4hAYbM/2EDxXKNplpYPNf71uP7tFSgOdaQAumLnYUNup8ezs1egOMoE29HmeowWUIiQD1UAimMtBwoR3GEKQHEssYAdZzlQiDiPUwCKo4lAYbM/2EBxqNE0S8tHGf96XP86e1z8AAdsfAFTo+IkF4+Lu+CoF7p6XPwoR5DyBY7YebQjdr5QyU6PZ2eviH68CbYTzPVEBUSX10jAvUAB0U+yHNElMF6osO6XkNfNPi5+lFk3635HG/2wgkCEf+Ikvr+Pt7TdGT0ufoJZN/u4+AnE4+InTbI3Tth6kbW+RCE/nOjocfHjHQEJV+w8Ycjt9Hh29gpmLzXBdrK5nqI1OxUhH6+QgF5meeIVwZ2gMDt9GbF4vdzy2amI8+UKs9OTibNTm/3Bnp0ebzTN0vJLjX89rn97BYqXOlIAXbHz5CG30+PZ2StQvNIE26vM9VQtoBAhv1QBKErLgUIEd7ICUJTEAlZZDhQizkoBKF5FBAqb/cEGipcaTbO0/ErjX4/r316B4pWOFEBX7HzVkNvp8ezsFSgaE2ytuXZaQCFCfqUCULzacqAQwb1KASheTSxgr7EcKEScr1EAipYIFDb7gw0UrzSaZmm5Mf71uP7tFSgaRwqgK3a2Q26nx7OzV6A4zQTb6eb6Oi2gECE3CkBxhuVAIYJrFYDiDGIBe73lQCHifL0CUJxOBAqb/cEGisZomqXl04x/Pa5/nT0ufqADNr6RqVFxkovHxV1w1JtcPS5+miNI+UZH7DzdETvfpGSnx7OzV0Q/0wTbWeb6ZgVEl9dIwL1RAdHfYjmiS2C8SWHdbyevm31c/DSzbtb9Tjf6YQWBCP/Nk/j+PtPSdmf0uPhZZt3s4+JnEY+Lv2WSvXHC1ous9e0K+eHNjh4XP9MRkHDFzrOG3E6PZ2evYHa2CbZzzPVcrdmpCPlMhQR0nuWJVwR3lsLs9Dxi8XqH5bNTEec7FGan5xBnpzb7gz07PdNomqXls41/Pa5/ewWKsx0pgK7Yec6Q2+nx7OwVKN5lgu3d5voeLaAQIZ+tABTvtRwoRHDnKADFe4kF7HzLgULEeb4CULybCBQ2+4MNFGcbTbO0/C7jX4/r316B4l2OFEBX7Hz3kNvp8ezsFSguNMH2PnN9vxZQiJDfpQAUH7AcKERw71YAig8QC9gHLQcKEecHFYDifUSgsNkfbKB4l9E0S8sXGv96XP/2ChQXOlIAXbHzfUNup8ezs1eguMgE28XmeokWUIiQL1QAikstBwoR3PsUgOJSYgH7sOVAIeL8sAJQXEwECpv9wQaKC42mWVq+yPjX4/rX2ePiBzlg40eZGhUnuXhc3AVHfczV4+IXOYKUH3XEzosdsfNjSnZ6PDt7RfTLTLBdbq4fV0B0eY0E3EcVEP0TliO6BMbHFNb9afK62cfFLzLrZt3vYqMfVhCI8D8+ie/vyyxtd0aPi19u1s0+Ln458bj4JybZGydsvchaP62QHz7u6HHxyxwBCVfsvHzI7fR4dvYKZpNNsF1hrldqzU5FyJcpJKCrLE+8IrjLFWanVxGL1xTLZ6cizikKs9MriLNTm/3Bnp1eZjTN0vJk41+P699egWKyIwXQFTuvGHI7PZ6dvQLFZ02wfc5cp2oBhQh5sgJQfN5yoBDBXaEAFJ8nFrCrLQcKEefVCkDxOSJQ2OwPNlBMNppmafmzxr8e17+9AsVnHSmArtj5uSG30+PZ2StQTDPB9gVz/aIWUIiQP6sAFF+yHChEcJ9TAIovEQvYdMuBQsQ5XQEovkAECpv9wQaKzxpNs7Q8zfjX4/q3V6CY5kgBdMXOLwy5nR7Pzl6B4loTbNeZ6wwtoBAhT1MAiustBwoR3BcUgOJ6YgH7iuVAIeL8igJQXEcECpv9wQaKaUbTLC1fa/zrcf3r7HHxgx2wcSZTo+IkF4+Lu+Cor7l6XPxaR5BypiN2XueInV9TstPj2dkrot9ggu1Gc52lgOjyGgm4mQqI/nXLEV0C42sK655NXjf7uPi1Zt2s+11n9MMKAhH+rEl8f99gabszelz8RrNu9nHxG4nHxb8+yd44YetF1jpbIT/McvS4+A2OgIQrdt445HZ6PDt7BbObTLDdbK63aM1ORcg3KCSgOZYnXhHcjQqz0znE4vUty2enIs5vKcxObybOTm32B3t2eoPRNEvLNxn/elz/9goUNzlSAF2x8+Yht9Pj2dkrUHzHBNtcc/2uFlCIkG9SAIrvWQ4UIribFYDie8QCdqvlQCHivFUBKOYSgcJmf7CB4iajaZaWv2P863H92ytQfMeRAuiKnXOH3E6PZ2evQHGbCbbvm+sPtIBChPwdBaCYbzlQiODmKgDFfGIB+6HlQCHi/KECUHyfCBQ2+4MNFN8xmmZp+TbjX4/r316B4jZHCqArdn5/yO30eHb2ChS3m2BbYK53aAGFCPk2BaC403KgEMF9XwEo7iQWsB9bDhQizh8rAMUCIlDY7A82UNxmNM3S8u3Gvx7Xv84eFz/EARt/wtSoOMnF4+IuOOqnrh4Xv90RpPyJI3YucMTOnyrZ6fHs7BXR7zLBtshcf6aA6PIaCbifKCD6zy1HdAmMnyqs+5fkdbOPi99u1s263wKjH1YQiPB/Nonv77ssbXdGj4svMutmHxdfRDwu/vNJ9sYJWy+y1l8q5IefOXpc/C5HQMIVOxcNuZ0ez85eweweE2z3mutirdmpCPkuhQR0n+WJVwS3SGF2eh+xeN1v+exUxHm/wuz0XuLs1GZ/sGendxlNs7R8j/Gvx/Vvr0BxjyMF0BU77x1yOz2enb0CxRITbL82199oAYUI+R4FoPit5UAhgrtXASh+SyxgSy0HChHnUgWg+DURKGz2Bxso7jGaZml5ifGvx/Vvr0CxxJEC6Iqdvx5yOz2enb0CxYMm2H5nrsu0gEKEvEQBKH5vOVCI4H6tABS/JxawP1gOFCLOPygAxe+IQGGzP9hAscRomqXlB41/Pa5/ewWKBx0pgK7Y+bsht9Pj2dkrUCw3wfaQuT6sBRQi5AcVgOIRy4FCBPc7BaB4hFjAHrUcKEScjyoAxUNEoLDZH2ygeNBomqXl5ca/Hte/zh4XP9QBG//M1Kg4ycXj4i446i+uHhdf7ghS/tkROx9yxM6/KNnp8ezsFdFXmGB7zFz/qoDo8hoJuD8rIPrfLEd0CYy/KKz7H+R1s4+LLzfrZt3vIaMfVhCI8P86ie/vFZa2O6PHxR8z62YfF3+MeFz8b5PsjRO2XmSt/1DID3919Lj4CkdAwhU7HxtyOz2enb2C2RMm2Faa65Nas1MR8gqFBOStbXfiFcE9pjA7Hbvu8T7DNda2EyZG7RNxio3s2elK4uzUZn+wZ6crjKZZWn7C+Nfj+rdXoHjCkQLoip0rh9xOj2dnr0Ax0cTxmua61tr8Bz+yIBHyEwpAMclyoBDBrVQAiknEAra25UAh4lxbASjW5K07tNkfbKB4wmiapeWJxr8e17+9AsXEtd0ogK7YueaQ2+nx7OwVKNY1cbyeuT5NCyhEyPLFLjZPtxwoRHDyxQaKpxML2DMsBwoR5zMUgGI9IlDY7A82UEw0mmZpeV3jX4/r316BYl1HCqArdq435HZ6PDt7BYoNTBxvaK4baQGFCHldBaDY2HKgEMGtpwAUGxML2DMtBwoR5zMVgGJDIlDY7A82UKxrNM3S8gbGvx7Xv84eFz/MARs3YWpUnOTicXEXHLUp01F9IvoGjiDlJo7YuaEjdm76FKIPIPpmpjJubq5bKCC6vEYCbhMFRN/SckSXwNhUYd1bk9fNPi6+gVk3634bGv2wgkCEv8XafH9vZmm7M3pcfHOzbvZx8c15vqm3XNveOGHrRda6tUJ+2IK47j7BbDNHQMIVOzcfcjs9np29gtk2BsS2NdfttGanIuTNFBLQ9pYnXhHc5gqz0+2JxWsHy2enIs4dFGan2xJnpzb7gz073cxomqXlbYx/Pa5/ewWKbRwpgK7Yue2Q2+nx7OwVKHYycbyzue6iBRQi5G0UgGJXy4FCBLetAlDsSixgu1kOFCLO3RSAYmciUNjsDzZQbGM0zdLyTsa/Hte/vQLFTo4UQFfs3HnI7fR4dvYKFHuYON7TXPfSAgoR8k4KQPEcy4FCBLezAlA8h1jA9rYcKESceysAxZ5EoLDZH2yg2MlomqXlPYx/Pa5/ewWKPRwpgK7YueeQ2+nx7OwVKHwTx4G5hlpAIULeQwEoIsuBQgS3pwJQRMQCFlsOFCLOWAEoAiJQ2OwPNlDsYTTN0rJv/Otx/evscfHnOWBj+tRxcTcclbl6XNx3BClTR+wMHLEzewrRBxA9N5WxMNd9FRBdXiMBlyog+n6WI7oERqaw7gMsPy7um3Wz7hcY/bCCQIS/79p8f+eWtjujx8ULs272cfGCeFx8v7XtjRO2XmStByjkh30dPS6eOwISrthZDLmdHs/OXsHsQANiB5nrwVqzUxFyrpCADrE88YrgCoXZ6SHE4nWo5bNTEeehCrPTg4izU5v9wZ6d5kbTLC0faPzrcf3bK1Ac6EgBdMXOg4bcTo9nZ69A8TwTx4eb6xFaQCFCPlABKI60HChGBKcAFEcSC9hRlgOFiPMoBaA4nAgUNvuDDRQHGk2ztPw841+P699egeJ5jhRAV+w8fMjt9Hh29goUx5g4PtZcj9MCChHy8xSA4vmWA4UI7nAFoHg+sYC9wHKgEHG+QAEojiUChc3+YAPF84ymWVo+xvjX4/q3V6A4xpEC6Iqdxw65nR7Pzl6B4ngTxyeY64laQCFCPkYBKE6yHChEcMcqAMVJxAL2IsuBQsT5IgWgOIEIFDb7gw0UxxhNs7R8vPGvx/Wvs8fFD3fAxpc8dVzcDUe91NXj4sc7gpQvccTOExyx86VPIfoAop9sKuMp5voyBUSX10jAvUQB0V9uOaJLYLxUYd2vsvy4+PFm3az7nWD0wwoCEf7L1ub7+2RL253R4+KnmHWzj4ufQjwu/vK17Y0Ttl5kra9SyA8vc/S4+MmOgIQrdp4y5HZ6PDt7BbNTDYiV5lppzU5FyCcrJKDa8sQrgjtFYXZaE4tXY/nsVMTZKMxOS+Ls1GZ/sGenJxtNs7R8qvGvx/Vvr0BxqiMF0BU7yyG30+PZ2StQdCaOX22ur9ECChHyqQpA8VrLgUIEVyoAxWuJBew0y4FCxHmaAlC8mggUNvuDDRSnGk2ztNwZ/3pc//YKFJ0jBdAVO1895HZ6PDt7BYrXmTg+w1xfrwUUIuROASjeYDlQiOBerQAUbyAWsDdaDhQizjcqAMUZRKCw2R9soOiMpllafp3xr8f1b69A8TpHCqArdp4x5HZ6PDt7BYozTRyfZa5v1gIKEfLrFIDiLZYDhQjuDAWgeAuxgL3VcqAQcb5VASjOIgKFzf5gA8XrjKZZWj7T+Nfj+tfZ4+JHOGDj25kaFSe5eFzcBUed7epx8TMdQcq3O2LnWY7YebaSnR7Pzl4R/RxTGc811/MUEF1eIwH3dgVEf4fliC6BcbbCut9t+XHxM826Wfc7y+iHFQQi/PPW5vv7HEvbndHj4ueadbOPi59LPC7+jrXtjRO2XmSt71bID+c5elz8HEdAwhU7zx1yOz2enb2C2XsMiL3XXM/Xmp2KkM9RSEAXWJ54RXDnKsxOLyAWrwstn52KOC9UmJ2+lzg7tdkf7NnpOUbTLC2/x/jX4/q3V6B4jyMF0BU73zvkdno8O3sFivebOP6AuX5QCyhEyO9RAIoPWQ4UIrj3KgDFh4gF7CLLgULEeZECUHyACBQ2+4MNFO8xmmZp+f3Gvx7Xv70CxfsdKYCu2PmBIbfT49nZK1BcYuL4UnP9sBZQiJDfrwAUH7EcKERwH1AAio8QC9hHLQcKEedHFYDiUiJQ2OwPNlC832iapeVLjH89rn97BYpLHCmArth56ZDb6fHs7BUoLjNxfLm5flwLKETIlygAxScsBwoR3KUKQPEJYgH7pOVAIeL8pAJQXE4ECpv9wQaKS4ymWVq+zPjX4/rX2ePiRzpg46eZGhUnuXhc3AVHTXb1uPhljiDlpx2x83JH7Jz8FKIPIPoVpjJeaa5XKSC6vEYC7tMKiD7FckSXwJissO7PWX5c/DKzbtb9Ljf6YQWBCP+qtfn+vsLSdmf0uPiVZt3s4+JXEo+LT1nb3jhh60XW+jmF/HCVo8fFr3AEJFyx88oht9Pj2dkrmE01IPZ5c71aa3YqQr5CIQFdY3niFcFdqTA7vYZYvKZZPjsVcU5TmJ1+njg7tdkf7NnpFUbTLC1PNf71uP7tFSimOlIAXbHz80Nup8ezs1eg+KKJ4y+Z63QtoBAhT1UAii9bDhQiuM8rAMWXiQXsWsuBQsR5rQJQfIkIFDb7gw0UU42mWVr+ovGvx/Vvr0DxRUcKoCt2fmnI7fR4dvYKFDNMHF9vrl/RAgoR8hcVgOKrlgOFCO5LCkDxVWIBm2k5UIg4ZyoAxfVEoLDZH2yg+KLRNEvLM4x/Pa5/ewWKGY4UQFfsvH7I7fR4dvYKFDeYOL7RXGdpAYUIeYYCUHzdcqAQwV2vABRfJxawb1gOFCLObygAxY1EoLDZH2ygmGE0zdLyDca/Hte/zh4XP8oBG2c/dVzcDUfd5Opx8RscQcrZjth5oyN23vQUog8g+s2mMt5irnMUEF1eIwE3WwHRv2U5oktg3KSw7rmWHxe/waybdb8bjX5YQSDCn7M23983W9rujB4Xv8Wsm31c/BbicfFvrW1vnLD1Imudq5Af5jh6XPxmR0DCFTtvGXI7PZ6dvYLZdw2Ifc9cb9WanYqQb1ZIQPMsT7wiuFsUZqfziMXrNstnpyLO2xRmp98jzk5t9gd7dnqz0TRLy981/vW4/u0VKL7rSAF0xc7vDbmdHs/OXoHiByaO55vrD7WAQoT8XQWg+JHlQCGC+54CUPyIWMButxwoRJy3KwDFfCJQ2OwPNlB812iapeUfGP96XP/2ChQ/cKQAumLn/CG30+PZ2StQ3GHi+E5z/bEWUIiQf6AAFAstBwoR3HwFoFhILGA/sRwoRJw/UQCKO4lAYbM/2EDxA6NplpbvMP71uP7tFSjucKQAumLnnUNup8ezs1eguMvE8SJz/ZkWUIiQ71AAip9bDhQiuDsVgOLnxAL2C8uBQsT5CwWgWEQECpv9wQaKO4ymWVq+y/jX4/rX2ePiRztg4y+fOi7uhqPucfW4+F2OIOUvHbFzkSN23vMUog8g+r2mMi421/sUEF1eIwH3SwVEv99yRJfAuEdh3b+2/Lj4XWbdrPstMvphBYEI/761+f6+19J2Z/S4+GKzbvZx8cXE4+L3r21vnLD1Imv9tUJ+uM/R4+L3OgISrti5eMjt9Hh29gpmvzEg9ltzXao1OxUh36uQgB6wPPGK4BYrzE4fIBavBy2fnYo4H1SYnf6WODu12R/s2em9RtMsLf/G+Nfj+rdXoPiNIwXQFTt/O+R2ejw7ewWKZSaOf2+uf9ACChHybxSA4o+WA4UI7rcKQPFHYgFbbjlQiDiXKwDF74lAYbM/2EDxG6NplpaXGf96XP/2ChTLHCmArtj5+yG30+PZ2StQPGzi+BFzfVQLKETIyxSA4k+WA4UI7vcKQPEnYgH7s+VAIeL8swJQPEIECpv9wQaKZUbTLC0/bPzrcf3bK1A87EgBdMXOR4bcTo9nZ69AscLE8WPm+lctoBAhP6wAFH+zHChEcI8oAMXfiAXsccuBQsT5uAJQPEYECpv9wQaKh42mWVpeYfzrcf3r7HHxYxyw8R9PHRd3w1FPuHpcfIUjSPkPR+x8zBE7n3gK0QcQfaWpjE+OVsh1lB68BNw/FBB9jXXsRnQJjCcU1r0med3s4+IrzLpZ93vM6IcVBCPCX4fv75WWHxd/0qybfVz8SeJx8bExbVucsPUia11zHX5+8Ijr7hPMVjoCEq7Y+eSQ2+nx7OwVzNYyIDbJXNdWALORBYmQVyoAyjqWJ14R3JMKs9N1iMVr3XXshIlR+0Sc6/JhIpzEW3dosz/Ys9OVRtMsLa9l/Otx/dsrUKy1jhsF0BU7Jw25nR7Pzl6B4mkmjp9urs/QAgoR8loKHc36lgOFCE6+2ECxPrGAbWA5UIg4N1AAiqcTgcJmf7CBYi2jaZaWn2b863H92ytQPM2RAuiKnU8fcjs9np29AsVGJo43NtdnagGFCPlpCkDxLMuBQgT3dAWgeBaxgG1iOVCIODdRAIqNiUBhsz/YQPE0o2mWljcy/vW4/u0VKDZypAC6YufGQ26nx7OzV6DYzMTx5ua6hRZQiJA3UgCKLS0HChHcxgpAsSWxgG1lOVCIOLdSAIrNiUBhsz/YQLGR0TRLy5sZ/3pc/zp7XPxYB2zcmqlRcZKLx8VdcNQ2TEf1ieibOYKUWzti5+aO2LnNU4g+gOjbmsq4nblur4Do8hoJuK0VEH0HyxFdAmMbhXXvbPlx8c3Muln329zohxUEIvztFY6Lb2tpuzN6XHw7s272cfHteL6pd1jH3jhh60XWurNCftje0ePi2zoCEq7Yud2Q2+nx7OwVzHYxILarue6mNTsVIW+rkIB2tzzxiuC2U5id7k4sXntYPjsVce6hMDvdlTg7tdkf7NnptkbTLC3vYvzrcf3bK1Ds4kgBdMXOXYfcTo9nZ69AsZeJ4+eY695aQCFC3kUBKPaxHChEcLsqAMU+xALmWw4UIk5fASieQwQKm/3BBopdjKZZWt7L+Nfj+rdXoNjLkQLoip3PGXI7PZ6dvQJFaOI4MtdYCyhEyHspAEViOVCI4J6jABQJsYCllgOFiDNVAIqICBQ2+4MNFHsZTbO0HBr/elz/9goUoSMF0BU7oyG30+PZ2StQ5CaOC3PdVwsoRMihAlDsZzlQiOAiBaDYj1jA9rccKESc+ysARUEECpv9wQaK0GiapeXc+Nfj+tfZ4+LHOWDjAU8dF3fDUQe6elw8dwQpD3DEzsIROw98CtEHEP0gUxkPNtdDFBBdXiMBd4ACoh9qOaJLYByosO7DLT8unpt1s+5XGP2wgkCEf8g6fH8fZGm7M3pc/GCzbvZx8YOJx8UPXcfeOGHrRdZ6uEJ+OMTR4+IHOQISrth58JDb6fHs7BXMjjAgdqS5HqU1Ox0RskICOtryxCuCO1hhdno0sXgdY/nsVMR5jMLs9Eji7NRmf7BnpwcZTbO0fITxr8f1b69AcYQjBdAVO48ccjs9np29AsVxJo6fb64v0AIKEfIRCkDxQsuBQgR3pAJQvJBYwI63HChEnMcrAMXziUBhsz/YQHGE0TRLy8cZ/3pc//YKFMc5UgBdsfP5Q26nx7OzV6A40cTxSeb6Ii2gECEfpwAUL7YcKERwz1cAihcTC9hLLAcKEedLFIDiJCJQ2OwPNlAcZzTN0vKJxr8e17+9AsWJjhRAV+w8acjt9Hh29goUJ5s4PsVcX6YFFCLkExWA4uWWA4UI7iQFoHg5sYC9wnKgEHG+QgEoTiEChc3+YAPFiUbTLC2fbPzrcf3r7HHx5ztg46ueOi7uhqNOdfW4+MmOIOWrHLHzFEfsPPUpRB9A9NJUxspcawVEl9dIwL1KAdEbyxFdAuNUhXW/2vLj4iebdbPud4rRDysIRPj1Onx/l5a2O6PHxSuzbvZx8Yp4XLxZx944YetF1vpqhfxQO3pcvOypQIdxWTexn/tlF4V13qZFGRVhk7Rx0LYIk67JqsCPsyzGQ+6aKqji1g+KJorTMu8qVUip+noGSVZkoR91WelXYVyESSKCq5sgrbqibbq69f0k6KoCKozwKKqoxt8p8yxssiav/q97+//9q1cAeo0Bntea62ljYpHu2Bd4Oo5ddQYzXnGXxAR8+jpurLkirvmMvtY8zgBmrvn19hbakaCXQD9tdeBTtmVTp21bFH7bQClhVwRZUVR+kCRt2oVVErVRmENAedQEBdAxaSCcNMcjCbOUWLCC1xD98QZL57yj9kkuJMbJSG59g8Kcd3VaHC+Ev/afaXGcz+C1RAg/najFNzqgxdeTtfjGnrToj+8ViJ9fr9CAvMkBn59G9vmblHyusfaSvPbXKOxDMzn0zIH1dkEcJ2GUdGEQ53VS5GmSZ0FadHVQ1U2eZ5WfN3Hj+znqfJekRYqtydgvkrTN01gjDsW+MxXi8CzLByBi31kK636zA/mnIsfgaxVikNkjvGXsehFXXYQ/2+ZlXaBB6cKi9JO88bsy96si8usszLPIr7KyitK6xV27KAek110WdYmGFsW+tyho8a2Wx6DY91aFdb9Ned1B2jZo74Ooqorar9O0bIOgiMO4a5qqruoiCuKmLtDtN21bJkmT1mmcxFFTx4UftSM14c0K697m6brrDqvCr6oSZayWkCm6NMjarKmrrs3D1m+6zE/LKo39usVYIKuyIiiLqMriNkqzKG1E429TWPe25HWPvtibU28n5l2ir4Oxzy/ENCJtEwx1irZq/DrJsiJHHuyyJmyLuI6KJAyasiziLM/DMCtrzCWqOkoRCmkQlavTjT++VyDP7e0Kujnb8vwo9p2tsO5z1nEjXs4da2dXFE3qI5NEeR5VHTA5q/3WD5GJ/Sxr2zgPysyvqyjMsiYGWmPummUYQoZBCZ2OjReMLMsWs7e8yYowlz8ah3WSRkXr51EWFFWUtXEaFGHQpphKN0VSZEGDfI60lgPgB+Il9jFcyeu87Oosj7q0KhEQQd4gGDI/8/0oBL3HaVEldeWnbZGmeeiHUVDXflJFrYZu5Lmdq6Cb8yyPF7HvPIV1v8OReHnngJ11nYZx2lVB1JVdntWFnwZh0AU5ggjJO5NijexdtWkaVXkV5U0gF4zqy6pqxsZL4EP5iI0kr7s2DPIkSruoSsM2jqKkKhIgQRYKLId1mGNTA1vpRQGpx6EUkDAciBdQUBpg3N3UQIQgCRr8wyUi1Y9qxEQVJFnnR9hQSLo2iqImDbumjJuwTABZlQ5/y3N7p4Ju3mV5vIh971JY97u1+Rv7alkXBwGE18Z1UYUVMn/ZJcCQEmm/iKs2q4OgbMI4yrCF0jYwPinCqsyDIK+EJc5RWPd2yvw93r5DasI7FNa9veV9h8T2uxXWvYNS37Em2c73EPsOosYDom6Csb5AEQog+rKtsMla5mFeRlnaoAaWXVyi2NV5lVUdepcmRtMSFnnbZah/8rM8CdNmdRr0x/cKxAfvUdDgey2vMWLfexXWff46bsTeBWPtRAeTRsjXfpY0qFtdXed+is65wR5/HYVxGEKtYSmtQ4n+IC3jFBsB8sM4x/RxIPbG2Q9tT+yHBmIvCzMk3SqspSD5EXgT2BblbVAHTew3oR9F2PUIwadRElZ1kIAF87Jpmq6oqyzX0KD44AIFDV5oeeyJfRcqrPt9jsTe+8fYGaKTKKqujGPoti7zBtpD45IVgMYg7vIgLBA/lV/lOdAiCIGP6HQQQGEYJmk+GHvj7K22J/ZWA7EXxW0dJ3WJkA+zOmyzuKyw0LAMYozuMNfrqgYPKYpBUVmTVrkc0YoQ1QkWFIUaGhQfvF9Bgx+wPPbEvg8orPuDlvdWwjjnK6x7R8t7K6kv71NY906W91YS2x9UWPfOjvRWHyL2VkSNB0TdBGN9ESRVEiaoIHhcbQAq7fI0rIF7XYb/l/plFfjIBIlfRhHSRS3lqutS2UYHhoYqfCc++JCCBi+yvMaIfRcprPtiR/juEmJvtSOxt9qJ2FsN5MGmzruySZuijaso6ZK2KcoIm00p0nLdosny27wU1kxyoGnYZD56rratuxQ/7FINDYoPLlHQ4KWWx57Yd6nCuj/sSOx9hNhb7UjsrXYi9lYDda/Cf0y6rg4DxHldpiCmzE8QjlFXJWnWlnGLWM473D7o2rrIcj9JgryMEd9NUWtoUHzwEQUNftTy2BP7Pqqw7o9Z3lsJ41yssO5dLO+tpL58WGHdu1reW0lsf0xh3bs50ltdRuytiBoPiLoJdhuoV5iLAwKrLAzqsunaou1QPSs/SLs6QohgF6uUcpVkeYEEEWQ1Hlze+GnRtElSrE6D/vhegfjgMgUNXm55jRH7LldY98ctX7f4+uMK6/7EWF6MoziO0Il1adwBGwP0RFnb4E9HXQ24StMc7VyV+igXZZCFsTRVPjqcukUz04bemNdaq9g53hr7CeLvHXxy7Jq7rkgT9I1hUsVd1nZ+mudVI62b33XoTuOmK9sMVqAa5l0XgJOTOo7KMq2TKGnG5q8wgFXYRKulHW3Q8PpZhWF/WOCfaBopIKkv1TMPmhDlJmjx37A30ICU/apNurH5KwizHA0oemJpbUO/xQadD7ptAdtYcd36VVRFWHbe1kFd+QkeL27k5wUovW2igfxVVGWR4ZVnIdAcLI0thgj1zU+zJMYcSPYn8M/VAGbcr6nR8kaC3FUVAQhUZkPig08q6PlTlsex2PcphXV/2vJ1i68/rbDuyWNjOSw7tLpV1yRN1mLU1KCNRVWuEY0R5k0QeFW2KWC2bnxEsB9XSDwBesUScRAE3pjXpFXXH7QI565KE2zaIf8FkZy6L0PJTVWNZIaM6UdJ0PixHzdRGmZlihlPlkVB2kRxMjZ/jTcXTibmwivG2tVUAN82w+wtLZD3gzhBr99GDfYsczT3GFVhYXncoGuIujiOc+xOAoiDJKxzjMgGciHIKCozcBKyV1GmBUYDLbId5n5lXsVBkmAT1E+7EkmxaqO6LoKqqaKyxp8MmyoZYLkS8BXkjfyOQwGP+ikmaHnbFrU08UndFUhleZ5gfth2+DN5HRVwQ4uWBt1KXg5wdVfjOXVYV5SltfylqMTf7TAUCbvWx/C8TcMKHUGVYnoCc4I4y/BnUSSKvCsyjdgQH1yhEBtXWp4TxL4rFdZ9leXrFl9fpbDuKWNjOe6qJsq6EoGZtjFiIcvL0G+KqAYE+DXQIoPosyrGsDwKI2wYYRaIeaAMABA63pjX2qvYiW7ZDwATiDUfrQ5SapGgcQZmJFUUI6MGCLwMw+6yAUzUUZa0GDrGZVIETYPMMjYXjjevTibm1SnEvPqZgd+RAWTFmV+iJGErAgUJTxAjFORRpKyowt5dnmOAmSTSZyb4V4OwQWpqkzbyE3+AMQPs8EV4rlFTFXmNOQ0SGbY5EkxgMWctsPGRgDZlP6VFskZy9DtMQnNMOn0QaDKYV+OkxJSnlD8Jmg+aDuPRsgZTgm/xb2PygRlu5YcYsfrYjSlaZE7s5BR5mSJ3DzJmmHd+UCRlK/8F1RS1uKk71NywaHM/xGYL8BklIMg6VIsOrgYhtzKYTfD/VM52ig8+oxBnn7U8v4h9n1VY9+csX7f4+nMK6546NsckZREWyE0IWdlvb2LssRfSHCPJIvfkkj5r2XPocJcWHXJXlhl25CuERhom3pjXOquuP8+iJImqIo66IuyqLEjR9cnRMOx7gIrQm5ZANDlFFtQJxrK4PSirBeRURdkEA4w5zhw9mZijpxBz9FRijv782DViapegGS/zGv8ljEKkpRxuwNZShr4hR2sdlyihmBLj1tjRxkLDqq0Ah7hpWg3kaL+MG0wLkxRTET+viirF+ARVNe2weJAuNrmgmQzzFNkmQ++P5Aw1waNhUvgDORrbY21QYuwocxg87KJLgrLOwy4rgxQpuyiQv6MiKlsUkQimYX+9Cgt5K5O0xO7ZAPvWBaYXqDcQVdBhwIBbNXGRxQ3UXHRdVGBzL09jrL5FAcnqDi6C0soS3ml8lTmm+ODzCjF7teW5Suy7WmHd11i+bvH1NQrrnjYw08uaFhwUoukvId4wDEC4bSXbOR16ujxq0SeGbZ7gX0TyjOsQcz0EXooGFXvk3pjXuqvYCczBtLDxcasi62SCFmLLqKtyYBmwDmlZDpBgmBc0WVYVKaaALfbKMHEo4i5oB+at4833k4n5fgox308l5vtpxHz/hbFrxDQjlBloGDZFBecg70lilmMOXVI2TRHKH8CsAYkVyVn2gIoqrpG627KKs4F9K+wDFU2OVWZdkBaRLzkZWbsD8GZtkolmkLzbFjWmi5FmsyrtMM+QLI1JezQw9w1a/PEi7aIoiQKMcrEg7DBBXB2GtG2ELcou6ADUKCeJn1Zl5GMmLEUmg0OreIDJMeHCvmaGeX7WYHc3qhN4KozyOMScAxrGTCzI87SOAtnq7OrQR31DsGB+jTmwyu/Aiw++oBD/X7Q874l9X1RY95csX7f4+ksK654+dt1IJdi4Cks5OJhjnyUvoyDB365jYBE6T6SutJOdnhb5BxQOTsJeT5yhB03qMPPGvNZbxc4wAgZFMe6KsXLXNAkGKmHcFUGBHZi8rJoA/7gfIq+mkR9iqoL0kWJbpSxKNNx5OLC/Ns7aMZlYO6YQa8dUYu2YRqwd04m148tj7YLSsMeHdInHk0Zdh9VV+Ekquw5t4PtlgmJS1zAULhJ/oF1MC4zQZWctDAfnOXGXZNgQjLBE/P8FWkp4VjYFyyYr4Qzs/KErwb5flcGfUQenV/8D6TX2aAdqB5J4HZUdZi6oLk2IHY4ib/D8Y9n+QwuBHUT0EmHRYHeyq0eG+lXVjsy+i7RNB2pHnRdNCYknmPUAo/wshXplZFO1eYoNYTk22IKbUgzG5WfYQi2yNAuqOKxLnd9ZEh98WSGXXGt5DhX7rlVY93WWr1t8fZ3CumesM9Bf+8i2iIQc08oA++ySMZHYg7gEi2EKiu3xGhPVDt/lqY9uv05QZmr5vYk2GegVnrbq+jNpseMkyGS/q0kxiq3qIMbWGNJ+mcj7z4dylgihn6InL+q8BYnJqFV+PSOIBmrHOOvQZGIdmkKsQ1OJdWgasQ5NJ9ahGcQ6dP3YNWI/ByUGzwKZP8ggDOkZIrQHTeA3si0aI/+jZYhblAOsoMKzxNBKdoJQCKrBHqYLZELVxEj0EF8pv3iKeT62QzMUlKRA/4L/gr3cpKqyqJXfz2hLPPw4jfFtNTCzqv26QxnEg4jQ8viQdhvLGzv4UAn2HNoCzTkGpNiblU8hwJZzJ8fUsfGBrYO2GphZBRX+WIH9jLaB1RF2gnPczMe2scRtDaszP8rCRE6Uo/HClKpJ2rAOwrTpCkxqNfKS+OB6hbz0Fcvzsdj3FYV1f9XydYuvv6qw7pkD84gwzdsuz/wsStuRt3jEbl3VYkIBHgT9oZYUUhriuvajuk0izBUi+aWnrsMuW+yNeT19FTsDbBhW2G/ssCuBtIu5A3iy7mr59JOgwhQkbMpMkn0QViDXHHuOcg4kaOocvFeWAzOrcda0ycSaNoVY06YSa9o0Yk2bTqxpM4g1bSaxpn1t4HnlVVA1HTwuLQlmW3kelWERJ6G8+WkQNG2cxQgLdDAoBWXYJbhNhf2MNA1Rngb3YRpst4TYoGviFHvPaI6SrobmkkTOGMXYPvHTtK5kHBaA82RsXLf4c6lIsq4Gz2O2UlaikXeBhzo7xFTQIFz9Bns22DyXtcEM7JDXHSaEeKYZHkcsv5dbpVk7sA9TSO9WyWqqCFLGZlDSxNjoz7DN1OAvYknYZ4JTSwQ5XFg3VYD9KAhc6mmkkePEB19TyHE3WJ7bxb4bFNZ9o+XrFl/fqLDuWWNjGcUJ/4cUhy3OOMWoO8R2pQ9ADcCTcR5iHodcmNeF36JEpAWQDRkykGPmKCUD58mfsYqdgpc5xnhNmWKXNUbGCJoyj9IOfIn+bOQkNGop5vvYMe1QpwqMzOXcDDY7MT0Z2IcZb32cTKyPU4j1cSqxPk4j1sfpxPo4g1gfZxLr4yxiffz6WD9if0k+u66G7UXSYW8oTxtsSNXy+/NwDP79Isywk5VgGF7lEYolpogVQhFbW3DsQH0sYC/mHygv8hiapEgizA7RZmFMid0vcGaJJwSFNgX2hbBPlCZ4rhKiSYZZyUB9RKWNghptnBy6zSOEBmIlSOo4jqsY3SfmiPjHwroOcLu2xiYs6i++BeqGYZiNrY9y/jcKM6ysw/NqsgLzfMRBKe8VCL0ik8ivqJQJdq2qFju9aZHWpTBB7UMkmUq+FB98XSFffsPyOiH2fUNh3d+0fN3i628qrHv22FjO2lzeVRmpExm2zIsaaS1FPawyzFyiMh55IzAEHyaRqJwxEmGATVxsBYcxdqIH6uP6q64/iXwZhGDcU7e4cV7VuG3cIDUVkZyESBNJl0BNbGmjhPohIl62rFtUFVwGf19hfLV2MrHWTiHW2qnEWjuNWGunE2vtDGKtnUmstbOItXY2sdbeNHCGHv+6bOvlI+rxczgck1B8W/pB0dW+L8KourTOoda0yvFfYJKfBm0WZGU9UGtRkNG5Bghm7MhBCjk2/roQ24Zd5rdBmSTyjjgou5isym/qVfnI7oMfdojcOMkGam2UpVGJTBD6QdiVXdphw9AP8QOkiyovfOQJsIHfJkgpRShvbdNmWCaqKjrPshqYr3ZNAgBHS40eGX81T5LM7/IU5b/FPmGSpg1iCdLDg8ywxippsfA4DbIU9bdTef8M8cFNCrn3Zstrjth3s8K6b7F83eLrWxTWPWcgX8WCkS12q4uuRR7B7gY23pu0RqZMcsxWs6JGvseuOe6CWhdKYUEjioSJ6WvhjXltsIqdIQIEGyZhkGBshRKWVF0GA4M0yFvsVhR+Fecl0mhZYRsx7LpaDiXWflHXSdYi9Q7MV8dZtycT6/YUYt2eSqzb04h1ezqxbs8g1u2ZxLo9i1i3ZxPr9hxi3f7WgL7qNpKjvKEPoWUIpqCJsmrkE05CZIG4wIg2guXomIvKlyOSqMFlCu+Egd92g7/TX8t7WuEJR9hdTbuiKyuIOkCoYGfS97MSXWjsI5wQ9fKbqUmKKEVIYbwcQd+7Dr6PCP4bHniSV9jpLLKRNFDF4AKkpkjYvw7RQo/8Lhieq4hf3rUREYEZcTdwPsdP5JecC2z7dnje8uv8QdulPjSEfjgp6wwySgts0cYFRtwNbg0Zy6ZvmaUIW5WzneKDbynk8W9bXr/Evm8rrPs7lq9bfP0dhXXPHeiRa7+Mgy6uK9RtbKQAk+NGAlw+xqtDZUQBQY0MI2yWdoGfN20ZVBWmSpLnytIb89pwFTsDeXMAhLVfyNyswlQpRhxjjISgLxDc8n752IFtYHAm79yB3R/Ubz+VX76skeAGzueMkwEmExlgCpEBphIZYBqRAaYTGWAGkQFmEhlgFpEBZhMZYA6RAeYSGeC7Y/0YyooQY/A7anEI5i+xd1xD4lGaybvEIkJhawNLAnS8Jaop2vwSI/HIL6Ns8Ixu2NQ+Uk6BIJdfmyvrFtHdQj4jfyOK5LPSWjkzKL+bgTF0HRVFG1V+gB1qvx5gAKiyK7Kmqys8/UAaEMz65F145MMA2hbb3GGOoA5QuLFLnNYtQr+o5K2WohJD/IE5OTwPBaDHr3w8oVJ+3zqsGgzy0xZ7bUgKdeZjvI6JPTaXoxiPA/QRYJ4QxmWbq3xmm/jguwo14XuW10Kx73sK677V8nWLr29VWPe8sTmmk1/NRfLPEWFBhf2fKAsjfBNiAAV07+JO9BwCiX0fO2FIPHURYOMZQRnmfueNeW206vrbDKkKObzKSkmCBaoQRu0ouBH+FUnxYRLXMLTFtL5DLstk2NagBmObze8G95HHyROTiTwxhcgTU4k8MY3IE9OJPDGDyBMziTwxi8gTs4k8MYfIE3OJPDGPyBO3DfAEWo8UzzWQ/YCwC3JshedZgsccI0RkdpBIGqqzsIQjZbYob5DdgRzw72UD73MaSEQgQrCrJ7/0X5QZSru8ySC20Ju6qLGnUGGfP8dfTfHP4XH5GM5LOceUwo/CgbPWsEA+xAvPNakQxvh30SRFeYQt97IM27hNoPMU2/d1g/+SIaTkQA4GAdgOQNAOvjcWdiPKAnsXcYIdgKiVnQyEWxHgKWWZvEsa7iDvViNvEgR0yjIkjVreaz+WwJB7sOuL+OA2hfryfcvrqtj3fYV1/8DydYuvf6Cw7vljYznpgNtI53lbhMhBWYXkEQUVam3XNWGTyVFOeVu4Att0SFSIPB/fYcDQhkGapN6Y18ar2InE1PhBkyZNKXt7RYLgRVaUrAeUaPKuHDlw0zb4D61fyO+cp2grsLUIPM/LYmAvYJxsMpnIJlOIbDKVyCbTiGwyncgmM4hsMpPIJrOIbDKbyCZziGwyl8gm84hsMp/IJj8cePZBg/EAyneHp58WiBOEAaK8lNkpjMi7LC1lN6RrMeOoIGFkNzRJFXAgDLvB92BPO5iB/c8OdR37C1ULOzs/lO2RBomiDRAyIIwkgUKRdnJxUhohA3QdRLLrIE9gUwNhAjqAB+VXtRC/MeDGbyo8ZuzO4EEHYZtGICl5X+O0wKQCM426kPdbGmCTSj4+sSmKBIHtpwmEk3ZNUJSV3wVQHbZtG8iyhG78CiOUJKmDMM8RcMgveKJyD3atEh/8UKFW/cjyGi32/Uhh3bdbvm7x9e0K614wkGMwn4tQSIsW+QyB4ndpWQPfK6g6xV9qIhnv1VL/4jrN0hC5Ow4xMywL368H2OSZq9gZJCF2LxP5yC3sACKD4QdBVIVNgAyGeGwrJC3820HgI2GnAWISA5QMdVQ+7iAePBM4Ts6ZTOScKUTOmUrknGlEzplO5JwZRM6ZSeScWUTOmU3knDlEzplL5Jx5RM6ZT+ScBUTOuWPsGkvUdHnwwIouwE5LVBZwLR4QHgau8qY/FSJZTjA2Yer7TRn5+HPyewzyqw0D5zrCOkbMJxL/WSW/UI4nPnJkAhkjD+oInSA003Xyxr153ZRl0AZ+DQcjj2CsMsg5sUyay6Aso1b2nVo8kCgMEcVx3eRxHBWJ/CpjDuwpOjlYFmP60iEtNTlS28D7k2NMk8jbtCSYwhT4I5m8A4x8EGKGzW8Eax1DDJmPXCp7QxHuX2I3J8IkPJC3c1Z5f3LxwR0Kde9Oy+u92Henwrp/bPm6xdc/Vlj3wgF+AF4g0yIZIwizSN55PJLPIcGmaZElGLpgFzVPRg4141byISd1LTrPUOnqbIBznrXq+qNMDlnn8gmEfpGCJYqoRVmNURsTOVzdIGqCMpJPGq39GMkSpiDFhfKee1kzcK5jvMw0mchMU4jMNJXITNOIzDSdyEwziMw0k8hMs4jMNJvITHOIzDSXyEzziMw0n8hMC4jMtJDITD8Z68e0izK/jLDlA20lCcbXUFKCRXUFpFlWJXbS5ZNckwJDnEKO03XgjrTz6y5J62RgNlQjX2Z+HMgn3gFRggpzoLpEsmh83KQqqjbEBjxGOgCvMu9G3oZHDsFAttiRTwc/n0/+LfS4OfbLUmwvIcm06HBb3BkiAb2V8gFYcYd/IYrjosBDTUY0UcjcJxjctyqwMRUEcHhSgq9wW4g7aILaT0qMuNoSua9M2yrOQtw9krerk+M7cVajDBQq7xEkPviJQg39qeXsIPb9VGHdd1m+bvH1XQrrXjR23RjDdvIeXbKB1WLgKR9PmkDPeR3l2KlNqxAVCYGIAovEI5vCKGqZL4UFWaDyxrw2WXX96ElkJpzKb5C3GCHDkKqs5MOYCtlGrhBMWEeNJQS4KXa9kRvbOo2ABXGaDjDTePlrMpG/phD5ayqRv6YR+Ws6kb9mEPlrJpG/ZhH5azaRv+YQ+Wsukb/mEflrPpG/FhD5ayGRvxYR+etnY9coA5q8arG9lUA78luIVdthiyuTkzNhFGBShLxQwHEdHkKdiNe7vJbHmYTFwPtZYdsL23tIH7GMo0qosImQXsOgzBEPCJIEigUxyTtU4Z/rEvwvbI/JxlqBMB88hwxQq9qiCeRNrxBrcRLGQRgG8tEhbYWWO45RRDBSylMIpopaxGmdd20nx4OyKB2cWaXIX1hJjAApY3kbyhhx5DcyF0M4Q/ewBJ5FzMovRmPJYDs/b6C0vGlV3itYfPAzhXr8c8s5ROz7ucK6f2H5usXXv1BY990DLIJkCzao6xypvuygYKRyOVSHzIv+BiUfbIFIkQ/RHPlAnUTYJI2qSOrlwO8Qb7qKnagKbRrL29Jhro38XMv7h5cdkkTV1UhdVZ6jZ4m6BIGK/IeoTCsJrSpFeCOXD/4O8fhYbjKR5aYQWW4qkeWmEVluOpHlZhBZbiaR5WYRWW42keXmEFluLpHl5hFZbj6R5RYQWW4hkeUWEVnubiLL/XLsGoE0UYr+uvOTrMCoqgvCuMqQ34NGDi8hi2BnEvlnJBFGBTYrZMsuxp5iF6ArX+VzPPMCEy0sJgZltUiL2ANp83LkV8fC0G/yKAjCLk1yZBPsF2Kahn2/Oksgv6wKB1lOPnsI0VphxwSpEhHsg8jyDpOwNpDUilxdwZcNgBP7Lg3mdqKj2m9qeQvvAZaDx/xS3mMViSeDPhMwW4q0jUeLctZk8gl5iGs/w7MqyzDM0hTbstjhxKQtjlXOWYkPfqlQ2++xnGnEvnsU1n2v5esWX9+rsO7FY3NyIu+KAIKpWySsCAHbykeCtcjO8tEpvp+jU/NblFEQXw5yyAophIglVIGyGXi/7c1WsRPFJwUNdlFXlUkjb74k5VkqUZGjVIS+fCgMBnZYQl4H6OhySZZdCCTq5H1SB36vfJxcOJnIhVOIXDiVyIXTiFw4nciFM4hcOJPIhbOIXDibyIVziFw4l8iF84hcOJ/IhQuIXLiQyIWLiFx4N5ELFxO58L6B/DVyBB7MhTwQReA67EVispX6eS3vzueXtXwUdNrKA5SPIIUWSxmA4Z9MfX9wxicfzRvHSHvFyFv34KlAuhi6YfszT7E5msEXuH2U4jF0yCh5i+cYJJBXhUDLB343UD69F3XAzyHoKqxhCP4UUi0Sf4ztWaQkmIBRYiRY2GUtHFDIm5A2Jf5KM3j+PklbuDBNwhYbqW3RZWEW1G2Xh3KCJyx80XiMxZVpjOqD2QiGl3lYJ0EdpqnOZweLD+5T4IT7Lecjse9+hXX/yvJ1i69/pbDuJQP1EJWnwuQ7lQ8/wugef7dCMS4THwGbx7F8ajcyZ1c1Df4EIhNZv81TZEdUhjTwxrw2X8VO9EegqC7GvbEDkGBGD+xoMqEmOb+fFX4i5Rd1HBUMiNHGkraCAJSIVi1IBs+ljY8xJxMZcwqRMacSGXMakTGnExlzBpExZxIZcxaRMWcTGXMOkTHnEhlzHpEx5xMZcwGRMRcSGXMRkTHvJjLmYiJjLiEy5q9X2XuCBJME80XsCzd1C/fJhwIhlAT/QowMscWUR0UT4R9su6zyA+Q7pAHAWZAOMGaLIuPHMf5zECbI720RII+m8nx9+VyGpE7q1E8j5IW0jNtWPkyvCgCzKYYgxcB7UftIBVmUN0kUdhgBwp8QASaeED5QE2VA3hUjakd+1xQaxhjTx40izEOjGuWwHmDMsmjyJmywn+xjUglSTRHmdVCWBf5HnVUVimRVIR1XCNsAa0Aikd/SR3ZEIKm8n5X44NcKzPEby1lL7PuNwrp/a/m6xde/VVj30rGxLINHzN4zvwSndSheKAlhIif42rBFZi6Q1HGzFjN4jNSjPEXUNRW+wU/SJPHGvLZYxc4gLeTDbCO0nFkFIxrU4wiM08inPyO2Wnk72wZw1MibwsUADQRlnuYdUiwCfPA9LcfJq5OJvDqFyKtTibw6jcir04m8OoPIqzOJvDqLyKuzibw6h8irc4m8Oo/Iq/OJvLqAyKsLiby6iMirdxN5dTGRV5cQeXUpkVcfGOvHDPM/+EXewwB7bVhk0cmHXlbIM0GQhUld4xEC6JAA4VcMU3LEbF7F8nsaXTb4/qtF4HeQepd1I5viwFP8T2TCtAKnNvKRSFmDpXfy+4MypMEQM4KV8sklUM3ge5JkiP1IfovW90skPKRRX6ageQyYjJC78PwQp9B8URaZvIs7yBPPBYNO+Qztgc8p83P4OK/9Wt70LQwrbNkXiKks8JHq8XSCGEWq+J8PFMWMVOImqDuEXRWgKOSV3IPNL+KDBxT45UHLuU3se1Bh3b+zfN3i698prHvZ2ByTo7olSCVZghCtRz55oMPuQ44amnbYGOg6NJshwiOP6w75GP8yuMdHCu/qYnCvfMtV149cWCO3o9jIaZgEhSuRDzOU2o/dBcQWsnIZIbPXRYac3WJzJIsRXoC/KmnawfdfHR/7Tiay7xQi+04lsu80IvtOJ7LvDCL7ziSy7ywi+84msu8cIvvOJbLvPCL7ziey7wIi+y4ksu8iIvveTWTfxUT2XUJk36VE9l1GZN/fD9wrTMsAYVd2TZ5iMSiDUGRby+cGdCHKpPwSTdA2YYWpT9iWVYSNfUiiSLsaU96BWW2Wxgi6FOkTpS3L87rFYw7hbqgjr7FHKQGA1QUpioG8QU0EJg6Qd1Cxk7AcYF95p7CgRhIOofc2CAPMmDJEPHgb2aDKJakjz0DouWQ2ZAtMXaE4LKPCsHngcwPDCE+yrVo5RRogvIHwJb78ppAPQ0LEoDRhzxSx0SHWwOt1W0KuuDby2WpyDzYLiQ9+r8BCf7CcAcW+Pyis+4+Wr1t8/UeFdS8fm5MREkijaZCg/QRZAgwQsrW8JU1cgtG6EpsR8gGZKHFdLMe2EYkownkr53LK3Bvz2mrV9edVI+9006IkIoXXrbxplbxjQiH5Hea1NSI87UB2aR7LB4IlPsIIOynYWwGcfmIdHkdPJnL0FCJHTyVy9DQiR08ncvQMIkfPJHL0LCJHzyZy9BwiR88lcvQ8IkfPJ3L0AiJHLyRy9CIiR99N5OjFRI5eQuTopUSOXkbk6OVEjn5orB/Lrg2EJjEvhXpiXz7xOm9wR+gxkY/MrOGJOkZmqkKkVVSM1sfEGQGQRk0x+DmeFWZXUZOiXDco2HUX46HHjS+BE0jGkTLuBykCEEkpxZOAjtO0g5ZQvtpo4PetkCRqJCyUlSYIEZZ+HGTgArhWPtajQ1wiS/tyBDYKO0zLUOTqCsSPyI2CsBvgaIy16wRaBnJL+UcBhxPqNsDkWDJ0XKMYQ72FJHAMzNsoKSM81hqJJwlKlfd7FB88pMBVD1vOk2LfwwrrfsTydYuvH1FY96NjY7mRkorkEqJQRZgcoweV935AexsDjMI0j5CnUJXyOi8EcICMTdrKaSTwRJd5Y17PXsVOdNRR2pYgNZQ7JPm6iUGH2NcRWJSPB/OlELUpWBobOwEqHWp5hNTVhZm8CdgAR4+TyScTmXwKkcmnEpl8GpHJpxOZfAaRyWcSmXwWkclnE5l8DpHJ5xKZfB6RyecTmXwBkckXEpl8EZHJ7yYy+WIiky8hMvlSIpMvIzL5ciKTP0pk8j+NtQt67uDcFkmvlk+pK+TptRgnR9B1VoycUI4kzSKTIUX6gY8qW9d4MsgrUTNwrqMN4F6ICrpp5T0+kflLTMlxixKCxai7wnqbNGswgPORa5F8Eah4qIVfg6YHftcN6I1ALJC4MG9vISqk9i6GzJsWiQBR74tiMaFDlgkB6G0W5UhCtS/vulUMfK5uUGHGHmNMjyqDhIrIR5whQ2c+iCSMQQLQVCMf/lfgbhUSmZ/KZ+EhLlNIRYXJxQd/UmC0P1vOpmLfnxXW/RfL1y2+/ovCulcM9NdVhBTcysnjGAVfPvSuAZMHRZl2fpV0Fe4hCAdYbTokSj+Uj9Rt0y7BHlMReWNeW69iJxJvhu0lhCO6d1B8krSFcCY4KwW3oretkP8jbImhRGVVioqLFICKhpwqtDNwDnmcfD+ZyPdTiHw/lcj304h8P53I9zOIfD+TyPeziHw/m8j3c4h8P5fI9/OIfD+fyPcLiHy/kMj3i4h8fzeR7xcT+X4Jke+XEvl+GZHvlxP5/lEi368g8v1jY+2qwxS6TKXOxnLkGTKoUTtCgDlEB09gvA31g57l846Q0Bo57dG1SRP49SqfsVQUaQtpRoi3ssGIPckjVDKEdRz7WVG2ld+G8oZnaRlGqOEokJIHK0wDwxJ+GPw9w6Yu/QQVGtKKwdwIzS5PQCiIdWB+GMk70BZ4ek0ZoVijsJWQL2aLcC3wZeDcNmonagoqbdtEXVdKdYe/gwAL7LKwhFDkTTdy1IEiw4w9RT2DTY14qkvSRu7B5j3xwWMKvPdXyzlX7Purwrr/Zvm6xdd/U1j34wP8AChu4ko+8KKI5AwZkhaiJQfQAaGRimuAQlU3CbAQVV7e+kzm812JbbJk8P1qt1l1/f/zwfMd/g/oVYMW8mpkO0za7RTjAPkk+bST37Twgwq868clSh122eTDtMPB97IYZ68wmdgrTCH2ClOJvcI0Yq8wndgrzCD2CjOJvcIsYq8wm9grzCH2CnOJvcI8Yq8wn9grLCD2CguJvcIiYq9wN7FXWEzsFZYQe4WlxF5hGbFXWE7sFR4l9goriL3C48Re4e8DmojB2FGG/NokSYynllZpWRaiQ6wXERMlPii9iZKiQepC6sz9BoUJWRtjf3/wc+e7PMRTliQSoHrCS/JmdYAKZGOp99CQfJKRfBgYBvxQNaaTWYnUAi7HvzewF4B0LO+eB2SPYQDyeyxPq5UiGzTwVp2joYn8CkN8P85ALxAfShDUC/+E0cBeQBpXWVXLGzAH8p6wdRnhD9Ytar0Ua2RkAFMouVBAK/DbNgviIPIxWG3apGjlHmx2FB/8XYEd/2E5M4t9/1BY9xOWr1t8/YTCuleOzTF5gXahRP5EWapyeTvvAmjVJihQUl4AyAka4RQIXiFMS8lkoP2oQzUDtQz0CtuuYicCJ8SOXg4DgzIJkZiRD/ywxKChadugbUrgdVjLL78UqD1hE6FT8aMwQa5A0h78bLFx9h2TiX3HFGLfMZXYd0wj9h3TiX3HDGLfMZPYd8wi9h2ziX3HHGLfMZfYd8wj9h3ziX3HAmLfsZDYdywi9h13E/uOxcS+Ywmx71hK7DuWEfuO5cS+41Fi37GC2Hc8Tuw7VhL7jifH+hGewY6CpE7IqoujAs9Y3nowl+MLGXYZkgL1o62aBmUyFVBJ0xDQ3qByocQP9B140EUmR4/kA098eVtsea/sqkai7yQp58hFSLroEpIEuwoN6B/DUhRJZKnIH/hMPVR9POFO6lOJfyrB0wvb1MdmhiSKXDIqEk+ch2CcKkh9Gc8mEbABCkTzMfj7tagADZAFfwH+Q7iVIQp4Ucvn8qEKo7EBllTCEikMhPEotBGKcYPtk6ROVT5TT3zwpAKHeuvazd9in3yx172G5ese8bXCuiesO8CByBcJUh/YFUkVjJQhY1Vx4CPrIfXlaLWrMBXGCSpMETJU1wr/Df9YWcaVN+a13Sp2BsD7MgR+ye+cB0jEUdMhjnMUNNAfIA41tpMPLUJ+BsvmJcI/S1BsO2kegmJgj2KcPcxkYg8zhdjDTCX2MNOIPcx0Yg8zg9jDzCT2MLOIPcxsYg8zh9jDzCX2MPOIPcx8Yg+zgNjDLCT2MIuIPczdxB5mMbGHWULsYZYSe5hlxB5mObGHeZTYw6wg9jCPE3uYlcQeZiyrjJd7Jo7lHkR2gg0ImIC/WCAHoLrm8vvCdRrLCWsIFzrpkLeTwM+APRjD5ihtSLBIa83gOasI+VPejg+JtcXDhxgTSCFBJg4SSbgonQmcGMLd4I4ixL1QtqISYZH56cDeSRrhGeDfq1I/CIUmKlBPjFopbxGPfI38EtcJ2ho8Rl+eJuRTIHXC23hqA++PGRTCQ2nUNKCNCoksqvws6rIOodjJ46nKJkWmR5qDUEMEZFVh7gw+qdKs0Pk9CvHBRAWmXdNylhf71lRY91qWr1t8vZbCuieNXTfoIkQlrcApgOwW/6MK5Z2CIuTvVD4ZFgCXS/sBtQc+WB5FAOW3qrFHCLT0xry2X3X9Mf4UNjwFH7ui6WKQeCltTIp+CMRUYacGM4miEnqW9yry5Q3BQtkYrdH65IOfGTS+fmgysR+aQuyHphL7oWnEfmg6sR+aQeyHZhL7oVnEfmg2sR+aQ+yH5hL7oXnEfmg+sR9aQOyHFhL7oUXEfuhuYj+0mNgPLSH2Q0uJ/dAyYj+0nNgPPUrsh1YQ+6HHif3QSmI/NLaHGW8/NInYD6091q4c2zUoLHWAmClRS9EFoaEARwEukN2lKQIB4R8r4hQ1DrkAskjgQ1TAIBo4S4baWabyTlFI1WFc+6W8tylUik2hpoWCS9QD6BPIkqAkNZhAw9AmDzpAQQZIG+iHcI8WCAZJ5vJpACkeVl6ACVoIVfaLEtRi+BrRhcamHSmLqKDIAyAZzK8H+iEACYJV8l8mv9oeyjtGpgkYJK1jVCT8TfxjILEQ+IW03CIMC9AVBI5HF6qcJRMfrK3Ax+tY3heIfesorHtdy9ctvl5XYd3rjV03imaWYqYhuTjskL+Rj2MMKVAa4hpFHDyaVPIRGRhoIHmmufyBDgjh+xhKDLzX0w6r2ImkFyFBxNikbUu0IKl8WFxagSVTFMtEuKnrgDtIybn8Algmv8FVAJuwuYvi0gycJRtnbzWZ2FtNIfZWU4m91TRibzWd2FvNIPZWM4m91SxibzWb2FvNIfZWc4m91TxibzWf2FstIPZWC4m91SJib3U3sbdaTOytlhB7q6XE3moZsbdaTuytHiX2ViuIvdXjxN5qJbG3mrAur7eaROyt1iP2Vk8b4LEQO0pxUXVYZYvcizqLzgO4UIKA2jaHNxMEAeIGvY2MpeHMHBU6lKN10eD76EKfBaKmif0OXi5zFKMI65RtJgQmSq4/4t8WVVf+l98WcowtqRGybdjEA++jm6WlMEwphRVZv5QPekMTBdwp8ZiLroPJubxTLzJ5VGO3LAyx14Qolm2wcKC3QhFEnNbimCQdyT+RvL9XVlYd8iYCUxbZop5kwCf5RR48ELSWIWClKYtm5PcX2KwtPniaAms/3fIeQ+x7usK6n2H5usXXz1BY9/pj141mBHGJGg0k6iRqqzqL0EFA1wgklLFIykbahqj5EQip9cE56GuAOvj3Bn5PZ8dV7AzkHXpRBZENwxz1FVMKObRaVUWAPikpOrBmVqQYWwD7oyIICxRZtA6gKtScbuCz2Mbbp00m9mlTiH3aVGKfNo3Yp00n9mkziH3aTGKfNovYp80m9mlziH3aXGKfNo/Yp80n9mkLiH3aQmKftojYp91N7NMWE/u0JcQ+bSmxT1tG7NOWE/u0R4l92gpin/Y4sU9bSezTBvaaxtmnTSL2aesR+7T1iX3aBgNMC/ViU6lA2S5QL9owb8SxMXq12M/rCBtYGSo4kmzVNHAhWqO6RojG8nnVUT2wB5aVdRUjqZV+1jSgJqToPMQq8YxD1LsUeT7O0raQzy0B3CUJnIGNLtQsVJs23HXws/6iMMjDDBWsTktJw5J6IklCSAgxVIJ2ESkDjyetI+gf21xYSFyDFsvBz8wGCWZovLC/hVyHaK2RHRC8ZYddvaytI8QJGAn0UmcNCgy22RDnkAwKSivulXuwuV18sIECt29oeb8i9m2osO6NLF+3+HojhXVvPDbHpPLZ2KjfoMomQdCirwkaaRNQe7q8RLoJK1ReJE/kRVQ47HshmAKhT6SvgT5tp1XsxBYy/niA3XD57BQQIopWLhMebKJldZ6HeRAhb6DY5UgYyL4Y4rRgMlTdDP3IwOedjLfnm0zs+aYQe76pxJ5vGrHnm07s+WYQe76ZxJ5vFrHnm03s+eYQe765xJ5vHrHnm0/s+RYQe76FxJ5vEbHnu5vY8y0m9nxLiD3fUmLPt4zY8y0n9nyPEnu+FcSe73Fiz7eS2PMN7IGNs+ebROz51iP2fOsTe76NiT3fM8euMUVeR6nPsOOVRZmP9TUQQxsBEWtsjJUAn0I+ArOKcoR1jqSUluiX8jof+dT2gfeyCAW44jL3fYRPHmTIGdjrQ41IhAygoBDJH5UuTeQtMfCgoCD4GGGFaG2ygZ4vr8K0A2T4wIoWdRbZKYKQWslpRRQ0aE4hNblbEgQoSwJXWGeOKACrDLyXhd8URYlsh0hJS9ScDmmg6LALhw0MWBbV0kB2tS8FXfJDmWBfMW9jiA5BHKicexQfPFOhB3iW5b2P2PcshXVvYvm6xdebKKx707G/09mlfoUa3YJ6AjBvENURhiBBA8rCbMXH/jtoqZI6EkZo0uRNtn2MeJBx5GOufG/Ma+dV1w8bkOzA/oA3dGpI/CjjaY6uI+zQYoCBatiUyDvYyDnqLPTx8wgdG/pARNfA3tw4+8fJxP5xCrF/nErsH6cR+8fpxP5xBrF/nEnsH2cR+8fZxP5xDrF/nEvsH+cR+8f5xP5xAbF/XEjsHxcR+8e7if3jYmL/uITYPy4l9o/LiP3jcmL/+Cixf1xB7B8fJ/aPK4n948D7bo2zf5xE7B/XI/aP6xP7x42J/eOmxP5xs7F2FciDMKQtCxT+osZfRlbvEr9EHMNT8jM8KuwwIMOihjdoMeFxoBi2Auty8D3YkewThGwhMFdHyNEB0maKPTmEeVCXaYn6FdUVahM0gdivAyQfpOdKLA+bgf7RB6floFxsG6byXoi4JmU8ApEJrEPrKR/VCs1hvzMI2wiJOQURIYIA0FkxsGcYC0mhTnRRAAAEGvphUKVZC3mmyAWpLKpK8EAT7HR2SIw5EhHEAeRA1q/lHux+QnywmUI/sbnlfZTYt7nCurewfN3i6y0U1r3lwO/ANvLOPEAI0A26t0y6H/BHDhoHIqOk1RUaBwQw4httXtEgOit5E1TsJOL/vDGvXVaxE71pClKW901sQ1QjtEEYOKEuZwFGMUGTyDvvIJkFWYkWpcW/FZegMbAAOosmH3wP9nH2opOJvegUYi86ldiLTiP2otOJvegMYi86k9iLziL2orOJvegcYi86l9iLziP2ovOJvegCYi+6kNiLLiL2oncTe9HFxF50CbEXXUrsRZcRe9HlxF70UWIvuoLYiz5O7EVXEnvRgf5xnL3oJGIvuh6xF12f2ItuTOxFNyX2olsSe9Gtxtol72kfIgTRkwYdNizhzhb7Hh0QAH85QgRh5zBB9YVmsJOJ8G3hxRjAUZVR0Qy+L3+AVBhkDXgBi4hQRxDBiWxnAjRSxHveBfIpphkiF/nBR6HEHkvYoTns8qIb6EVLpDi0nUEr2anqpICHaZCU0k4i7LHyIBZJxHBJWFeJZCSk6QbS6WDb4GcHFx0Sr7xTTdhWeVzB4XGDlVWt/HZhh+pT4+YpyDFAmx2gh25DLKVGp4pcpXJ+VXywlUJv8mzLezKx79kK697a8nWLr7dWWPc2Y9cdgw5RT9MONQBtXY7Ui2KPeuyj4cCsKUevKE1Gh3CPJCcHQLwM250d9u/z1Bvz2nXV9aP8537RNbLFX+bI1ODk1M/B8whs2OsHAKUiDPFvpSid6LrSMgHPSgpBThnYyxxnXzuZ2NdOIfa1U4l97TRiXzud2NfOIPa1M4l97SxiXzub2NfOIfa1c4l97TxiXzuf2NcuIPa1C4l97SJiX3s3sa9dTOxrlxD72qXEvnYZsa9dTuxrHyX2tSuIfe3jxL52JbGvHTi/Os6+dhKxr12P2NeuT+xrNyb2tZsS+9otiX3tNsS+dtuxdoVApbKMAx8QlKR+k6N5lE2XBFLvijitUc2QjcUsCKRMwWVog2NfEBJ5d/CzGvw8hdsQ+XBLBAoIG+BDh2427cAVcAuSRIsCjAYSMRoiyEfeGxWFHelx4L1Jg//5WG0sBmKMgU9yYySMogFOVvKZdyjjeZDh5sDqLEyQaDPEdBTKI6kHfy8zLcPQr/MQuTRHOWix2mjk5CJybZLJJ3FndVMD3+qwRCKsorou4gD7rRB9pXNGV3ywrUKfs53l/Z3Yt53Cure3fN3i6+0V1r3D2HWj8gGhkggsWyQIXeT4FPKOgywKUdFAIygV6Iiwn5pipAQmDZG0fHBOU2G45I157baKnSFwGySR+Ig9/A00UbAHLQOKXJ4gpQWoXrF8ECUGZBkKD6BXGlUYKtiXDr436Th75MnEHnkKsUeeSuyRpxF75OnEHnkGsUeeSeyRZxF75NnEHnkOsUeeS+yR5xF75PnEHnkBsUdeSOyRFxF75LuJPfJiYo+8hNgjLyX2yMuIPfJyYo/8KLFHXkHskR8n9sgriT3ywPvnjLNHnkTskdcj9sjrE3vkjYk98qbEHnlLYo+8DbFH3oHYI+848H4nSDhy5LdF6ARhDQ7J0QOXQNcGlbmReoMrsLspsQQf1rcA7gJaaxBhwcDeL9TsSwnMkiIZwa6yxXYTVFqVBVaG3A+QqtF51ighAOdC3oS2hJ9R1vLYH/j8jgwVEIGF8lHhSfmC/E0BIC/BAq381mrQRkVZorJE8Bv6dfTUCSJF3hoXj3Pg8zsqbG0leNpRJr872yIjlvJZHhl+HGKDDHUJTXwJ6gh9+RBGiY8kLpG6yhxjglzuwe6ZxAc7KvRMO1neK4p9Oymse2fL1y2+3llh3bsMrLsqAU7oadArB4KWSCjgOHBDJu+ZHHVBJy1zjWQaAxOh+USO4CfI/Aig2Bvz2n0VOwO0reiJQzmGgaa7alrEdlWgLhfysYhJAv4B9iAh4l/H9jMakq4oRiqK9BT+wN7vOPvtycR+ewqx355K7LenEfvt6cR+ewax355J7LdnEfvt2cR+ew6x355L7LfnEfvt+cR+ewGx315I7LcXEfvtu4n99mJiv72E2G8vJfbby4j99nJiv/0osd9eQey3Hyf22yuJ/fbg5xmOr9+eROy31yP22+sT++2Nif32psR+e0tiv70Nsd/egdhv70Lst3cd2McSeI4EHKsQG80hdo/rDmqU3/xF44pcBOgE+0KDrXgXrgh8bDIDsLCHWw7023Ga1HjUcVDHcdWleY12vUTSQPmPsZQCSRcFKMqQr6ANsT1AvggFz3I4f2y/LdgegbihdBTUJkA0RxgF5HhMTZYkcYEKF2KDHMUww051JuQCdomF9IFWg/02iA2PGhkMGS8oxKg2wm42llqVQLeqklakqODNBKIHYgYR/BqGSVVChiNnUNn9l/hgV4X+azfL+06xbzeFde9u+brF17srrHuPgVpRxSA95GFQApI3alqRo0YG6DxbeVNsBEaYYm6WRkmHJIxQavxGTqGE0oXn3pjXHquuH2Wqk9gNmjwGO6M2YpCWpUEd+VLahNKjHLMvjLKwBB8dYBbJJ8/WyNroTwfeK3icvftkYu8+hdi7TyX27tOIvft0Yu8+g9i7zyT27rOIvftsYu8+h9i7zyX27vOIvft8Yu++gNi7LyT27ouIvfvdxN59MbF3X0Ls3ZcSe/dlxN59ObF3f5TYu68g9u6PE3v3lcTefeCs9Th790nE3n09Yu++PrF335jYu29K7N23JPbu2xB79x2IvfsuxN59D2LvvufYNXZAND8NU5Q2CT3kfWnSIVaoNcKPEWJxggoL1kJPHuG/V4goFPMuiYo0G/icH6HCBPkg7pBIEzQFcdkC8GFBCi735V2eg0IMAs2GUR6H8hZCVQ5hZPJXBvbKCwQoWCiKkEBBKH5bhOgDkkKADo6J8kw6BR8MDW2mEVJNjH+6A7IjPZXJwHlyyL4CHMch2g+gDdIK/mRTyLsZBSGKCIKmC8MghmmtNCApwBYJAZAib3OdyT3YvZz4YE+FXm4vy3tYsW8vhXU/x/J1i6+fo7DuvcfmGBR8EL+wNooPcBDc16J3C9DEomvP06pCvm/Dtoml1cVWeoSK2zVZVUqUDnzOz56rrh9E6jcF6l0kH4sMMk0RlyjL6IaRalHR5I3gUYSSBpXRr1t8Yb6G1rIukTcG9srHOweYTJwDTCHOAaYS5wDTiHOA6cQ5wAziHGAmcQ4wizgHmE2cA8whzgHmEucA84hzgPnEOcAC4hxgIXEOsIg4B7ibOAdYTJwDLCHOAZYS5wDLiHOA5cQ5wKPEOcAK4hzgceIcYCVxDjDwnl3jnANMIs4B1iPOAdYnzgE2Js4BNiXOAbYkzgG2Ic4BdiDOAXYhzgH2IM4B9ibOAfYZ+LyYUh55gJxapAhy2B9UWdYknWSMMJXPXQpkRx5rQmOOxbVh3CSoyfB9ULUDv1eeAeGw+y+f24Q9ewGLBFAdggpQ5uXdykB4AboIgfe2AKoUKHXAARRIJI1kYA8/bOqiRT5GwkXEyCHgtCix/Q/wyiF2OCuWTwJOhNIBz20aojgUTdqCgtIoH3i/tKBF+ECfeKUAyCzwkSDANfgnakAsCAr2YSIQBmGWy+kAZBWgCmpThExcyT3YfaH4YB+FvtC3vB8W+3yFdQeWr1t8HSisOxybY4DuyI1Rk9dRKMfh0xSlCykKXUcrB+XLGEm7KFGsOzAe5n3YwW9R3NoQQ7Zk4LOf9lrFzgCdOJBdTsNkTY1WL0S+QD4rEDM1Cn1WVnWBnhSThQTpHQiABqdG7142aYUOd/D3ysc3U5hMnClMIc4UphJnCtOIM4XpxJnCDOJMYSZxpjCLOFOYTZwpzCHOFOYSZwrziDOF+cSZwgLiTGEhcaawiDhTuJs4U1hMnCksIc4UlhJnCsuIM4XlxJnCo8SZwgriTOFx4kxhJXGmMHBmfpwzhUnEmcJ6xJnC+sSZwsbEmcKmxJnClsSZwjbEmcIOxJnCLsSZwh7EmcLexJlCSJwpRANrlGP1ZQ4fYa2IfMB8VqHqgOfKugQA5T6SUidv0wwJl/Kmbm0pWRgiRH4Z+L0Av4yAd/hCD98JBbTwK3Kw5LJAxgFI762UVRiByELTDtFhchGgbYBzB96rLoxQzBt5QnA4/mouJ5lBzhH6n6CC0DPpMwLk1LDDcwDoJGUMGguhfCSFgbMFyOSAEjgrlx4L0OsnIUo+9N8CeKoE4AO+k/MVcHDexWkEXIJk5VcF4Fq5B7vHFB9ECj1mbHlvLfbFCutOLF+3+DpRWHc68Ds+RRKhAUdlQpCHonKMBkskV0gbuIPoKZJKCiu65WKkTlexn5Qo6Pg7g+/B/pxV7AzRxcnErpbsivuh8ocwFUGeh53MB9sSPVJUgMlSebtHVMU6D9Gc1/IJCMnAe9WNdz4xmTifmEKcT0wlziemEecT04nziRnE+cRM4nxiFnE+MZs4n5hDnE/MJc4n5hHnE/OJ84kFxPnEQuJ8YhFxPnE3cT6xmDifWEKcTywlzieWEecTy4nziUeJ84kVxPnE48T5xErifGLg9wLGOZ+YRJxPrEecT6xPnE9sTJxPbEqcT2xJnE9sQ5xP7ECcT+xCnE/sQZxP7E2cT4TE+URKnE9kY+1CK1D78qFtDUpD5qNqtzEoDQ8rKREnbZFV8n71ZY4cD6JGsk5RIuoE6y9RJAd+96EpkQ+6vAhAe4GP+hZLmSvQMeTIE3GHB9BESP0liAougkZE3W2BcoNSNfgZcX6GbCtv6Y/sjupapkWE3JjLp8AB2PwuRx4J0QN18gsNAZ4r0q8vKQiQWAXJKmceEjwjZJREPow9C5sQ5RWZsJIYh7oqdC0F2ARk5XdoE5DjABQhHnsu9UXuwe5XxQeZQr+aW96ni325wroLy9ctvi4U1r3v2JxcdIjjtkYPnRVJI3wZ+6iNqPMZ7oo0nSJhoX6jyCJlAab8FkHmyzuAZIhZb8xr71XsDFFYCtQYxEgLggxBJE0clMi2Aq9oo9AMoyspa+RY5O8KdqOJlzfcROAGaTnwPoHjnHVMJs46phBnHVOJs45pxFnHdOKsYwZx1jGTOOuYRZx1zCbOOuYQZx1zibOOecRZx3zirGMBcdaxkDjrWEScddxNnHUsJs46lhBnHUuJs45lxFnHcuKs41HirGMFcdbxOHHWsZI46xg48zDOWcck4qxjPeKsY33irGNj4qxjU+KsY0virGMb4qxjB+KsYxfirGMP4qxjb+KsIyTOOlLirGNf4qxjv7F+jNHvpE2eJqkcDEfH06CaBG0skBcXCRgENQIMJCcduqBCHkEakrdDhNexnFU+EyEPw85Hem8Rt6AAuK6Mcvwv+Q2OCn0QoK6pkaXhRzzxSkAKIRTW4JcyGHifhxrpF0CVtwDVHF0IHnKKPgFzCQR1E8qnn4GXAD2o2CVQPUEqyxHd6D3SLI0HzmLg2aLrAa9GqMi4k/xSOwQRlshaYSyfCZ7gNmiosjQM0B808hERcFLuI7+mI5+nxu59xQf7KfS++1ve84t9+yus+7mWr1t8/VyFdR8wdt1xkCP9R8imnZw+iksEcIheOkbnWQdhG6Zxg/8UoxTWUYemCGPIQiosUBwFxRvz2ud/2ekDxZFDI7CojCGjGNiQNMCTGLUJBIEShH68xBgAPRUaBoBFIx9TgpRY+gO/3zHeuclk4txkCnFuMpU4N5lGnJtMJ85NZhDnJjOJc5NZxLnJbOLcZA5xbjKXODeZR5ybzCfOTRYQ5yYLiXOTRcS5yd3Eucli4txkCXFuspQ4N1lGnJssJ85NHiXOTVYQ5yaPE+cmK4lzk4FZxzjnJpOIc5P1iHOT9Ylzk42Jc5NNiXOTLYlzk22Ic5MdiHOTXYhzkz2Ic5O9iXOTkDg3SYlzk32Jc5MDiHOTAwf0hToHzInlHShRbFBLE4xIkP3gYCwohHaTWOpO2qRlWXQ1XA60rWF1CKgcOCMi1FmGyJg+6h8kWPo+wjdDjwDl5oG8RyayDRKvLDuSj3NEO4ZmAhOZLK4G3hcjAK2AmMMmTpDsMW3xUQ1z+d1+oGYB7BV0y8E1ZZAVQdpi3tGhmqHAIKlBtQNnRCJ4HfnQ94FyCUoY7pI2SY2d8RK+w4IDv5NmKoFhaZrDKyUArJZ3Do0AbHIPdh8tPjhQoY8+yPL5wYh9Cus+2PJ1i68PVlj3IWNzTAyaRRcVC3XHMq9EqsWUMJTfV0FHJW99U8YgYsRghtqEOSgSb418CgBGiHtjXv7/Wj+gEbEdtnkGBEEezuXtcuoOYYrZIuoSWuVGfgmuBl+iB87kV85KpH10UW3bjZ2bjHcGM5k4g5lCnMFMJc5gphFnMNOJM5gZxBnMTOIMZhZxBjObOIOZQ5zBzCXOYOYRZzDziTOYBcQZzELiDGYRcQZzN3EGs5g4g1lCnMEsJc5glhFnMMuJM5hHiTOYFcQZzOPEGcxK4gxm4HdYxjmDmUScwaxHnMGsT5zBbEycwWxKnMFsSZzBbEOcwexAnMHsQpzB7EGcwexNnMGExBlMSpzB7EucwRxAnMEcQpzBHDqgCXnQJdoxxKBAhLztR4P2AE1KjLyYSIYvQWFguChvEmRAmOxLCQIjtNXADCZpwNhIEVBNC9N92C6Q66OtqkAzIEsUWcSzTEPQzKH7Q/YEswIowyaMBn9PR2CuqDqMgFAz6goVOUErleNfB3TF8L80MDG4JSnqDrQA/aOtqNEJyJxnYAYTAhAaJIYiAfvhD4NOGjQuIPoKN0U5SoXsW2gHlaVCT4S49lNwEyIeCpd7sHty8cGhCj35YZbPIsS+wxTW/TzL1y2+fp7Cug8feB+RduRTeFBikwDNFFIVJpuos0jnVdnEmQwR0JTJ2w2jA8XMA0WiHUmpDZqHgc8XDVZdP3Ae/SWCCEQub3jqIzizUuYcQAGUnBq1EUUCCTwFSGERSNsxEAOoDfJoB96bdJzznMnEec4U4jxnKnGeM404z5lOnOfMIM5zZhLnObOI85zZxHnOHOI8Zy5xnjOPOM+ZT5znLCDOcxYS5zmLiPOcu4nznMXEec4S4jxnKXGes4w4z1lOnOc8SpznrCDOcx4nznNWEuc5g58vOr55ziTiPGc94jxnfeI8Z2PiPGdT4jxnS+I8ZxviPGcH4jxnF+I8Zw/iPGdv4jwnJM5zUuI8Z1/iPOcA4jznEOI853DiPOeIsX7MUIiQNnGTEuEfpnUqv4KEjgFoGGCagogHBHUwrmwrv0ErkIB92lAaL6DO4GfNgIZK9FcoZ3j2EGkRxsiE6CEAhDFk4OP5oGxidaDVBP8AaixAB9zZBdXgPAdzF6wFagLdApoRK5H8doX8apMfdJ0QNHpFAECSIZPjfwBy/DiN5B1cqqgZmOfAxxXUA4lmcdZlAhPId+g6GlE9nmQWZWkDFKzhmgotF5ySgqZwzwJLlnuw+3vxwREK/f2Rls81xL4jFdZ9lOXrFl8fpbDuo8fmmBDs4LdowlBGA5TskXd/lc5ESlUI4aOg1QLwQAYfERijq6nKtMAYFI3vwGfOhquuH1aGWV4K/YGP0Fuh18IktUWTCC4BRAOsS6wAlFEihUQFqgNu3AkIY8A7MM8Z52xoMnE2NIU4G5pKnA1NI86GphNnQzOIs6GZxNnQLOJsaDZxNjSHOBuaS5wNzSPOhuYTZ0MLiLOhhcTZ0CLibOhu4mxoMXE2tIQ4G1pKnA0tI86GlhNnQ48SZ0MriLOhx4mzoZXE2dDAZ86OczY0iTgbWo84G1qfOBvamDgb2pQ4G9qSOBvahjgb2oE4G9qFOBvagzgb2ps4GwqJs6GUOBvalzgbOoA4GzqEOBs6nDgbOpo4GzpmwI+IwghEh+fRolQGwt8phFumIIwsS3I0amhIQl+qJ/oKNJg+nmaKwoWWZ/D3rUK/yFJEci4JE41CGiGgIiB8G3UgEpRYaBeVBf/LRzpspIKngJisLNFEDbxPDVrHrEITh79XJEmSoXDXWYo8JseEZEwEBMnhGDgOmS+sYr8sqypD5zuSCgc/M0iqqXgO8SwtKaxChsqCOAihJORtv5Ma0kmNLaUbgu1ADOQWJBI8ZLkHe1YgPjhGYVZwrOUzErHvWIV1H2f5usXXxyms+/ljYzkEiUQgUOAbuk+UBOA7uhUgIAixRGdQSvFAfFRtmDcZMN1vUJbAUejc0tob84pWXX8M3htpoio0vpjSFkVQStuJUg58i5HM8F9QNEAXCKUYCbpDHgNHYljgt9HAbGicc6bJxDnTFOKcaSpxzjSNOGeaTpwzzSDOmWYS50yziHOm2cQ50xzinGkucc40jzhnmk+cMy0gzpkWEudMi4hzpruJc6bFxDnTEuKcaSlxzrSMOGdaTpwzPUqcM60gzpkeJ86ZVhLnTIPvUzO+OdMk4pxpPeKcaX3inGlj4pxpU+KcaUvinGkb4pxpB+KcaRfinGkP4pxpb+KcKSTOmVLinGlf4pzpAOKc6RDinOlw4pzpaOKc6fnEOdMLBuKxjmvk1i5HZIJHakiiRdoBjDcNcBqNBGI1LIQyI+lsoHr8OfSUSQauLQfmTHEeljXwDU1t3iA9NZKFGplgwZ9NEiEvoBxKoxHJOy6nNXQNgIqLCr5ssrFzJh8jnzAt0NriCRdx0mFFBaIQ2b6JoYUctFn5Ur2wuABBg7YRLa0ckQqF8QbmTEETSv3rMIMS/hRAw+pQ78E5WYPpWCntMVzUgtnRC2CeBohs0IqAt9NE7sGeO4gPXqAwd3ih5fMWse+FCus+3vJ1i6+PV1j3CWNjGfUOf7iJ0V2jgAGrfJCE5Dc/q+qoaeUwoBRxpLosAzrEJfoptDJoSYN0cM4Ur2JnGEqTg9lugw4NnUfmR/Ie5OhjQxgTBShI8uukcYZ5B/J1kKMFj8FmMXAjQYkbnDONb2Y1mTizmkKcWU0lzqymEWdW04kzq/+Pur+P2ywp73rRNqFJepImGeKggw466KCDDtbLqvWCDvsMew97DzrooIMZ4mBqraqlRImioqKioqKiRo0aNSRBg4qKCYlEUTESgwnaaKONNtpoo4022mijjTTSmMbz/d2Ec+56knP+2Pe19ueeh9fpfp77qVpVdV2/3/eqVfVOQ2b1LkNm9W5DZvUeQ2b1XkNm9T5DZvV+Q2b1AUNm9UFDZvUhQ2b1YUNm9RFDZvVRQ2b1MUNm9XFDZvUJQ2b1SUNm9SlDZvUZQ2b1OUNm9XlDZtXsQTqQWT3dkFndYcisnmHIrJ5pyKyeZcisnm3IrJ5jyKyea8isnmfIrJ5vyKxeYMisgiGz6g2Z1QsNmdWLDJnViw2Z1UsMmdVLDZnVywyZ1csNmdUvbWIhIocGk1emiaefI8u/sojmuLLs594lJMQc9BIcyQMliNtliS5M1swTbO7wSgoPzHLCPQYnMcGhPj3rwxFcRhRxrkOv93XGVDXZ0zzPeCeH/vVkmoZZLRN5P/FgEWLDIC2DHExz5tGWvvTMW9YQiakftMrXkcQ5TwjYkAly07jPrPxCWwnGiEKWDJG8W2YwXM9Tz9hlRIODvpVV85z8X4gduDZyDLK1x9bpM6wZhsbgl27AMH7ZkbMbte+XbdDvx4+83xrrxzfo9yv2Y0xJFclQmdoJfZGdqFLqcKBo6ERmWNDuARY7gWpXXWPu9Lppmp02MKYvHj+9+0on2snCRnR0aG4lURxgipMAVV9GiQAoDisPCISj6JN8zqRkR2LSOfYgtOYOrwP511sM+ddbDfnX2wz519sN+dc7DPnXOw3517sM+de7DfnXewz513sN+df7DPnX+w351wcM+dcHDfnXhwz514cN+ddHDPnXRw3518cM+dfHDfnXJwz51ycN+denDPnXZwz51+cM+dfnDflXszfqQP71dEP+dYch/3qGIf96piH/epYh/3q2If96jiH/eq4h/3qeIf96viH/eoEh/wqG/Ks35F8vNORfLzLkXy825F8vMeRfLzXkXy8z5F8vN+RfrzDkX798v13Kg9qS1feoER/xAZpXYfXMdkJ17goEDBsqhYJp6Jj5FWmExEF51JZ/dUxxsnC/YMiAYSQxwSifmfjEH7w56QIxjeNGZCIgiLZuRVeRAJX6Gv5FOF7RB0POiKfMyllS5x1reOC/B8djTDRg1aVSTFf8KUqHyMN3DpGBbM8B51mlGBZCrisJXzUTyTKugwczsBx0ABYPYUToJszNSFjNpGwUQGQ97s5HtuYhGoNfvgEP+doj50Bq39du0O8njrzfGusnNuj3K5ucr42GBUIDZWAZI+SBvAPpbMRc6MVcsE2ua04IRuTrhBhYhnkujjUFEz6199WfaCe/NEh9sNKQHLVDfrvOE8kI0jOxYhb/0kZImS3yEfotjPgR/nyR+m7414Es7S2GLO2thiztbYYs7e2GLO0dhiztnYYs7V2GLO3dhiztPYYs7b2GLO19hizt/YYs7QOGLO2DhiztQ4Ys7cOGLO0jhizto4Ys7WOGLO3jhiztE4Ys7ZOGLO1ThiztM4Ys7XOGLO3zhiztS87YsbSnG7K0OwxZ2jMMWdozDVnaswxZ2rMNWdpzDFnacw1Z2vMMWdrzDVnaCwxZWjBkab0hS3uhIUt7kSFLe7EhS3uJIUt7qSFLe5khS3u5IUt7hSFLe6UhS/u6/T6itcn/dCcjdrpO3KrCqgLqF6ewuIS5YR4H9anLPH7nFiYSOWDVnGj3kkXmU4ZloQQCWi+zyAfwG5iOvyLj8+SnBUC2DogWuFcJ5IJKGp10SNY+S0P7LiPrBTfMh9Qece96vr2QNScCJANCCp1LQNwguPkksBiqPXkdIl/bc7ZqQeAnrERWkKExbnaFCZs8gXssLLBIWBQ5jAwuqh/xNw898gSnHnbXi1mzFY3B123AVn7FkTMlte9XbNDvJ4+83xrrJzfo96v2Y4ycXcAgYCCmYZrIF5h20jz6GQ3Yr1rqOEhECMhJRlbH0kGiJlZGcc1esuFEO5FZyyRNj3sS3KqxAiNQpaVDGuCFKz69Ql0GkgxLaILlBWU0MiB52e+ztEO53FsMudxbDbnc2wy53NsNudw7DLncOw253LsMudy7Dbncewy53HsNudz7DLnc+w253AcMudwHDbnchwy53IcNudxHDLncRw253McMudzHDbncJwy53CcNudynDLncZwy53OcMudznDblcw9IO5HJPN+RydxhyuWcYcrlnGnK5ZxlyuWcbcrnnGHK55xpyuecZcrnnG3K5FxhyuWDI5XpDLvdCQy73IkMu92JDLvcSQy73UkMu9zJDLvdyQy73CkMu90pDLvcqQy73K5v3wtzAt9M9j2UTndIJYIviMokZhcRs8dn3DqmJyOA5LMwHD65Tig/t3YjznJELPAgULS0ht3iWOwGNx0Xcqnl2o9YSxgDV0ukNTWbshIdCQnVTs8cNzxIKoYhfg3QSOatE436YCZIjT1CyHJeQkeV4cHxLJFaWmSyaCj6reccTT4bFIDNPnY46YzoyZYnTSy4MPyOP3CmO9VArYAPXyIriNywVr8hz1WdYcxqNwa/cgNN8/ZHzKbXv6zfodz7yfmus8wb9nptcQRKBa2SJ2UVWv07JzxjEfkaaTIIQHRGZxTJF2EfW5k9ggXAaIsmf2vsaT7Rzx9J2RwuSc4rEZAd6l4mdsBhks0l0j8DRr3DBGXfQe0zb4MFp6JzU7HE7kPG9xZDxvdWQ8b3NkPG93ZDxvcOQ8b3TkPG9y5DxvduQ8b3HkPG915Dxvc+Q8b3fkPF9wJDxfdCQ8X3IkPF92JDxfcSQ8X3UkPF9zJDxfdyQ8X3CkPF90pDxfcqQ8X3GkPF9zpDxfd6Q8TXnkh3I+J5uyPjuMGR8zzBkfM80ZHzPMmR8zzZkfM8xZHzPNWR8zzNkfM83ZHwvMGR8wZDx9YaM74WGjO9FhozvxYaM7yWGjO+lhozvZYaM7+WGjO8VhozvlYaM71WGjG82ZHzL/jjC7UgKpdObrENiWGsdgGSj0kmHi53J6YwG1K8jzTBXyMx+YZUiPNI6NXvviI9uJgPSEvIRXpvIziOaPTp1wJGRhFmuU0ojGBAPgE7E96DMIYlkguaOS1bMlJE58DiQnkNzENgl7EkCWlNeFxegL3ZBjQWBnuWXFQfNCMTOZu/dTNRGHSSM3EgH4Ror/p/oj8/vOnlGHtaCdhUTiUlKXw+Rh7pCBbM+w5r5aAyWDZhPOXLWpfaVDfpdj7zfGuu6Qb/X/bVM8NPu12EMMO2BPBb8zOeWhIOVlFwm4A5KJmMWUKg62o2shrnCY3fjF7He7ms60U54eySjYsa6GEcdf+iUNcK0u8LD0SKiJPIaT0uKZ7Gz+Imcq6Aj3nz6MXvvDuCFbzHkhW815IVvM+SFbzfkhe8w5IXvNOSF7zLkhe825IXvMeSF7zXkhe8z5IXvN+SFHzDkhR805IUfMuSFHzbkhR8x5IUfNeSFHzPkhR835IWfMOSFnzTkhZ8y5IWfMeSFnzPkhZ835IXNOW4H8sKnG/LCOwx54TMMeeEzDXnhswx54bMNeeFzDHnhcw154fMMeeHzDXnhCwx5YTDkhb0hL3yhIS98kSEvfLEhL3yJIS98qSEvfJkhL3y5IS98hSEvfKUhL3yVIS+cDXnhasgLf9V+HzF0XUWp+czC9ZEAXVJfdd/DtKJal5lMDB5Azu2Ue5Y2DxBEXCdzY2h4ITEF+TLyRAnWGPeyM3ksrQyiwNbSXChGLfjwMUSCHNGZYJ7TyKToYrMncFqVYliDFXVMD2CGfVl1DyriGdmKFd69TjuwHjHSUcqQSIdy7ZXaG14oxwcKxOx3EJR50S5IeZmIKgqo2MIwO2l8/P2CCcIuDbEgr5hM/LU+w5ofaQx+1Qb86FcfOTdT+371Bv1+9ZH3W2P96g36/Q0NL4TOV5LYTFgmImfnKATgoImpVUpwropoldzBgkM4J4JSD4jAdZA/6qm9rxeeaGeYOjdl8RsS84KNcmmXYNe+FgxB0I5izy8QQ9NewxkHAOsghTqSeHDtnsDD2ONbDNnjWw3Z49sM2ePbDdnjOwzZ4zsN2eO7DNnjuw3Z43sM2eN7Ddnj+wzZ4/sN2eMHDNnjBw3Z44cM2eOHDdnjRwzZ40cN2ePHDNnjxw3Z4ycM2eMnDdnjpwzZ42cM2ePnDNnj5w3ZY/Ou7oHs8emG7PEOQ/b4DEP2+ExD9vgsQ/b4bEP2+BxD9vhcQ/b4PEP2+HxD9vgCQ/YYDNljb8geX2jIHl9kyB5fbMgeX2LIHl9qyB5fZsgeX27IHl9hyB5facgeX2XIHmdD9rgassdvMGSPv2a/XSsutF/0Li4DPo48O4VXfCeD6eRCI5mIdY1D0gvCeIs+eWR851iOq2vYo75pliKhgyOadx5rh3Ct9KIbCVCoU2TWBEjAmBYkATI0MpGxALid2rBHbD9qqc6iCQ51TACFbeiuDe/mGVOEMSapowkxHVIfGoCoGweK3iVu3kcm2ePCGHh+RC8543xHUjhmaIgrcYxOdXk3lOSOQuCBdi54QkIrYXrWZ1izKI3Br9mARf3aI2dwat+v3aDfrznyfmusX7NBv79xfy3XHQMh1xDfpaxDWSQsMbOELdZzRQPM4L0osE5CCdQrUadRby7jgU7tff38k/3Pveg/LoZ1O+kgzdgNKII0lxG7gbXG/GkJOeIWhsmVDFBc9d9ifWvDHg/kmG8x5JhvNeSYbzPkmG835JjvMOSY7zTkmO8y5JjvNuSY7zHkmO815JjvM+SY7zfkmB8w5JgfNOSYHzLkmB825JgfMeSYHzXkmB8z5JgfN+SYnzDkmJ805JifMuSYnzHkmJ8z5JifN+SYzV7FAznm0w055h2GHPMZhhzzmYYc81mGHPPZhhzzOYYc87mGHPN5hhzz+YYc8wWGHDMYcszekGO+0JBjvsiQY77YkGO+xJBjvtSQY77MkGO+3JBjvsKQY77SkGO+ypBjzoYcczXkmN9gyDG/0ZBj/rr9Pq48DVQZ/I843RFNQACexYQuXwoYDwPg4BCMIp5Bypi/HGMgFmAw1vbu4LIMDqXKNzBAw5z7LJnqPXFq1TmKBGOnF7k9wYoYmWZyboCL0POx61xz30ksY8aLEk8Ki27FuXR+HGWl+A+phrioXLAqFSwrYEVyARklwYEeaDgmQZgwGGRPfOhYRX2mM5AGBDSCiUCDcSQgMjkiyhyfVQm5lXiJzJk22UOpMfh1G3CtX3/kPE/t+/Ub9Pu1R95vjfVrN+j3bzjT+EWVHQqOd0IOkpsh/cT4XhPeAS7RRjrMdIL4zRH6g2nBrK3IPWyRX0/tff2CE+30pFdSYIViLIDDESmKhAHwsRaJiOIvi0se2Y4ZITsRGhFsIpjAJwjBPsc8lIm+xZCJvtWQib7NkIm+3ZCJvsOQib7TkIm+y5CJvtuQib7HkIm+15CJvs+Qib7fkIl+wJCJftCQiX7IkIl+2JCJfsSQiX7UkIl+zJCJftyQiX7CkIl+0pCJfsqQiX7GkIl+zpCJft6QiTYc80Am+nRDJnqHIRN9hiETfaYhE32WIRN9tiETfY4hE32uIRN9niETfb4hE32BIRMNhky0N2SiLzRkoi8yZKIvNmSiLzFkoi81ZKIvM2SiLzdkoq8wZKKvNGSirzJkorMhE10Nmeg3GDLRbzRkor/BkIn+xiZ+zcSvALfoBhQzC3sJ9NR3bvfi9RxnIojOshtmdDBPY9VDmWroiEek2+auGYZv6ZQCkatDN2DCOiRzxBrgKhGrBC0CGgOSJ56dGOmMBSWHkGhYLM05lMKy67Lyg0kH6rF0EE3zGDB0kZC7rhBTj/PjoUMe6pQgKCyzFQ/A2l5+dnNvjbIGOmDA7EUpQGwP4goLGPjFRMMVsIGBn5D/EXlchhGxXAnnRR5Cn2HNyDQGv3EDRvabjpwNqn2/aYN+v+7I+62xft0G/f7NjQ7sqxxERBMTaMVuUkErk8QQ7tFFrT1CNsl0RJwnbL/DfIzYR6/rZ07tfT14op2hBtFL3Dm+Chsf8sJPUePAQsTSdWtSIHagqKCt4iRMbeUmsOF90X8NEz2Ur77FkK++1ZCvvs2Qr77dkK++w5CvvtOQr77LkK++25CvvseQr77XkK++z5Cvvt+Qr37AkK9+0JCvfsiQr37YkK9+xJCvftSQr37MkK9+3JCvfsKQr37SkK9+ypCvfsaQr37OkK9+3pCvNu+VH8hXn27IV+8w5KvPMOSrzzTkq88y5KvPNuSrzzHkq8815KvPM+Srzzfkqy8w5KvBkK/2hnz1hYZ89UWGfPXFhnz1JYZ89aWGfPVlhnz15YZ89RWGfPWVhnz1VYZ8dTbkq6shX/0GQ776jYZ89TcY8tXfbMhXf8v+OCJkAsGUOd7JnjEWpFKd+xcT5nPGeqDHBoAASr3qk5mpoFbkV7/m0uw5DeAMJKAnusW+VzoufSaOQRpgmR4hS1pcBExQQSAKsErtyH6BJT/5fm34auUZLnOHhIbkoHUIEXzIpNtK4LuIXqTWVLCLowIFOoY5OwJGEY4Qn7k9t7MDwxbFaN9pAoUCYsXQkx6xK0wThP0Ixp30OMlFjg9DF7qyTojFRZ9hzds0Br9lA972W4+cM6p9v3WDfr/euN9f/DrJGb3OcnVLUELEztA8MhzyB9ldUAkdwBHvkfCziDFSSOb/kV9XwgiKamzvtPa7U2SLRGPMMSnEEUKHkkSUOrS8QnRXhm5WMsXUE+2pdxDG+OZlafZepgiOBGuQBWV8EaVIVQAPVgGt5bQdNewgyYRRn3VBVkFR9zXA19ACzTvkoSPJ72Qp/JA1ANsJ1CF01i691gVZCk8jTwKfHLXeCNXoVuJlh6vZ54zgK6gf0BPdP4h76XhdPpM1uFLSwY/h36FIQ5cWZCvOGe/PJ+EI8Wel3XupszcKzr/HqWOFZ3xpxZGMiBbMU0bJy9GSpOEbBFzCetTCDzorY/Bdc98N2SF1Q8C5zioCQXOrIFwPPStkMiIyqWohMuMKElq/T2RHhByEY8GxN5xRJJKk1/ET4F6ZAAQmGgizj5wg+ODtdV063kp3nmUmCeADA9kXGOvacEZEUVFhCY0AXUwEODIFtmxe0blYLz57xTdBShLzBAwHPKDZiDONessZ0YX4DpAmupr86gYHQBwQhiPEB/048k+E6DJhX1D6ZZrIZwsYOXvyZ3PfDQU3ZvfMLENweug68C/CqyKzBC2VSd2EZx4zrGhIHZWqBb0vzxjIcmN7p/UA7chgMB5bAKAllFBCzTOtB+90sCwPcWC+rXCiGR7QkTHJk6jfxEB3zZ3WpCc0k1N+wWV2hAvw6siSUdpBTmfXT4gxAgUzOFNR8ALk8vZF4aPhjMx5JDwTpg+5k4mAHC0MAcsQHqQDYwKye3Q0nRlLGUOpiEyHbuV7Y3vfDRmE/Mn0mlgsaJ8h0pTKcOEswYUUNBH4uAb1wJHIWIddpZqokp5v915CEfGvhAb0Hl6ApwtTlFgaFY4qnYLJZrwA0mmm9wwkfxV7Jp6WVrP3EljKo3eDHlUaYW8+CEwAbzqix0LdgRXZlR3xQthjO3AELGxGvgd2tXsvSaboZtQkK0A+TBvZ4Vzoljn3mi8ENzwBaiGJRoIXy4qYJ+1XqrPNO+SA017O0iEdcEgg1UWMXKeA0JuEy9D4Opa7pryU+ZI8wXJB68fS7L2kc+JWmOuJccQGElW6Supn2jFtC/9CCfCnOrxnpcQLNyG9DDpFhzkXW85I/QchAAOfhcURjvgUFa129Q7KSEEvxqA88C4pyjww4Qk8Pfx16mPDGUdgLTlMzgFu7VDXTPkVzMWkZC6wTOGPoE6RtLouSxAid1rzWpjN+ZWMODqYYgjpRgerw1VR6pUIhspSJRrNjXhCIqMw0TeMCQRt1hrFEtfmTmt6kOgTjz5R8ZqAvUhSoiYqeVC9a4ETg+l1/vOIus6YWPAg8Aw7j+lu3yEHSLkUcN7EZ2x6lo3gG/2IrVZpAiyfEYVoeTRbTlSuAuGbujy8llTa7L0UxcZz6kJIcizrl5VRpfgGrUieGcla5IXOUhyggsiMRaSCCXDYNTbvkGNIB4aFbxvDF5ZSiUzYngebJUIHIg4+viwYCupMA4GRfETQFxpdQ8MZqTyAXwetQadEQ+bPCzmHJb/MI1NsGSEAqMtEzh48zINEBMOHw09u6Zu9l35CzaJvAU/Etw7OAOFEoqpiSY5H+xBvyRsxSqMLiEF7GREV78BiDWeE30Gmx6Uj9hF2+IewUvwa8ccQbqLMrOPqITcw/UlbFwayELN63SU815xfWYVHiCmUaJzO1IpwfoptmR8dSW34gdx1JAVm9EpFjYmYtIlCPJSCRbv3clyBf5R5Fz/LFXsyPcSFOZCn3RtpmEM6j8+g+tQ7rS9qrthHcTXqtM3eS6QSConfVilHJE1qiFWlfEf4wnkN5Fs4uAYW0koIwqhi2VmW8GgEVXN+JXFglgssYV5GRec47IgXcXRlHeMMqR+GlTjPqEHKWEuj2sujQCG55h1yCs1yKsBnmAppalLYK7utKSuOCWfCAqsAHkQZ1Jk6DEaUpUr48hCqljMuI8yDmkUBwTkqjMw14AhAcSYg44U6XbPqAeYrc4qoAc2i+DyOFEpABQ1njD35TrhhnAK+E5dKhKfwSJcRAgr3uCinNwo9KwqTRX7EO/NPo+4saM6vhNt20C2q4UWNgxTnzLKkujHSDCp9hGYCHIlbfMXLKfJFzM1w+fb8SuYEqIJBZl4SdbSPh1VEqofOBuILaBVxyAwljJAtsZQsV1wAZRWyzNjcd8P3g2pWUic2nzKxSrAV7USQrRkRwkRzYoZa2FQ9kNZplZstEkIVCbzfR9Wl/K7oxySPO9seeQ60kcdfBeew6lS8IC5Ma1Qi4CuBovnF2rPT3GmtXAgxygKfSfNbKj5RlJsgYxQgGbGqfDFgSFcVqSGCOpyOtU3Qrs19NzyNpEjK4APCmJhEOSJAJdYm1B+THCgNrfKUslxBsRJRePZEOSqTcWj2XgIfgb+MiRtVQaLeXzDzIFCpLVYFAQiWRgpmwWQBuVFeH7EKvGPev7itk2CHHLyUIqyXX6DKRSKE3rBkUN0seIdnB7xTfqOuTtIbpKMy34K8avZewsxEMgscRCyfnAB+mEW/EVLELhYQghWHhdjFFaouPSTwEMMMbmzeIcfWIxqFuxPVHZ3N57IqpQVyhIqADPZBkBDOhXRbMvoQIBC1Rwss363tfTcddJ2UCKsnJTJg+i8iGCCNdaPlNTOhFGeoVMjOIeLoJoAWDDSXhjOi/lQvHlwBmkH5aSIPedCLsJhe6gooV6g6j011Iccgiozz9IdEqEjNO+Qza5mcTPVpGibWOAyehkHEE+ZTG8WoJKvo3ItgylmmaQd44HkZatJwRipFwE6cd0CrOfT2qIo8cA8asiTdBrFDVTS8V9m1B16SjYhzODDWVPMOedLOGJaK2kfBDWpPHmSNdML2rHgmVK7IMCQl5b5B5UumtZQPKhDU3qwhYB72Bk8HMCpIYdwXbovsAMJbhRmpIFAX931P9VkIS3U4Kr/EDFJEcw8uKiFhEakEOWRSRwRi0cL1GNGiaApO17GOYMeOaCHyqeA4Umyjbh5ys/eyZ9oTI2Q9aV0S6USOsT5wMuRX/gLky+okWS4IIuqxvVYPEoSYOYRvbJh4UK0TxUHzECc7/EYVFRdCvYO1jgQiXmNtSI3aGeKV7fiLXtscY/veqYo3MgUFjiKrAipjwHjuuGloPOVXJG4hzjCczFV+5yS/jEMhRw3ekjP+tv124ScwOqwH1LZ0QK4dUkVuhFil8zjDDiKgiyfmIMm3x4JSKCcjMbhd8267E3ImzlMw5pPINqwqakmIfEIXpS+ePE8NxtcRSikmDhS2Wb+sdJjr0jecUQ7H4ySoziOCxVh43noxnSBDxR8YihWiordqrkHeVUxT+KXSgNyIDWd0Eqb8Nk9NyFFPJ1VhhClK193VKOQnUj9Zgs9kyCdifb8QUIs2xI1+k32cGoPftgFv++1HzhnVvt++Qb9/x/9DnNExH1Ew5CbKYV67HxCipEEPnMBkdDrwskPWjAsKi/iwwrdHbUqM2BzUUrOfEYmYOu1tmhENzOpVh8/q8h7SKfpmKRhqmKYQ486osLbkqrDVlBFdfUuzfwpDV/TeOoAur6xXlCkiFVeHsdBeSIQHvE3n6CJ1Fe4B+WiDnYZLzX5Gr3MrqIvJ8JN04HZJm1B2qp/VQeFtRdNIY1HuFNvfVQG7ccVCUGkIzTve6BbsEfXSUSNK0QcDxE/OFNCJmDjhqM1OlLES5W9yYse/GeyggtXgmnu10b08khXcA9tBE2AAcRjAylxJHyzayACoiDfy/Em1FELpHNmF8FWSCw1nTEAUJBb5HgWuXax5kaaNysbEEd3CzpDhHHEBUSQPxDDQ7gH8R5W8uScHx8z3BBXn6qzNQwMCe8EOK6MHmese2AaQWxG3quOpkDEi58FoxLnmrMrQYzJmUAGlWx4pAGRWbRplQolnVll3Vd3Oa69DJxqNu2LODhGJAzZuOCP5OMooq7iGfWP9aHMqDx4Pg/yLOpJY3HqU+qUMA12kxUwxUpOPseWMdAZqXSYkAsSG0heTS6lv8AAFFAy1pF4X1CP4e+2l175ZWAhiFzfp3tvsLUJ0Vu3j7RK4GQk9q4LPjCMd97FK7MIVcDHUTfssjICipjqtbY94mYYzQt0pMjOByPZQ6I6EhkKliZiIqMJuJyHYQ4mCNvOQA6jCFqwqrItqZHNWJU+RfEJJP3rtARoFrKhm8WdBbyJ0CxXJTjkGvzZQMCRpoeQkj/TSQsMZlatQLLAaclaHqnaFfAmrQSNEio0IEBRo1GZJ+HagAokb0l5dxgDP2HBGis90C3zVg7boH1BpZoyA492A9AJ9Rq+CN0sGeZNJvZIn2owFQaTF7TveC1ORkelXsP+guhomloHAAmELQ4J4oEFd5ptQp9T4Ea3akgnlY0EtDWfcvRGB7XbYMjgNupSyA6Ihjl5FWQYNoDShq7VWIdNexXqKBNpTWFvOiL/D17sdKcPdzNr5IN0r8NNDPBdiLLUUgRrMwaxCLPpz0o7SoJ20zTveQUoAXQ4YY5JN2gNOAYLJ3atYubIskqgo8lmeTSVWAUJcFisY2dhwxlE2GBsAYaE2wkJzHZQgAgGZ9zimTvtRes0PRo/4C3wNcrnUZfHl4ePNvJ+pKyCj+kUESRtu5VBmz6PBVQSgIItslENENOOiaBMohPqE08RpzqoM0pLaQiIzWEHAVKq9TmeOgdSBUcYZanc9MB9etRIxcE8zPpAQNiI8m3e80WnYAb1NQ6AmIFJPgi2Rz7IH3OhWRngjNdqd8ZkE8pFKWTq/6Fz0Zj8jrIA6MlKxEJ4g/ZTT8Tg4CpIYKYXMiWAeBVBgI6h1rwwKEoeB0KzUcsYCGGW5acmJP/eYkymIueDDMg3QwVayuYk1Nsxqr2o92inaw0Sad7yBYVKwdAvYTQ6jAOWUrrT9FjWqeSt8pzOUZCSZWpRW8JcZm0vE+HxbcyFiTUoEPAkeHMlSJ0HhouHOlOvxmcT4gMFnAWAV0b39bilQ3eFhfEnjC5jQIic8FL1ShDGL2Dc0UI18VmFgtbeKSMq0wB0hlWdZIEgiIcX3T2+5hseA4J0lN1SPA5GQLgZP9Yx5XgDtrPSF+ijTvzLjKHOmHMUCeHANZ3QYVcFOvxMC4ERc+qxTo6ie4npUCBDKBYdA2TG31A0WlY16Jht0pntGu1cGRcIPkL2CtPoC7lWpg7VL5ZKljY0OPX4YR7tQ4qTqp7euCNXkmX5sOCPV2KjXympQyQ5rof1z5FqSmw7TwtomGjSwNjDvSgpOL7YwRLpqYA7NO95EeJ21xbqXAisk2Uk+teg1C1jjAiGj2EQE4XsgrZ6IvdvaDmlfcPbtvdrgMC0L/ORMiVNbnXrQY6+9TZ0YgbZsUItVqYlckBcwNnEc4CQP096r7VT4YEZ1OGw9d0YLGTJQcqyi8ywXQsaoPRDIS2SwzyhO6H2A0sHIG86IteSBqZJBNXtFNcH9weOqr/CDYG5tWwMxoFcIjHqPotMNDVh4puBUm3e8qU0XCbSQpLxhNoBcnCNmcCWo4OiQpYT3rJdqJFBEy8CRzC6VK9zz231Ku3owEiRUFD2VRdU40V+IHTgev4Z5ylxAQ6smK8E0iomh9gDv6QUtE0eDBpHDoMhKOovMApjkBPwnHsMueAS6NoL1R2m8RkxuZuni+Pm00LQL3wnQW7WUKdAwlfHF/KmEIYkGnEMemkSnMsGU2UjkQOEF7VnV20jNnqekzVdSOgCgKelVCbSY03YdesHj0obBRXUcRphB5Em63V5ZqHCaUrOfcQEvs+q+kEpB3tqoS90NLbGSL6jFsFaok0YVwbU9UeVU0gsZAAw0dc1+RjgktqIbdNuursvtg/bigUIRaszgCn6ler/jG4Q4yviobsQ7s78nfOTmrMqoEIoih6xAT0kO/FKn+IOS1K6iAZKgzFI1B/Euszb2FmqIRdmj4YxMggH/sCAJZ2GBpEoNSUR7WskgELWOklzfJ81oKknaFcVYSORFnkW7n9ELfQ6a9uj6eVGxjoBJ8Q2kyr9Yd2RUAsxEiAXQa28pko4cSrKBXTackWXBx0CUoBmsbmSA7g5e+GS5t55qYyAqVG0gH0hY8CaEFz+z2xa9hHY/I54Rq6DaGXVHajK0R7ut6XSnN0CS3sVjTVGSSL22t/PwVr6fckWks81+xkQuI8AFABGVyUWYmgUzdiFlvaKq3S4LNVFlH8KadgpqcmMJXQ80KQ1n9HwAcRlHCgiiEEc6nPSyksR5J741K6su0iMZbhy0/0XmiBCHixwbzki36TwNryxa/pbUvWjrxEjlcyI3zgA1oCBBH8yIKNRWcS13amk82eZebVUl+a6B8DEDa4rr9T4iKBztBvwFTWO2gJTEWigVv4JHn3hOMEwMQGrf8dauADJi3m27xV4xWYPvsC/Lbo+g3BlrYpGBkTqDQRRxX20/iGs3NpxRRW+8GQFTJRsfVTwmZ0bwKkW+Dga14macWJ80f8Z4EG5VLya8uOYdb+i5AjrOnqEGHhI+GX8JkECIlUYiOrOoWV6OkWVd/uhGkIJm6ObQ7Gck9FGMXaQt4a9Mecx67bUTZXR6f44hpJLJ1EvU5fAbPIJOb+AhLwgUgyVnfEPz7gCJa9i9KyBJqVo8y1uqcgB/IsMJY502A6dRdfLdBi2q36q2kT9i3+xnDHpbHLk8aFcqFVdqpZBFbfeU1dY+F2gtvi3ohVAI36Q3JFlTPC48TmrO0KT4vFsqfrdNC7fIL4tl6eMkNIi8IGC4XQFuooCIc4R7lKot9GDaxTecES04JSEDWLzelmJuVfqkPQHaqMRapGqKYyGEyQzxweS/WISTiC+TPsOat2kM3rABb/udR84Z1b7fuUG/f9fG/T50P7L2rr5+g35/11dt3G+9Kw2Gp3Q3qaqvffd0VjqL+KA9HL7TQobjUM3RjnsENIaZIsCENtjVNH7HBv3+7o37jWrSRiL0ODV/BJheRcGBLOIbaMeCgMDUUK2m9hy0GWbS+6vzQGrF3fVFa/t3bdDvdxr3+4tfTzNu5++2W4/ecI57w3nj98cCdYJE7LE8ZLysF1Z7veZbJf2ZKACgIWpjFBbdq7qu3cKICWSn3p1x4483B91hX15j8Ls3mINvPPIco/a9cYN+/54zT42193vb/Tm9Xg/sHKxUxyqDxrFqFDKoLuMr9JLHyH96iGJeJOv0Ft+oP4SDDLFZe3ojvNcJP3rrfJYDQsdVVFTnhXb0niQmc8c6Ka9h7AftO0clw2QBo/trD4OAxYYOoXpxk3wrKB0coA0XcfATIhhbo1fwIcUwoAk/CedYC+F27LrUxEGAGb8HiBMyv27WW0xQUy/qSnFML1JOOgupR7RnSGnQ66irsCWh228zBzUGv3eDOfj7jnztqX2/b4N+v+kpsvZ+f+OtqD/IP2FeKJeM2jaZ9H6xziDoVkADzEs7tcZRL4kE5GOAc+htGR3K0649bcSAI0KNYFSkkUVVEwCf132qHehXggQHLdwJqZ6j3tYdtUU9ZMj0/trD4VDLc9ABcBq/EQ6wapnALSmqwM6oMgTS1qKa96hXvcs09RXVp9fnQ2jyXg8CgH5BRB3lxZBXAGYpw6rNkXrRVFtLKdFUHgXlgH5eKnZebDRBW8Imc1Bj8Ps3mIN/4MjXntr3Bzbo9x88cm8ljfN7Nuj39xy5t1J+edMG/f7eI/dWWtt/cIN+//WniLd6s6G3Mpzj3nDe+GYs1rw7bwLQp7oCRU0dZrODg2RXvY1H9XLSXoy06J1GFtVUkLQTNJMi8CaxVmPw5g3m4B868hyj9v2hDfr9h58i+u6PGHqr7zH0Vt9r6K32156f9I4ixVY360WoSAl2DpSNqNnsNl6XSBJb6phUN6ePY4KAJL02Mie9fbvFHNQY/JEN5uA3HfnaU/u+aYN+/9GnyNr7Y4be6nsMvdX3GnqrZu3BM4oOHBu6ISaVWynjjzzFoh0cQI1VmwUnT8KjhDiMS/Wqv+kdpNxT391iDmoM/tgGc/CPH/naU/v++Ab9/uYj91bSOH94g36/68i9lfLLH92g39935N5Ka/ubN+j333iKeKs/YeitDOe4N5w3vhmLtbq8DuSr2k2s+xpy0lYsAsLEc/M6d1fnqKxzKSHm3f48MpWCSNSbjD/eHHSHfXmNwZ/YYA7+ySPPMWrfn9yg33/qKaLvvsXQW73L0Ft9n6G32l97wevlbirE8zIU8q6TWuQXBqdzkLsaSk67M7GmSpbiI3T+Rx70IvyE4A1bzEGNwbdsMAf/9JGvPbXvT2/Q7z/zFFl7f9bQW73L0Ft9n6G32l97LKsELZwQSq7QnC7rvCadmK0bvv2s1wbnoD3KcdGR2Ct95RfpeICQfL9J3tMY/NkN5uC3HvnaU/u+dYN+v8Ww30/70TX3pad+7Jf18/gJp7aJGaeM27nhZ4efsPdsv/j/v+3Mj/7Dl/7o/37b3qT54teXbDgYh07IbzOekKf3+rv/Zb2QvvTw5+m/+H9O2U+a/89n7z+Lbz/zhf/9jpOT5tvP/H9n1Rf/TN/000806ks3fIj/Nz8r/Ohn+W83fBvgO87YDq51NNSiUX+tx+PbDJ+h5Xi89YxthD753A4lgnLm+47yUNImt7Gvkg8lWFJQb9lATfy5jVWUxXzWPLROgJbr5M8bP0PrvurzDNvotZb/3AZz8TubNq4esBBiWoPXOYfT2Kdx8P2k8yN1dd8w6+q04tzuYj7dV7Kua+emBMboux9vLrrDvrza950b9PttR+5k1L63bdDvv/AUWDeWeUtr5s9v8Bz/4n4bdUll5HvBajrEV2drK+EUt2adA7e71m4cdOBAFlSofOoax8nVBb64pi3mj9r3Fzfo91868nWj9v2lDfr99q2rqwdqH8XIv7BBv7//yKuMmuNv36Dff2+jKqO19/jLhrHScKz9/vMLruqgI52LRPkBgDpQdSAOrkMJutcnTrrFluKEjuWlSgLDTUx6HYa2UJXJP968cYd9eT23v7zBvPkrRx4f1b6/skG//+qZp8Z6eccZu2re9xtW85r10rm19OMy5nUZxrj2s86b8mNRidINzsWgI9v6aU6L7qeZesqVLkRP9TJRYdhi3ui5vWODefPXjny9qH1/bYN+f9dTZL189xm7Ctz3G1bgmvWi0zyAUaHoyCOffOEXZ1aqrtRZltmnQbfF6TrCGnV+S1h18FrICZE1b6O/9dy+e4N5884jXy9q3zu3eIPqyHc3Skv81Q36/d4j392onPBdG/T7B47cd2htf88G/f77T5Hdjd9r6DsM57g3nDd+fyyCLuIpS66zLn0aw5h356aOQ167TLJbxnmYV7xL6XTW2KS99uS/4QtXQfTlx5uD7rAvrzH43i3eXjzyHKP2/fUtdpI/RXZYfZ/h7sb3Gu5u/AFDP9SsvSEMuuk6LEpILqI3kW1x1HUWuqVJh0WOOjNSJ3XqqL6EFhx1luCq49w3eXtFY/B9W+xuP/K1p/b9jQ36/TefImvv3Ya7G99ruLvxBwy9VbP2dgckpiXrDnCdAj10eaajOiwcdAfXW3VdOE1ERQ2ln/k8nX9fe933EzfZWawxePcGc/BvHfnaU/v+1gb9/ttH7q2kcd61Qb9/8Mi9lfLL39yg3+87cm+ltf23N+j3P3iKeKu/Y+itDOe4N5w3fn8sfJpTSLof17NCUKXr2IcFubfurl1wedYtdai6HCPhYlG6WtdeZfRBd73+eHPQHfblNQZ/Z4M5+J4jzzFq33s26PfffYrou+839FY/aOit3mforZo4WJZxd8Po7hrftCZdVBB1KQdheamYLFd1vL+f0zjryr7B4bmq7jvhD9d+izmoMfj+LWr6R7721L6/twVDfoqsvR8w9FY/aOit3mforZq8N/OXaV2X4HX+f+5RTINLLMeoI4CHmrvKWh5XPt6vdZmG0em67tyxvsu0bDEHNQY/sAXXPvK1p/b9/S08xpF7K2mcv7tBv3/oyL2V8st7N+j3Dx+5t9La/sEN+v3+p4i3ep+htzKc495w3vj3N/kKLo4InHXDXi5rnepK9pyd79clskSoYmWlqzSMEwHCD8usmw5dP5Wa0iY3lmgM3reFvz/yHKP2/YMtYu2R91tj/UNbxNp9vdjFros4sbXvdH+wxxMNtfDdcV0QV30/YufmXteyZz+ETqbK4XCWipmp4dTe1+kT7Tw0x/6w4XtP79/v87pOfcI3hjR361B1ieg463rCwa0r7rQra64DrSAbjuvq0clp6aIuK04xlR9qThChVboQVHa0YHh1tSntnPgVpSiB9E7Zc/Ql6Bbqyt8F3UhbvJtrWvfjlw/DqPs58yJrq7tjXXSo24rYpse69S/OkW6PdfHL7BKPlw9y44RKryU28Wua8zTwNQ5B12ZO+O8xkt9cP6QODqT6xKBrUROPQgdI9nOU5J7niCDYhA1pDN6/wXz+h0e+jtW+f7hBv//RkfdbY/2PNuj3uf21HLKuApzXkspQQU0FG0tWXliNEd5Uly9cRkGwKo4V7DpdU+bxiroy0zcnKDz9ZP99ZTnrGkOKdsQ/3aXYUdFTbJoXghkR08Xkdb1aV+LupjwYzzBEr8s/0378OjQWnjOMhR/Yb1eZEb51gL31uvDUdwmvX2OhZjli7kFVdGzsCq4hrl3XjVQnEcQ+hWUEkTWxEGUU84BOInpNuZ9AA5Vop7tRx7nzKVEEdf2aCYq6IXeZ/FzmqPsjcyhzarRcRnz5segdh4kRdT0Ebax10o141FXXiVA2jgl+WFe+Z1zixDBULA1uZcyNrl4XntNKv+LQL/qhmPlZXTwa1uq8bokOM45g7qEnNMd3w8D3kiSmcZ2GLdaGxuADG6yNf3zkMUHt+8cb9PufHHm/Ndb/ZIN+n99fy906lzisun+8rx1rYRizLnKNCyLALUiLgUmvi6/CEEOkYAQLhAcKALB0Tu19fdmJduKWna63Zq05rA4hdUoYZ2RGmmNHRPUsvAHYnQtiYomDzkmbupwmXwqRZT8WHhpXzxnG1fOGcfWDzTsyiKxucJmURCmChMQTBKEUXXC9xJna3ahLZFOSz0z8Vh8KoammGl1yjcb0VPgizzWWeRoXOA2BjDJHgsDCWScKHwm1qXpKJVgTHN0KCR0hnQ4Fmtq42qUM5cn6TtS8Lyt4NC9oSvQtvxvyAcOdXQCxOqoxup91pZIzjbkndrcaM4yr81PKVX9DNiUXl2Ul54apji5QbEE+kwL8sJItVoYahVwFZhP/3mRvp8bggxuss3965PFF7funG/T7nx15vzXW/2yDfl/YjzEpT2EiNs26/QLz1lFjn2SOCbLEnlHhc1HNYeVTKg55zXmgIj+zNPqQTu19ffnJ/o9DTCnOUxdX3dk7+B7Xp61h1D1QRauu+WU5DuJQCSzLx6OyKiJnnnLxjcY8MEafM4zR5w1j9AXDGP2h/T6Ouoc+dnlc+JsQA2FpjLo+GiiwMNh0LpNCdSf7SJ24o6NhrjPikA/t5yZGu9wVaGHqoSJunKe5B5+QVfuVzqN0KXIxZwZ4ispkeH+CM7OJEQ1pck2MpjxWfQY7isPwsKc1+byMYR2y7wnZ00T8jlPMlSQSaRr19TlMOn6kz1TPGu27TNAL8g2Tyq8ABj6qdNPQFWbztK5xorg39h29rySQYVkZImZazoxOcZtwTI3BhzZYs//8yGOV2vfPN+j3vzjyfmus/8UG/b7YML2hVHRQwPRnJm8IHoVbZ5VzVjzdGCs+MdQxdboFPXZLgOux8HoMKjXyU3tfZ060E5kDLSyOj5qGVQQtUDJa5xFZhqwjLGsDSdVJwcMwTz0UsFIrgzhM3eprw1sPjffnDOP9ecN4f8Ew3l80jPcf3u8jNCOIgYZQppnBIe4pMGubw5pyKVPQN8AaCKwEZ9WAprnTvVc1z93Q1K2oA01lpJfD6vspOsVkovaK4B1qGjRnCN61kmPWjjA7zP0Kz1CUhrTHhvv6yrdP/Rpjih6US4eoMDG5ViBtjZQoV78iqEknyfVzjg4mrCQzMKBz12hyCBd1zQGePxSqu3FJjFSIYxfgHMxhmJgfx36JXqXOdQmO/MZigV/DgTd5B15j8OEN1v+/PPK4p/b9yw36/a+OvN8a63+1Qb8v7febUELhKmRtHByps4w5+sRPLx2yCOeZdba7Kj2V+IMKRyd1usYHD5qWMJza+7rjRDtDRAbFjk8FK6+lJIBK6NbJT1RgxjwXzy93gbjaRxegKoSPnrJKnjKGewxNfe3A3HHOMHecN8wdFwxzx0XD3HHJMHd8ZL9dzDRqfIRLHk8fV114PfMnvaoO1TuXE8lkWWgoQ6TxwC72EwhdlbUQWp7TrWmgIBjpIv89YSkZWRUFcxkyg0HlD1dC3W8eGM+4MujzF0T6Qo22yR0E8SXmFeZCdimBCsc0Fp5/p/IfFoIKIl4iTIXq5LrsoP481x37nvraN7ljGaeSmeIJ1oOMckPP7BWymevYUxDWtsGKbuoB4/ozSqjT0A9+7sKSt3lnSWPwkQ1iyb8+8hiq9v3rDfr9b4683xrrf7NBvy+fafy1I9qyEkZopafOrohJYPddRotBQSmPLxDVlX8ae4fbXxJpZtF7EzU1XuErTvZ/kMXukh9U7yo9KHZefEdpjLCfEz68C9pLxNLv8eTTMlaUmFCrXs/wsckdB+ahc4Z56LxhHrpgmIcuGuahS4Z56LJhHvrofh+p55BieBZEfj8wMeQZIvageFdUFu2I/1iGro66BJ5mehpVVQkiEcyth1m9CFXpCPRMvqwXT+H5lEMHEkqa8C/8DbXcNM9DrHo/o2Yeftd3/OPcMKvFLStpkAcRsTyOqV07HezgmCXUHOqEOQeQUpuNA/XfjBunjkHhg9JBnRtm5We+baKeUQutjlSCx0nXXg2d1u1CqwcXh5C0oxzjBaUqqYbFh76sE6R2i7ikMfjoBnHp3x55PFb7/u0G/f53R95vjfW/26DfVxoeEfqxruPghtjX3RGPVOvmCqFAD6L+yCWTUkO3LC4uNUW4QtRLT+tKla07tff1lSfa6SkYztQbV6oShF24A3pyWZeOxednKEgoeVCw92FGuY7UHLUPxJdlRO/l3DCrA3PaOcOcdt4wp10wzGkXDXPaJcOcdtkwp10xzGkfa57XOPu5rIy4LAlsaxxjDlOXgg4/9b7UbuhYFjgYUkEOa+JjZuoZfR9IT20dplBuCRToStdTe8YcpXVhzqWkPUYd5RPX98ssHObRecLGS+X7ek3JZW73Y1allbg7uZ3ZubKmvK6zd4WaDcVz9Y1mUCFfVgghz3TgcXR6L3fuh9rUYSZ5t1m9mSNTmWJQKh2F/oEyU+EH6RJ1JgY1s8gZwqXMnnoUE1z5NG4R4zQGH9sgxv37I4/tat+/36Df/+HI+62x/g8b9Pvq/lomOfEvQhwlzq4HdQfKlQ6B6tGT3RjgccTCcZlcJUX0E5KNCOm1zZxU0uwnP3uinZKXIxiv5J4qa0fE8CWPsV/Rl/iz3U5ocil8n4rpSp6aQObaN0OxE3rS1GEOzY/nDPPjecP8eMEwP140zI+XDPPjZcP8eMUwP141zI8f3x9H6ktrGeaFtk9ppTY09oWC1KL35xkYfv8UBipZCRg+j5FkCUWcWYqUthjYJj9OtBf+QXrRYyhpShF2iM0CU1L9QmdmnhAztEzUhagT9YnnqiWaBlhJkx/JtNEv2Dhtuh0jS4O14tPSdd3c4T7hiPyysCyej6sLRVjyL/+I1A0hDPv5Uft/Yxjo2crzKsMEz2cdZJ0VyHwlkugVlZyoWs2VSm8/9UuWJlgck2TYJF5qDD6+Qbz8j0eeJ9S+/7hBv//TkfdbY/2fNuj3tf21PNRRpyoTOomweZwWwlpPPpwHmEvM3e4gMBYfJJLM2REIPUVcSsGhoxLd5MdnnOx/ik4gBNyzVD54nBc+tiuEpilqJ0SfFC6RmpS0SaEusOJVsq5kFf6nfV/hsFx7zjDXnjfMtRcMc+1Fw1x7yTDXXjbMtVcMc+1Vw1x7zTDXfqLZQ89vV1lv3M0eNzLgkFD+MTs/rYtzmhjz2i8js7WfR/6GJrne18EPeWlyLQkZ5+pZzFTkmAojhb81UDZcB1d9Tkkn4pB2Iat6U28ed9UHF1ZWbpeGJtfGoY+ZSBCcD2te+5WCoQv8AeFiHidHnEAbuJoIKVPQ0TZ1oJtkVZxnnhu+upaEAMdS45H50TGlwa1jT/qv1AlT3xfWElOPBznQxzlVOt71fujJv+sm52doDD6xQez9z0eec9S+/7xBv//LkfdbY/1fNuj39SZedZKRlWr1tFbiCNUNCu+lX4iUaYStDtNCvKdqzqeQ64ISC0aUgAl9nU7tfX3ViXYGFggFk+AT2IoUluZ1oIG+92OlWjG5uRszYTTPlBHDui7alLi4aVnSUAm9DV89MG+fM8zb5w3z9gXDvH3RMG9fMszblw3z9hXDvH3VMG9fM8zb1w3z9ieb+bXUqK28wTHRBhaTL3GYdzecBKJAN4FoIy3HMU+z0xZJcnDuGZ3gXV3bd/oXnWnFE45UV/t1WvPMpPYsFSqTzg0ZF9o5lhOrXm+mpp5VypICL0fm9w+354jwdzzwNM5UOqdhFwbmDl1AaIrS/kvAQu/eBeO5avLr1EZWBIx4bfbnuKSXnCfKvivPW6/z+7r2jjmEH055GZhG/USJtptA3IWPZhqr6JuHnmW7yd5OjcEnN4jj//XI85fa91836Pd/O/J+a6z/2wb9vtF45MXlzq/dMpO3KaQgk7uiBa5rvFYyIwmEHBkixdLVu7HU7OcZqqQ4l/Opva+vPtFOr8MBWNZuEjeboUod6xiMxKKfWNw6L58KbKHBg07uoPpD/na9Xr5cCHDN/pwDNcA5Qw1w3lADXDDUABcNNcAlQw1w2VADXDHUAFcNNcA1Qw1w3VAD3DDUAJ/aH8egHrHGGHdycUDzZ2rHC1M89oNOiWWF0tZCSzyON5NNsfkZJB5djkO7RzeUxRFyJha5XpvLS2V1V6bP7idi1F1pVXsG9W4GGHqJ01Tj7DwVarc0GoBZuU5DWZeZp+9lQGB9OoVHlwHUSpk7jCxqT+KmStwvlaU/zTpqKWYgfsPJGXlmAB5/djyhrPetw1wA+X2l1kZQWAYHXofYU1yOHY8D9eHhCaHLddzkzjaNwac2yAn//chzodr33zfo96ePvN8a609v0O+b+zFm1au5BP+RFeZn6j9xCJF/CAAopPvarZrPAUnsHJUwAs8yeQrPLMowuvXU3tedJ/tfB0IVMXwesoLgRBYCtZNwI79FIT6kbqGhFVq/EssGwbZCDqbM5ta2jnygnjhnqCfOG+qJC4Z64qKhnrhkqCcuG+qJK4Z64qqhnrhmqCeuG+qJG4Z64qahnvhMoyewHj3P1aseEFY/Ugofh8Rj7lgiYgdJYWgZQmYgxRZ1QPaKcuD3Dc05p14rghVCVU8v/U95ILXrkEFK6GWZFmoKM3X+kR/t+XU8LgecVzqHUrgYmr3WtECXePFc08wy5vdikuIYKbnnHGpXE/O8p3y/FP5mYElpQw4ggHIAi7Y9G4tqRJ6oXXSJCkCsqmSw3CbPUxoGnZLGJ+i0Gh0ShHQaBoLGorP2Oy0MfYZ1ftEYfGaD/PI/jjyvqn3/Y4N+f/bI+62x/uwG/b61v5bTitwmnI91CsSgYSZ4RD+Ta9e1hDJoK6eOhZso0xGoWHmOfwIw1OD71J/a+3rmiXYSmIrzpU8lq7Y3JRYvUVFRDylRxjXvNtzUwl9UN+md8x5bQWkReT7mqakFHKhNzhlqk/OG2uSCoTa5aKhNLhlqk8uG2uSKoTa5aqhNrhlqk+uG2uSGoTa5aahNbhlqk881z94X8ADpe+Xp9xPrhGXAKs9ipzRiXIc+qxqyVhjHzBQmumGSZuRACGt7Bnu/0gzqnyt5nfrCXGnn6oLKI4VAUT1LBoWREjOUsDNqkPpIBFhXJskPt3qCogbLBHXACOpVLdZvh7hxZeYxU53hQftQ+4iS0rnG/QSpgGksk85barTJrOsTyzQlFrbrExOnX4uf8uxWz6yjbFuYlpl542YQSkqLD+PIgiO+8ET1Gda5SmPwuQ1y1f888hyt9v3PDfr9I0feb431j2zQ79tNjIHPRRLpVIlnLBS39nlBvs/M6p4fKlF4b1H+65Z+6AOxuwswwzw5tzTa5GtOtNOnQPUy6cotKoBEMP7AxzkUTwRjPdaZoMXv9t4RsHvPmgSgDORRXXfQtXsCD9Q55wx1znlDnXPBUOdcNNQ5lwx1zmVDnXPFUOdcNdQ51wx1znVDnXPDUOfcNNQ5twx1zm1DnfP5/T5mcroePLJi9VRaYp4YWh4QD4P/1aE/MytZOxhL6J0rOTq+T+8x6NWGZl9HWDrWfNL6H2a9UM4T322ZIGKMfok4QebMuurg3nEpOfvq3cIAE0fAKq3O6USas885VtWdKg8khsAq7pYydl2ckl5lHJE906qNZR30ZSUslZHQ1pxPDqZJOqYlQWEmvmXQCTC6CHGg+M1iXTomw+CIpaoNRT4/U82JkHCv45w3OZ9cY/D5DfLe/zryfK/2/a8N+q1Dpo653xprtdG63z/hjn39gLwg0hKMWYRD1MnjUfeQUDSdhgR0oYo6pt2mZj5Kl5wsi+b5QKZbhkbn/MST/Y+DNlmPuoHQTT1aYoqVtNqRG5M2VxdWjc9RN40uriNY0hRCXNCZe0Np9nUcqpnOGWqm84aa6YKhZrpoqJkuGWqmy4aa6YqhZrpqqJmuGWqm64aa6YahZrppqJluGWqm24aaaT82Hhpnv2Tvs0K/xsHlSMmHuZUS+JqZlOjUOjE185yppOsm1zQBcSZtp1vRHf3qljX1S2rY0EK8HFzndeMdEsXPcKAlEyyK40Pmaa6BAjxIB+GVx3V3DI82wTBtqcj37f18+l143JF6WU95iSBTcbiVT2aSoN6yLsDqVn5D7Lpp4qGm3ZyYxH18W7eaKEx5z4CnjL7iY5ncvvjFpQziqpnYl/s6d0Pg06OOq9P2nW5YSAPTJmcEaQy+ZIMc+qVHrh3Uvi/doN9PO/J+a6yftkG/T+/3Gwy76owuFbAqwFPXkybm87jEkUptPwcyEguRBEvgUVGYpDY4JRaiwHxq7+uuk/3Hk4gJ93qDvIKQacicZ13GNKmMPLOY6MdCFzwfStWb2FiXPiILur5vNNOh+uucof46b6i/Lhjqr4uG+uuSof66bKi/rhjqr6uG+uuaof66bqi/bhjqr5uG+uuWof66bai/Gj95oP46bai/nr4fswVoxrlS3krMHb2FONeVEtegnTMhekgRcWFi4FYewpI06uu46HGmMDXnWVH2orxH+OiEozKzsETCa/B5ZD2wSBIzFsWkE6r4dWvi/1EeU2FtYpm3+5ARanOditehV6y1LoXOh+B1dUidsdxdRxIBKY09E2aOlXW6jGtdtT1oiH3LrHriFz3pWCC50zGUHevIFXExljPznpYwsqxZvRhNl9F2bizMtLHUTc4K1hg8fYN8/GVHrkPUvi/boN9ffuT91lh/+Qb9PrMfYwhFA9pgWUZCfV6ZwYRybaoj8uJvSPloC1aKLtHcXaiTpE36OEfly+Yd4medaCdZofadjqWDaxOfF50fnleCxLwuhK55HPEscU0sVOIfq7KftbTmnuVNLG/fIT5My50z1HLnDbXcBUMtd9FQy10y1HKXDbXcFUMtd9VQy10z1HLXDbXcDUMtd9NQy90y1HK3DbXcvv46VMudNtRyZwy13B37fUTSxB5/vbo0TKCq1YduHojvvmjzElGEyiTxZxcI40SxQiW7jpri6nHlJ+7xHCeIFp3pUFmVsEgNpI559+pYCK6M0fuw9mkkmlAvhKZR91uGxPQb5tBqOd09xGqdqZgQKlnBDkU2rpCw6hVaidUzY1kQnNRdCtxO82hxZdER3o2WY8Rc1hmrBJ6B+ZnQbD1hm0dLOiuDbshjXbuBZ5VzCEPfU5alwglp67pN9llpDO7YILd/xZFrGrXvKzbo91ceeb811l+5Qb/P7nPxpFMRUDBLJWBFFmzVlWCV6KyrU5wbcWqukkZRfCPKYZiUCFlLZIFcmvO2f9KJdpJ8etTgGtc5p6LDl5SelYmmkVQRnC6FAdjRhXHxOLpRwXINSKJV56Q275UfqAvPGerC84a68IKhLrxoqAsvGerCy4a68IqhLrxqqAuvGerC64a68IahLrxpqAtvGerC24a6sGFpB+rC04a68IyhLjxrqAuf0XCB3RZ4NBdxIEZ0HbVIyFbvxkWn87m86CrovuoB6gpS5mIWAONX9s61jE9X83YdYW/aHd3DU2HqAt0of449xdGBseDjY89jWIkoY+U5+sT0mlloY/NuoG7vJQ+4kQk9h4WG8F2EWgJ/R3mWkEQTQIlRsnAdKgMw6RDSkvmR0u6/T31lCPsUKoXUOq1DGPxS1zFoB0+YnOZ4R+dy35F9YCPAyzEsyS+h77e5O1hj8IwNdMJXHbk+Uvu+aoN+f/WR91tj/dUb9PvO/X4nMs8M+e51+RHonp+dScY5ORbs2HW6tZvIuc6l8B2sTKJ+HXuiI5mh96f2vn7yiXbij1BRa8dnUwFIMHpkRxmkmrR/f5hcUvolj5PBkBi1U9jyHpWIVfOp3Zd2mMY8Z6gxzxtqzAuGGvOioca8ZKgxLxtqzCuGGvOqoca8ZqgxrxtqzBuGGvOmoca8ZagxbxtqzIbxHagxTxtqzDOGGvOsoca801BjPvNE7YkpmBJ8kbpwWSrDp0uBWEqSfwFkSIlpjFOJ/MK6DrPzxDvCAOLM943GrCQZ13X8tQ+J+F4nTxzt9Xyd7mVIS1p610fiQp+7WnWZ3uwRsz0QZGrOonaEgiGOJcWwggAZTyYBxJOJj9QkDehUjFh375oyh8GYjg+K8NC4kA6XRmPmqYwlFOrJDlKJUu1Z5ovPeeL/LMM8kyTnmXA8s2w9fSCQ6C19oiMLaZPzrDQGz9xAc3zNkWstte9rNuj3Tzzyfmusf+IG/b5rfy0LPMLeB5fRaSvJi5QQknbw1VCJzBNBnQ+rMHiQehx7Vl2Z+Qf+pE/p1N7X3Sfa6ftJl9lGLOcw04hCPo5onKLbn1lbVcfZFsRR0aFwHUKDRTn240qIZYG3Z1oeqFfPGerV84Z69YKhXr1oqFcvGerVy4Z69YqhXr1qqFevGerV64Z69YahXr1pqFdvGerV24Z6dV9jHqpXTxvq1TOGevWsoV6901Cv3mWoV5+1P44D/I9x0RkG1Nro5LTq0suZOOP9ENKy8AgRdARAxhWYMrJmx7nTexrr0J6/Onm3MtXXYd0VxZGn/F8iYT+jU4uuRBoKXV/1/qAgDRAz0krdXMKsac8kGVj7UW/ROpcJeIRRJwo6dojJSOzi+bFOmfNTngad4o7y5LkAOnWHdnNPmRsZ43Fxiw59C2GmZD+xpgbvCPU8Hd+RpKYvXCgKI9W68cvKsps9SWGc9RnW+kVj8KwN9MtPOnLdpvb9pA36/ZOPvN8a65+8Qb/v3o8xI9ktEUqGxBJddjcPrFQfRnJov1IYWFfMZmB5jN2yEo/5zegeRwhfl6mtlT/7ZP+JhQuxnWSj3TCJxJV0maFyP9UF1hZROUci+zINxOxKcWToWF6IvzmV2p6/epj2PWeofc8bat8Lhtr3oqH2vWSofS8bat8rhtr3qqH2vWaofa8bat8bhtr3pqH2vWWofW8bat9Grx6ofU8bat8zhtr3rKH2vdNQ+95lqH3vNtS+z24+K/TZs+zyWsaezpAGmZF10b0BayBN6iUaX0uYoT6h5jlS2GdKTP26QHkbVjv0HYuuJ3yS2oZxXCqPOTDczI5xoUapBUDvfE8y0AE1EU3siTtk7BRyo311UphfCMKB+V598DCmgRWP3iYazKOCOnGGiT4qshEtoK7MOLoxA5ubewND5EnWuWoXqWd5I+Ez/3Fl0mVIrBhSEzVT1sbKWkOvLzUzXfnforvV9BnWWkhj8OwNtNBPOXINqPb9lA36/VOPvN8a65+6Qb/vac5PwGRG8nPCfqIsEQYs2UVH0nQZjbZmihG6IJMUt3bats1KJAmPVfty8nhq7+unnOz/OBeddFNJiYTwperQKp2YMCm+07y6sML7FWXXj50uBEuOZUQlhdoK4vSHz9jp6HOGOvq8oY6+YKijLxrq6EuGOvqyoY6+Yqijrxrq6GuGOvq6oY6+Yaijbxrq6FuGOvq2oY5u9gMcqKNPG+roM4Y6+qyhjr7TUEffZaij7zbU0fcY6ujn7I9jXquXmoSXMns6pxuvx8InMh+TrsxcGImlIzLNgbBKxqgO4swC6GOZ2ns8Z9hVLD3pupCwl7XjoXfFaeF4RRylced7FiBBqedJMI/7fmUukb5qbN63IkgsBCzSSvGBZek6P6ALGFpd67GyLonSTltgY1ihZSS5ZUbxs3KjD2ujo8HaS2IuI7mV/kngDMJSPeRYEbpbSMbM3kkBHGBeY8qRx7oQeJLPm5z3qDF4zga66qcduZ5U+37aBv3+6Ufeb431T9+g3/fur+WilEpwCSSqCDnGg+rsB+xthzAK/RiJU2SlcRknCRwkY+mrdiOhJ9bh1N7XTz3RThx17GtGqZHuCPJL6VCH1HUkFnU9mFMiqj1amsKOJ9ORyyOhaw2DDgFrdPSBmvycoSY/b6jJLxhq8ouGmvySoSa/bKjJrxhq8quGmvyaoSa/bqjJbxhq8puGmvyWoSa/bajJm/etDtTkpw01+RlDTX7WUJPfaajJ7zLU5HcbavJ7DDX5vYaa/Ln77WI+rwxuJegtuqVu0tOr4OTIvB6m3Q7lqDBLJCNEOu/IssvCkyGuxNLs66ie4WVSMW+qzvgk8mcoOR+RmbCg7pn+ln4oADhHrCX4slB5qJNbUNPNu25IbxbiROCCt1cmFaF97ZjmpRIIWPVOMxZCR5QJCPQ6xJEgtDidujU19+r6GcbegenJMgRUVj7rjAg9OBRJ6FACzKmiy/8mPm0mkLled+GxLnumyiaaXGPw3A002s84cm2q9v2MDfr9M4+83xrrn7lBv+9r/PUcCcFVO487Er4uvStocj/lfnVzWmc+QxIOsVpWAqULulK39muixjTFU3tf95xoJ4F3oLzEcsS9o+JTqpN0JjqrR7fibWfif6QkRooa5p6MSwggoxFTpXaafcgH6vtzhvr+vKG+v2Co7y8a6vtLhvr+sqG+v2Ko768a6vtrhvr+uqG+v2Go728a6vtbhvr+tqG+b88TPUzfnzbU92cM9f1ZQ31/p6G+v8tQ399tqO/vMdT39xrq+/sM9f3z9tu1hJ552SvPdtryzDRYyB0BYc6kYyTA28x+1LPuOyKgFe32WGsq3i0n7liapr4yNSPrLRcQexojmYxl3XVumHKdXQ068KzPIZLDSZCKgzM0MGTGoX3PsCzZJTI0U6tDc7M01zGhUFjryPwQdQLtxNMrOZKsSWyZ6QtbZGiRL82+bXInOYVMW0tc16zsznh7TwfXIWQmig7dGMkD0wBj78lntKlopNbUF32Gtd7TGDxvA733s45c56p9P2uDfv/sI++3xvpnb9Dv+/fXsrR66WZdeDFF7SEjaLFaRgQdEppQvCAU5qUkZCFZXkefic+vmTJZas+rfc7J/n/h4vmVfyG9FtTCOO/KYbLbPThAN8n3q960cH5G77ouk+qosuky7dCeZXGgVzhn6BXOG3qFC4Ze4aKhV7hk6BUuG3qFK4Ze4aqhV7hm6BWuG3qFG4Ze4aahV7hl6BVuG3qFZu/KgV7htKFXOGPoFc4aeoU7Db3CXYZe4W5Dr3CPoVe419Ar3GfoFe439ArPb+ZEh8aOA/G1pNTx1Pq5z3nSPKS/rJiYHCq9xDQVQhehc3SFxETUBvu79t75dQw8ZQURT/ZklHRYHaKCaKx8zxzSTUa6DAzAz6yGTg6Z0IIu5/c1tQDCsU7PQ7J3NID43ulpVSVZXxitZcTQRDcD8V03oF6YfKQgZi/jE2JTC+i7eZgXHcDsdSbskiPfuFRyvZI1ERnBFBQLJbS8q3XwnY8OsFpqmqo+w1o7agyev4F2/DlHrpnVvp+zQb9/7pH3W2P9czfo9wPNO54TdiETP0lL86jjvCekVU0kKKUXBHLCCPdI8JllmhXJUPtxJZuhWhqv8NNOtJOFE6jojTTQ5xQIzMQDFzKgodTqa8nI67Do5ZeJ3BNKxKm4GBKxgqDd3i12oO84Z+g7zhv6jguGvuOioe+4ZOg7Lhv6jiuGvuOqoe+4Zug7rhv6jhuGvuOmoe+4Zeg7bhv6juYdzwN9x2lD33HG0HecNfQddxr6jrsMfcfdhr7jHkPfca+h77jP0Hfcb+g7HjD0HS9o3snjMaWs0Mm0Wrs48Yx19OCo7QsDVYY0kT/qXAppspdQ6fuAaC9kLlJ84zt40NOgrUe68MTpWGydlT0vBPpVQXkkFhF0cQkpUVUoqH9gKUmSKBVdc6ceWZ8nvCo/ZX5V4umF2juKGQoUoyIqgacbAxpn9r0Tnk0R2cAMxHy079eSAQqShR9g/FhuOZDAp0X38pGFMTbIkllaoqeBNJ5EG0nGhfJJWvpN7tTTGLxgAx36845cf6t9P2+Dfrsj77fG2m3Qb39HowOJF4nQh3YlqKKRBiLW3HlH1CP0jVjtOfTSOH6GIgxk15m/45fl3M2n9r5++ol2euR9DsgvvXPuCcSxrKzjkYSG+kPEkWNXXVpEfEbLjpnlPySS7Srz4KemRnGghzln6GHOG3qYC4Ye5qKhh7lk6GEuG3qYK4Ye5qqhh7lm6GGuG3qYG4Ye5qahh7ll6GFuG3qYZg/SgR7mtKGHOWPoYc4aepg7DT3MXYYe5m5DD3OPoYe519DD3GfoYe439DAPGHoYb+hhwv44srITBQiawA9OxACy66j3hZe+0w5rJi7zZCVuJ+8GZA8YdiS1EWAJa6XdZxWJnzqOj8BaefhMxsRUSERinxRwSZ2JQQwMN7pjCnwWaStmlsXg+qZ20keeAb9v7p0PUhMzqqcjV+qIeOI18aVbEraGx+j0NJk+E6GT0eapNedj+kl6qI+loDZmAlmc3RDXYWUprno8cy49kZ4wx0QNLMh5hjujT+Z+mLZ5j0JjEDbQtPHItbzaFzfod3fk/dZYdxv0OzXxakB89H5GpyCyK/9nDjopKBK/e90Mi4AbZT+Y7d6h5UkCpN95oUaItDy193Xvyf53fBcFT8nHdSprhxLPsjE9fgjFNFOpgUlMs9SzzipyOhAsqDC6YH3G9s6gw/zQOUM/dN7QD10w9EMXDf3QJUM/dNnQD10x9ENXDf3QNUM/dN3QD90w9EM3Df3QLUM/dNvQDzX7rA70Q6cN/dAZQz901tAP3Wnoh+4y9EN3G/qhewz90L2Gfug+Qz90v6EfesDQD3lDP5QM/VDf7D+hXENiWTxrJpNLcUEYCnQU4oLoLlOEAuKXTV1PjiMWMC0SY0gG9LHZS0buzL1OiiJUh25xWWebMkspCpXKDM7kA+YnkiWRkgoEmoaW0a+IggGR1vghPqMiwZiSo24D6HlY44QmqExU1YsSuZixZnVhbOouLZJBiQMoGfh144cQJCxWxb9Br7YHnRjZJzRIv3RkJH6SX4YSC8gvwnJlGU6oKyY4jy5sspdMY9BvoI+HI/cFat+wQb/HI++3xnrcoN/Tfr9JmkMP01AsDivxm3jcASlIDd1CEkePpllXZAA0CJ79qG9YkRDOASWas56ee6KdBL1IgOgo0taMBel1WVw/oyV7kmWSblpX5A4hedQLYIPe4JqQTRR3SS6l2Ut2oLc6Z+itzht6qwuG3uqiobe6ZOitLht6qyuG3uqqobe6Zuitrht6qxuG3uqmobe6Zeitbht6q6amc6C3Om3orc4Yequzht7qTkNvdZeht7rb0FvdY+it7jX0VvcZeqv7Db3VA4beyht6q2TorSZDb/XCRo8FKkrdNK/0shJ7ybM4D+RCRgHVOjKaiUXAusHbCEszmCMZOmhrXWzP0WV+Tqya0rmVUc4jySjST5WZWJikXLcb30rW1f9zddI2trSwZGsoXXOO7tBnaZisxErUz7roDROF3Mk85mldafKok3qJ5HGhWhYCtSZWscpgofFWJEHW6aKBSf0u/kSd7zXkeSVusjDVyUo+GZBPepGHB4K1DIiVkqeye3/BWmtrDF64gdb++UfuMdS+n79Bv3/BkfdbY/0LNuj3g/v9xoywLsnRSKJVq3ZehoiDYF6zkEhjUWmjr4GcH1FI1aFz8DVIHX5f857OzzjRTq8TesmCRMMwEo6gFNq0Os+TxyelaUVrDlMPtkD2x8mHiSSLdUBVkXPW5i62Q33aOUOfdt7Qp10w9GkXDX3aJUOfdtnQp10x9GlXDX3aNUOfdt3Qp90w9Gk3DX3aLUOfdtvQpzXe6kCfdtrQp50x9GlnDX3anYY+7S5Dn3a3oU+7x9Cn3Wvo0+4z9Gn3G/q0Bwx9mjf0acnQp02GPu1BQ5/2okbTMnspKk2k7Yl8UcNYNLAdXq1z4xIpYA1kcILsXApDiDVaFpZop/uq49LUwIa8zB1BLbuhFFQTIXoM9JJnHMh3PXG+G/o66d4SxF1KDAaFLnIW2aaGH27v+ovBj2Eggy19VhhW6IkKQgSEjlmCXSRk8Hj6JTL/KXPRkW5BLeb2zmyU4IDxor5FrGO1LkQHFm9eqeoNdYmsEzQS6mUZCgmGMhvrnClDQqkaXn2GtW7XGLxoA93+vx25X1H7/rcN+v3/OvJ+79bcBv1+qMnTuhub/I2qLIlFi6/xRTaB3LOOmXATZjIvwZO4SIaj7sVi8lKfhK/Gp/3ME+2khMy3e6rhujsFhUjSGkV4KKINyziG0UfiBsluJGAQfYE4FU1G1h3wI819J4d6vnOGnu+8oee7YOj5Lhp6vkuGnu+yoee7Yuj5rhp6vmuGnu+6oee7Yej5bhp6vluGnu+2oedr9gQe6PlOG3q+M4ae76yh57vT0PPdZej57jb0fPcYer57DT3ffYae735Dz/eAoefzhp4vGXq+ydDzPWjo+R4y9Hwv3u9jT1wn1Q9UvIY4OPpXmAw1IhEXCmMZ4TPpCsw5jizrkaDUZ/zSuIy7W9ubsyyCBFeXR+dYPqMfiBnU+sgRScqAGRQI/mS6PulIDB4UM4gxZlmxWsvQeL5xDv2KyHDIikqeJTpFJlJVTJuiL5hTppo+LXlPWpK4op8jqwCt0pxl4co0ZaIdK6XP5JyVMDCtVOEoYNCyuMhArotTQld8yIm64lg7Jh2L2G+y71Fj8OINPMD/fuTeR+373zfo9/9x5P3WWP8fG/T74f2YvPZuJkdXVI9H8/q4RCCIL6gs2Iqj/o5ampVHQsSk6ZBtB+Ih4uiaK3dq7+u+k/2nDQQ7tD/iDadG4CeN9yOuI6xYDDTQQpuSTrDRPuohOP484tjwgayupjZ3oH88Z+gfzxv6xwuG/vGioX+8ZOgfLxv6xyuG/vGqoX+8Zugfrxv6xxuG/vGmoX+8Zegfbxv6x/a87cP842lD/3jG0D+eNfSPdxr6x7sM/ePdhv7xHkP/eK+hf7zP0D/eb+gfHzD0j97QPyZD/zgZ+scHDf3jQ4b+8WFD//iS/XZNxEEaUvNE4p8WfpioviaXWceMlP6MR0WFgQhLDi9YTEYcKUYpcMntGewE+8SSnSTmlkiM9oTNnpocy9wvuc/kr7jM5CbmBGt/8QQfwvOslofS+EeHThtRuZQNe52FyP+m3O1EZKJ1WE9d1cqco97pQ40E5h5FxApCQA9TUzPspKTIE2v0CECkoQt+7ofK9OyJBb06NSceaKLSuRIYRwIRkwPJQdRf9BnWfkJj8JIN/MT/eeQ+Su37Pzfo9/915P3WWP9fG/T7keYd2KKTeZAQqBvc2yD3g/4YUeNIZFLaMmMcWMCsb2zeVFidsw5BpZLIv07tfT3vRDvxpj1KWecm1kA2wgYBnMjLgwfF+JJ08g7BzA8Zi1L5XV1GjaEFcBZlbM9gP9CLnjP0oucNvegFQy960dCLXjL0opcNvegVQy961dCLXjP0otcNvegNQy9609CL3jL0orcNvWhzBvuBXvS0oRc9Y+hFzxp60TsNvehdhl70bkMveo+hF73X0IveZ+hF7zf0og8YelFv6EWToRedDL3og4Ze9CFDL/qwoRd9xNCLvnS/XTrTPrAE8aR+pWDJcFbqHisSgB+OrCAqh4nsy5yhksnyrYxih+CYc5xKey6/JxT6oaAX6EQkj7CCk8qZCI2e9T6uXreYDqxc4oMjUVJjCSvmcB2ntfGimRCH7fRV0WlelcBD71OWnWTZ03PfaUp0DElY5qSIRJguTJ2VtrV3B08rgVcn1YQ6j93MgHeFns1VbxeuZJ+FD+9Rjh6b7fHQNdCVBadKrNpk/6rG4KUbeJNfeOSeTO37hRv0+xcdeb811r9og34/ut/vDnVIPu1XcgC2biT0kuzJxw7DAWsa8YoyGSvLPSomeyTeQLlzpX4/9qf2vn7Wyf6T/kc3rUUl/jwSqdHJvRvR8yxs2us8QmkKgd/VkzpxXX1O6FmFEGJKU8s80NeeM/S15w197QVDX3vR0NdeMvS1lw197RVDX3vV0NdeM/S11w197Q1DX3vT0NfeMvS1tw19bfue4WG+9rShrz1j6GvPGvraOw197V2GvvZuQ197j6GvvdfQ195n6GvvN/S1Dxj6Wm/oa5Ohr50Mfe2Dhr72IUNf+7Chr33E0Nc+auhrX7bfroBUyrnzDhGUeldGzKOKLompvk5dv5DNiMZqFhMk9+gybHDnJCGJu+1dDW7sGTZWPsMSUQGhIB9W3Gy/oisYFoJEJQFjIFmjgUW+OxuVxE54bM4m9V+4VpvOMBk75JM+mIAxFeTkrDvvSOOjH/hwZPUQEoF2YE3HoEeytO9l9jkEt4yBWDqSDiq9jbudi8TaNOgm7mEpC/JtCZlAOMdlmTpPvZVJP2+zR1dj8LINfM4vPnJ/p/b94g36/UuOvN8a61+yQb8f2+83mQ8JlSJadkosXWJ8z/Tu/BADGQ01QqrAEVFP7UFKaNJA0HLonDIDl07tff3sE+0MyG2URHKsPX4CE0V7sAwkuTER0jzZq9NFlACygcSD6JVRpaGSfX17NumBHvmcoUc+b+iRLxh65IuGHvmSoUe+bOiRrxh65KuGHvmaoUe+buiRbxh65JuGHvmWoUe+beiRmxrrgR75tKFHPmPokc8aeuQ7DT3yXYYe+W5Dj3yPoUe+19Aj32foke839MgPGHpkb+iRk6FHngw98oOGHvkhQ4/8sKFHfsTQIz9q6JEfM/TIL2/WNgFHW34rS8eHBR0y4oEz0rWQmYvyDf+L7C6ZLjhaXxHcE3OtsMJ8U/tlNjulwCFNaSe7cqXcxCyd80TPiP0IqQXnuZBCEM6TDqHNjDNpbexcc3/HQAZkYZE+Zp6Uk+QvE4I8owWq3lr1NU7wJGwx44Zfx1MnVoqOxuVxNvd3zJS2Ek87Dnp3thIRs+7yGPjjQIGMvISJz6iO4HQJo9ZH6jKhK49gglGfYe2ZNAYv38Az/dIj94pq3y/doN+/7Mj7rbH+ZRv0+/Gm33NGOOFp8Mpe0pKAgo5DNww6MzmufpVlXgimHTKROZ+0BT8R+VlA3am9r/tPtNNjW/HEQdswMN1zqazteSIvT7oWMSX0D7KHgMhvp/yMIVmnaZdR5ClcU/s90G+fM/Tb5w399gVDv33R0G9fMvTblw399hVDv33V0G9fM/Tb1w399g1Dv33T0G/fMvTbtw39dnsn+2F++7Sh3z5j6LfPGvrtOw399l2GfvtuQ799j6HfvtfQb99n6LfvN/TbDxj6bW/ot5Oh354M/faDhn77IUO//bCh337E0G8/aui3HzP0248b+u1XNHUsieco4TgHCs2B6vGyMhv15i/GlViE6ET7MgerRpeh8I4iMwKLGm5u/HbXp4VH3fml6+a1HxfseiZokP47ujIRdElAcSBeMTfUdk+8CJJnI4O/77cl2yOKm5lOQi2e1RxBASOPqQwpdRMZLlAgJxkOVKoHKRe0Syelj7Rq/TaKjUdNBCPi+UmNqpFqNl2dM9JtnmVFppnRTEx6JKaPjGsIac5Mw90eVGv/pTF4xQb+65cfue9U+375Bv3+2iPvt8b6azfo9xNNrpg7lB5xGJVA8CanTSM50uM8qw7FZmGEHm7Wx7QShFlKxRXtQgly4eOpva/nn+w/aWrV2vVl7NDO5EZA2tD7JTqlNqn0OMK+QFl0weEAh6ibZxeiNv60OSv4QO9+ztC7nzf07hcMvftFQ+9+ydC7Xzb07lcMvftVQ+9+zdC7Xzf07jcMvftNQ+9+y9C73zb07j/hDjvvftrQu58x9O5nDb37nYbe/S5D7363oXe/x9C732vo3e8z9O73G3r3Bwy9uzf07snQu0+G3v1BQ+/+kKF3f9jQuz9i6N0fNfTujxl698cNvfsTht79lft9XJForg89qU1Lj7gvk85kZbZG/pgl1iUyLFoLTx75+5kVRTJfU5z6obnnR6owEQ+6lUCaMAVdrgh8WtCjy51OefaTGoSaDXHsgo4QmkcmxqAfaWrlEwsULRQjARSF4uoU8AFpkqBjYOI4yCk4NDRzs4+Emo5fvSLZCU85NfvJmfYz4rgL2A+kDWGF7yyTTjPygSTCollD8KxifTCrHmFLQECk6JjrQZ9h7eU0Bq/cwMt93ZF7WLXv6zbo96848n5rrH/FBv1+cj/GkPBR/NLaJB/kILqv4t08JhbXPvbzTLyvoZZOVpdSeiTjrmWYs1Zpc8/PzznZfxSpKxP5LupaZJRpz7okLeOGCbVkNB0ETxJKhczolsp/4GtYyyUTN5pa+aEc4JwhBzhvyAEuGHKAi4Yc4JIhB7hsyAGuGHKAq4Yc4JohB7huyAFuGHKAm4Yc4JYhB7htyAEa734gBzhtyAHOGHKAs4Yc4E5DDnCXIQe425AD3GPIAe415AD3GXKA+w05wAOGHMAbcoBkyAEmQw7woCEHeMiQAzxsyAEeMeQAjxpygMcMOcDjhhzgCUMO8KQhB3jV/jiS4nnknpg69Sxy2u/nYShpVcQIve5d8qrI0yeMOZ2roSuJnMzY+7k275UPSDiq/7q3iZq9hEVCVAdUAWlep5Wh8DwuQuK9TkiViVSHHCBBEjRSU8MPZZkq8ZiAy4rRJuB+ypT/EV4jk53B6nQTcJJKRzzXPpAcptJXVFAfx+a8NF9ZPsxPvnoE5OAdAQJdw69YELEoKNoHEQg+DKN2BxBVkCrkpkgknvUZ1r5QY/CqDXzhrzxyP6z2/coN+v31R95vjfXXb9DvvB9jkO7ExljGJQZth+97UhchCtdRtVE+dwTtKZOsVzQevI8KfiW51QBkS83dTz/3RDs9ThzJrt0wQ1mweoF4QTybWDMLiX7I8zLhSSELSVf7IRcQ1nj3XPoZh9u+V34YUzhnyBTOGzKFC4ZM4aIhU7hkyBQuGzKFK4ZM4aohU7hmyBSuGzKFG4ZM4aYhU7hlyBRuGzKF5r3yA5nCaUOmcMaQKZw1ZAp3GjKFuwyZwt2GTOEeQ6ZwryFTuM+QKdxvyBQeMGQK3pApJEOmMBkyhQcNmcJDhkzhYUOm8IghU3jUkCk8ZsgUHjdkCk8YMoUnDZlCNmQKc9NHbavPI2NEX1n5iPlhJuug5/KSEUCjIyitOqaZKZx1qFvNisJMQuJL816AyxF5x3/w8KtUQGVcicGKZV44gPBelVZpBCsL086kg1x4bAOD25xVFyLJvOgJMeD86KidzCjniP/xxIFlkM/wxNSw8hwQOil3qLHAzCcoNHsLiOSIEgZrlMdC9LoUSPnM/4rgmRPCB32n/RUM8Lh2fUQuMWX1qgBDq8+w9pgag3kDj7kcubdW+5YN+l2OvN8a67JBv2vzjs+UIgaczOSQ/JrloMFMcGVqI3dYPVOalVhxy9MuT8+dS5mEzs+0Z7A/cKKdARcnYrcouvJ5ZP5AU1nkY1jFB2vGI8UJTdbruEey4jIGzPmiGxBSc1bdoXzinCGfOG/IJy4Y8omLhnzikiGfuGzIJ64Y8omrhnzimiGfuG7IJ24Y8ombhnziliGfuG3IJ5r38A/kE6cN+cQZQz5x1pBP3GnIJ+4y5BN3G/KJewz5xL2GfOI+Qz5xvyGfeMCQT3hDPpEM+cRkyCceNOQTDxnyiYcN+cQjhnziUUM+8Zghn3jckE88YcgnnjTkE9mQT1RDPrHutwsrsDhd2lZIDYMja9cOlTar/ayTOg2zzqvPIzEeRU2w7kkRS6L/mSTZvPtQMvFgHSeP2vOO/NYpzU04hpE40a08gBIJ/RlFxRAxRzS760S6IVW1d8S5gWirI/2J7mTX3E+R2DjqFjgEm1tH4kjAA616ocHzXAm/TiEIkTj7dGLPQ+IZEVGSLmMfQgmkVyLhrDXO7JpxLRPaBGXlVmwCMQ5BEXjso/KLPsPar2oM1g386q86cp+u9v2qDfr9q4+83xrrX71Bv1+9H5Mn8jZKBg89TKlIX3aO3EieH/hUwnRPwCJ/k2QJWYgpV1lkTieADKzZU3tfLzjRzkBimcgxrJGKggwoktL5TLSVeMVGYYZxJXkhxhK/Z9qNideBmyxc3+fmnMADWcc5Q9Zx3pB1XDBkHRcNWcclQ9Zx2ZB1XDFkHVcNWcc1Q9Zx3ZB13DBkHTcNWcctQ9Zx25B1NO8+HMg6ThuyjjOGrOOsIeu405B13GXIOu42ZB33GLKOew1Zx32GrON+Q9bxgCHr8IasIxmyjsmQdTxoyDoeMmQdDxuyjkcMWcejhqzjMUPW8bgh63jCkHU8acg6siHrqIas49WGrOMbmtyB3+nL2KdeG8NxPIVs4msnkddNCQ1CjkADaafD6mfiCGFIxyEy6nTnxJ0IYwirI7xX1i0qgKHLceT/6Q2OGR+EqCsLUZpx5InPElIsobCgX7JvznlYCL8IqrEiVEdcCA+5xyfAJVjUJej2M/QSooeMnZHqiVA2srrxHv3Qd81eDJ4trge9GsnIfJJeamdChEzUCp3uBE98DIZq6IPHHxRdEcEgjY742u/uU7P2vhqDb9jA+/6aI/f8at+v2aDfv/bI+62x/rUb9Ps1+/3u/Ej4j0TTVbuPuswCDnjpDue5+FBD3xX+qiMVLnHFFIEhJ2VYpDgJ5dTe18/7Me10SHFiaESLCkPGDtmQCvKkIzehIEhB+PEMBkCJYBgQFkXXlBASs2ve7ziUm5wz5CbnDbnJBUNuctGQm1wy5CaXDbnJFUNuctWQm1wz5CbXDbnJDUNuctOQm9wy5Ca3DblJsxfjQG5y2pCbnDHkJmcNucmdhtzkLkNucrchN7nHkJvca8hN7jPkJvcbcpMHDLmJN+QmyZCbTIbc5EFDbvKQITd52JCbPGLITR415CaPGXKTxw25yROG3ORJQ26SDblJNeQmrzbkJq8x5Cbf2Mwv8hwyp9MJlCQbcmkCkRD9GGA6FJi7qVPe6Uuf87QuDDnSdqHVAVHZ7BGR6syBiOnIf0zB7BzLd8AjMHNHrzMyiTYEXnU76jpH7BhmAiIzdHNzLoZHraCYQ+kSwR7a4siGo97tR2pOyF5JtxFdk/0w+b7CO1ayGQmGoMasbfaIREadeOgcUi6RwviUvqSFynhm7Oiwd6vMVKJhfT8yKhkBtujk0Ihg02dY+2iNwTdu4KN/3ZHzA7Xv123Q719/5P3WWP/6Dfr92v0Y06FmcVGdVHcnXkmohRIGva+Co9LRN7lDEbMGB3ITHJTAuxBPEcAs8VN7X+7H9B/RyNoOdRyQIMThUcflLCvLFLZIXsIqF70Et6Av8cCDXjnLhH1cVK3rPjc5lMGcM2Qw5w0ZzAVDBnPRkMFcMmQwlw0ZzBVDBnPVkMFcM2Qw1w0ZzA1DBnPTkMHcMmQwtw0ZTMNNDmQwpw0ZzBlDBnPWkMHcachg7jJkMHcbMph7DBnMvYYM5j5DBnO/IYNp75I8jME077AcyGAabnIgg2n2iBzIYJp3WA5kMM07LAcymOZ8zAMZTPMOy4EMpuEmBzKY5nzMAxlM8w7LgQym4SYHMph9bnIog2n2iBzIYJo9IgcymH1uciiDec0ddgxm32sd6tt+QzMn9KAzdow1KBGhYz8K9gCT0hEXkyJ8RoWh4eJYEhGQJjulIDRCnRsGkwoamxDBrKk03dF2iVyHrZpRMyhLkizrWTQEM4f7I3qiWRGUoYTYvqcjMTfNKwiInLHMZOSElRr57YiujvGXgenQLWlaVtQC8x9bseAExHkaBhMQCIXAMCW0H9+MOikYFxT9zIeSjnop+8rcIbPMeCLWtevRTax4Zrg+w9qTawz0H2tP/hvvOG4Wofb9xg36/ZuOvN8a69+0Qb9fd0fj1Xe38JBik8dMEaogm+RZwvmcSzcIImDKdNwwDhTmQZKou5BaMA/N/aL+ZP+R8/hLFhGKXAeeOhbnkMU5kAKknIXcSJIggPcIKTpB2O6QGEhtlEdtziY9kOecM+Q55w15zgVDnnPRkOdcMuQ5lw15zhVDnnPVkOdcM+Q51w15zg1DnnPTkOfcMuQ5tw15TvOezoE8p2EwB/KcZu/KgTyneU/nQJ7TnCNyIM9pzhE5kOc0DOZAnnPPHXY8p9m7ciDPafauHMhz2nNEDuM5zf2iB/Icb8hzkiHPmQx5zoOGPOchQ57zsCHPecSQ5zxqyHMeM+Q5jxvynCcMec6ThjwnG/KcashzXm3Ic15jyHNea8hzXmfIc37z/jgOJCLCJh+SWf6hX3q9goRjQBp6aAorHhG00rhcZ1ewAgntU4OMF1KnvWsGNZTxV6Qznj2TdAodkRAPgSDsmAaO50PapHeo1cQvIMcidNCdq59bngN3oS/MJtQtopm1EvV2hV5tcn5dpaDxigiANBDJ+T+IHNf1USe4zLE0PIcxnpk9TNGhG9ZBYoJ4h+somvU8ySEOfUEKLgzNjOViUHrUFJ850WV9hrW/1xj85g38/W85cq6h9v2WDfr9W4+83xrr37pBv1+/H2MC2sFVTBhp1JOyd6e/ypkoVQUmPgltkYBHMjhWYIermXM/gUExvs2ds+Fk/2llGMYs9Yc+wlvhtSCpFZOILkFEI6wzPUBlZEJInMgOfPAqIQzgbXjOgWzonCEbOm/Ihi4YsqGLhmzokiEbumzIhq4YsqGrhmzomiEbum7Ihm4YsqGbhmzoliEbum3Ihpq7Zg5kQ6cN2dAZQzZ01pAN3WnIhu4yZEN3G7KhewzZ0L2GbOg+QzZ0vyEbesCQDXlDNpQM2dBkyIYeNGRDDxmyoYcN2dAjhmzoUUM29JghG3rckA09YciGnjRkQ9mQDVVDNvRqQzb0GkM29FpDNvQ6Qzb0ekM29NuacWQVRhQdz6MScr30d8/EzT0KYxjSiFHDkASn7ImvwGA6nmZP4sLytO9bBTcNpIBxVMDEKPSRBRWR8DWuKBJSLHOXzML/c4TDogzeI2KGnDFRzTk1WMdhxsTxc1NKaSBxL0NPHNM2IWEiJMjIwDBwRL4wdy7neR5wvrtQ2N4ZpGyqkWM9y5LSKiLU4DsfmEnEbbcqh6zKsVluiLYjMYgtBBIesj7DmhVoDH7bBqzgtx85I1H7fvsG/f4dR95vjfXv2KDfb9hfywElElGgyDfcJykB+Y5bQQKiEDPOICt5sD7mGsYyINNdIS2ho3Bu/XJq7yue7H+H3tuZqBnjC6WdJp9lO0nlyLeOYMbfkDRQFyyljgC9EsfQkcACV2PDhg7kTOcMOdN5Q850wZAzXTTkTJcMOdNlQ850xZAzXTXkTNcMOdN1Q850w5Az3TTkTLcMOdNtQ87UvG91IGc6bciZzhhyprOGnOlOQ850lyFnutuQM91jyJnuNeRM9xlypvsNOdMDhpzJG3KmZMiZJkPO9KAhZ3rIkDM9bMiZHjHkTI8acqbHDDnT44ac6QlDzvSkIWfKhpypGnKmVxtyptcYcqbXGnKm1xlyptcbcqY3GHKm39msx6VbiK3ryMpEjyxMiUrYQYyXgpzGSLBWwySVGeVsmPV8H54yDeja3HCmbgx5Qb5hasdCeCqKQkUEi/EsKRIXSIcyGlEnLvcL8xoB1U0zY1mGfc7kQD6hn7C2POGpSys9mliFRPvSMRdG1ObslL3onGfRYBuxtNoiFaTxGs7kS1D+W2FQ0p8SaPSOfI/OGQp0LMseM0QVzY4XgKchIgtWBL3dJ32GNXfQGPzODbjD7zpy3qL2/a4N+v27j7zfGuvfvUG/37i/lsl3fHPpcNckMGSVQ0kovrlhXmKp2gyoJE6oGwakQ5fxU1gZLKnvW87UnWhnCDI5sN2CQ8N5DC7qDHJ8bKAx0ZOQ9DppN8A7iNd+xIJ3aLMOuZFIcS1nOoxZnTNkVucNmdUFQ2Z10ZBZXTJkVpcNmdUVQ2Z11ZBZXTNkVtcNmdUNQ2Z105BZ3TJkVrcNmVWzB+lAZnXakFmdMWRWZw2Z1Z2GzOouQ2Z1tyGzuseQWd1ryKzuM2RW9xsyqwcMmZU3ZFbJkFlNhszqQUNm9ZAhs3rYkFk9YsisHjVkVo8ZMqvHDZnVE4bM6klDZpUNmVU1ZFavNmRWrzFkVq81ZFavM2RWrzdkVm8wZFZvNGRWv6eJhYgcGkxemSaefo4s/8oimuPKsp97l5AQc9BLcCQPlCBulyW6MFkzT7C5wyspPDDLCfcYnMQEh/r0rA9HcBlRxLkOvd7XGVPVZE/zPOOdHPrXk2kaZrVM5P3Eg0WIDYO0DHIwzZlHW/rSM29ZQySmftAqX0cS5zwhYEMmyE3jPrPyC20lGCMKWTJE8m6ZwXA9Tz1jlxENDvpWVs1z8n8hduDayDHI1h5bp8+wZhgag9+zAcP4vUfObtS+37tBv3/fkfdbY/37Nuj3m/ZjTEkVyVCZ2gl9kZ2oUupwoGjoRGZY0O4BFjuBalddY+70ummanTYwpi8eP737SifaycJGdHRobiVRHGCKkwBVX0aJACgOKw8IhKPok3zOpGRHYtI59iC05g6vA/nXOUP+dd6Qf10w5F8XDfnXJUP+ddmQf10x5F9XDfnXNUP+dd2Qf90w5F83DfnXLUP+dduQfzXnIB3Iv04b8q8zhvzrrCH/utOQf91lyL/uNuRf9xjyr3sN+dd9hvzrfkP+9YAh//KG/CsZ8q/JkH89aMi/HjLkXw8b8q9HDPnXo4b86zFD/vW4If96wpB/PWnIv7Ih/6qG/OvVhvzrNYb867WG/Ot1hvzr9Yb86w2G/OuNhvzrTYb86/fvt0t5UFuy+h414iM+QPMqrJ7ZTqjOXYGAYUOlUDANHTO/Io2QOCiP2vKvjilOFu4XDBkwjCQmGOUzE5/4gzcnXSCmcdyITAQE0dat6CoSoFJfw78Ixyv6YMgZ8ZRZOUvqvGMND/z34HiMiQasulSK6Yo/RekQefjOITKQ7TngPKsUw0LIdSXhq2YiWcZ18GAGloMOwOIhjAjdhLkZCatUmLBWc2Q97s5HtuYhGoPfvwEP+QNHzoHUvj+wQb//4JH3W2P9Bzfo95ubnK+NhgVCA2VgGSPkgbwD6WzEXOjFXLBNrmtOCEbk64QYWIZ5Lo41BRM+tffVn2gnvzRIfbDSkBy1Q367zhPJCNIzsWIW/9JGSJkt8hH6LYz4Ef58kfpu+NeBLO2cIUs7b8jSLhiytIuGLO2SIUu7bMjSrhiytKuGLO2aIUu7bsjSbhiytJuGLO2WIUu7bcjSmj1bB7K004Ys7YwhSztryNLuNGRpdxmytLsNWdo9hiztXkOWdp8hS7vfkKU9YMjSvCFLS4YsbTJkaQ8asrSHDFnaw4Ys7RFDlvaoIUt7zJClPW7I0p4wZGlPGrK0bMjSqiFLe7UhS3uNIUt7rSFLe50hS3u9IUt7gyFLe6MhS3uTIUt7syFL+0P7fURrk//pTkbsdJ24VYVVBdQvTmFxCXPDPA7qU5d5/M4tTCRywKo50e4li8ynDMtCCQS0XmaRD16nL+r8HzI+T35aAGTrgGiBe5VALqik0UmHZO2zNLTvMrJecMN8SO0R967n2wtZcyJAMiCk0LkExA2Cm08Ci6Hak9ch8rU9Z6sWBH7CSmQFGRrjZleYsMkTuMfCAouERZHDyOCi+hF/89AjT3DqYXe9mDVb0Rj8oQ3Yyh8+cqak9v3hDfr9R4683xrrP7JBv79pP8bI2QUMAgZiGqaJfIFpJ82jn9GA/aqljoNEhICcZGR1LB0kamJlFNfsJRtOtBOZtUzS9Lgnwa0aKzACVVo6pAFeuOLTK9RlIMmwhCZYXlBGIwOSl/0+SzuUy50z5HLnDbncBUMud9GQy10y5HKXDbncFUMud9WQy10z5HLXDbncDUMud9OQy90y5HK3Dblcs5fsQC532pDLnTHkcmcNudydhlzuLkMud7chl7vHkMvda8jl7jPkcvcbcrkHDLmcN+RyyZDLTYZc7kFDLveQIZd72JDLPWLI5R415HKPGXK5xw253BOGXO5JQy6XDblcNeRyrzbkcq8x5HKvNeRyrzPkcq835HJvMORybzTkcm8y5HJvNuRy32TI5f7ofruKG/h2uuexbKJTOgFsUVwmMaOQmC0++94hNREZPIeF+eDBdUrxob0bcZ4zcoEHgaKlJeQWz3InoPG4iFs1z27UWsIYoFo6vaHJjJ3wUEiobmr2uOFZQiEU8WuQTiJnlWjcE01KGXmCkuW4hIwsx4PjWyKxssxk0VTwWc07nngyLAaZeep01BnTkSlLnF5yYfgZeeROcayHWgEbuEZWFL9hqXhFnqs+w5rTaAz+6Aac5o8dOZ9S+/7YBv3+40feb431H9+g39/c5AqSCFwjS8wusvp1Sn7GIPYz0mQShOiIyCyWKcI+sjZ/AguE0xBJ/tTe13iinTuWtjtakJxTJCY70LtM7ITFIJtNonsEjn6FC864g95j2gYPTkPnpGaP24GM75wh4ztvyPguGDK+i4aM75Ih47tsyPiuGDK+q4aM75oh47tuyPhuGDK+m4aM75Yh47ttyPiaPW4HMr7ThozvjCHjO2vI+O40ZHx3GTK+uw0Z3z2GjO9eQ8Z3nyHju9+Q8T1gyPi8IeNLhoxvMmR8DxoyvocMGd/DhozvEUPG96gh43vMkPE9bsj4njBkfE8aMr5syPiqIeN7tSHje40h43utIeN7nSHje70h43uDIeN7oyHje5Mh43uzIeP7JkPG982GjO9P7I8j3I6kUDq9yTokhrXWAUg2Kp10uNiZnM5oQP060gxzhczsF1YpwiOtU7P3jvjoZjIgLSEf4bWJ7Dyi2aNTBxwZSZjlOqU0ggHxAOhEfA/KHJJIJmjuuGTFTBmZA48D6Tk0B4Fdwp4koDXldXEB+mIX1FgQ6Fl+WXHQjEDsbPbezURt1EHCyI10EK6x4v+J/vj8rpNn5GEtaFcxkZik9PUQeagrVDDrM6yZj8bgT2zAfP7kkbMute9PbtDvP3Xk/dZY/6kN+v0tjf8Bl2VxowDTHshjwc98bkk4WEnJZQLuoGQyZgGFqqPdyGqYKzx2N34R6+2+phPthLdHMipmrItx1PGHTlkjTLsrPBwtIkoir/G0pHgWO4ufyLkKOuLNpx+z9+4AXnjOkBeeN+SFFwx54UVDXnjJkBdeNuSFVwx54VVDXnjNkBdeN+SFNwx54U1DXnjLkBfeNuSFzR2XB/LC04a88IwhLzxryAvvNOSFdxnywrsNeeE9hrzwXkNeeJ8hL7zfkBc+YMgLvSEvTIa8cDLkhQ8a8sKHDHnhw4a88BFDXvioIS98zJAXPm7IC58w5IVPGvLCbMgLqyEvfLUhL3yNIS98rSEvfJ0hL3y9IS98gyEvfKMhL3yTIS98syEv/CZDXvjNhrzwWwx54Z/e7yOGrqsoNZ9ZuD4SoEvqq+57mFZU6zKTicEDyLmdcs/S5gGCiOtkbgwNLySmIF9GnijBGuNediaPpZVBFNhamgvFqAUfPoZIkCM6E8xzGpkUXWz2BE6rUgxrsKKO6QHMsC+r7kFFPCNbscK712kH1iNGOkoZEulQrr1Se8ML5fhAgZj9DoIyL9oFKS8TUUUBFVsYZieNj79fMEHYpSEW5BWTib/WZ1jzI43Bn96AH/2ZI+dmat+f2aDff/bI+62x/rMb9PtbG/8Dna8ksZmwTETOzlEIwEETU6uU4FwV0Sq5gwWHcE4EpR4Qgesgf9RTe18vPNHOMHVuyuI3JOYFG+XSLsGufS0YgqAdxZ5fIIamvYYzDgDWQQp1JPHg2j2Bh7HHc4bs8bwhe7xgyB4vGrLHS4bs8bIhe7xiyB6vGrLHa4bs8bohe7xhyB5vGrLHW4bs8bYhe2ze1T2QPZ42ZI9nDNnjWUP2eKche7zLkD3ebcge7zFkj/cassf7DNnj/Ybs8QFD9ugN2WMyZI+TIXt80JA9PmTIHh82ZI+PGLLHRw3Z42OG7PFxQ/b4hCF7fNKQPWZD9lgN2eOrDdnjawzZ42sN2ePrDNnj6w3Z4xsM2eMbDdnjmwzZ45sN2eM3GbLHbzZkj99iyB6/1ZA9vmW/XSsutF/0Li4DPo48O4VXfCeD6eRCI5mIdY1D0gvCeIs+eWR851iOq2vYo75pliKhgyOadx5rh3Ct9KIbVRxhRMYyARIwpgVJgAyNTGQsAG6nNuwR249aqrNogkMdE0BhG7prw7t5xhRhjEnqaEJMh9SHBiDqxoGid4mb95FJ9rgwBp4f0UvOON+RFI4ZGuJKHKNTXd4NJbmjEHignQuekNBKmJ71GdYsSmPwlg1Y1LcdOYNT+75tg35/+5H3W2P97Rv0+zv213LdMRByDfFdyjqURcISM0vYYj1XNMAM3osC6ySUkPkWOIDeXMYDndr7+vkn+5970X9cDOt20kGasRtQBGkuI3YDa4350xJyxC0MkysZoLjqv8X61oY9HsgxzxlyzPOGHPOCIce8aMgxLxlyzMuGHPOKIce8asgxrxlyzOuGHPOGIce8acgxbxlyzNuGHLM9J/AwjnnakGOeMeSYZw055p2GHPMuQ455tyHHvMeQY95ryDHvM+SY9xtyzAcMOaY35JjJkGNOhhzzQUOO+ZAhx3zYkGM+YsgxHzXkmI8ZcszHDTnmE4Yc80lDjpkNOWY15JivNuSYrzHkmK815JivM+SYrzfkmG8w5JhvNOSYbzLkmG825JjfZMgxv9mQY36LIcf8VkOO+R2GHPOt+31ceRqoMvgfcbojmoAAPIsJXb4UMB4GwMEhGEU8g5QxfznGQCzAYKzt3cFlGRxKlW9ggIY591ky1Xvi1KpzFAnGTi9ye4IVMTLN5NwAF6HnY9e55r6TWMaMFyWeFBbdinPp/DjKSvEfUg1xUblgVSpYVsCK5AIySoIDPdBwTIIwYTDInvjQsYr6TGcgDQhoBBOBBuNIQGRyRJQ5PqsScivxEpkzbbKHUmPw1g241p87cp6n9v25Dfr954+83xrrP79Bv7+z9YsqOxQc74QcJDdD+onxvSa8A1yijXSY6QTxmyP0B9OCWVuRe9giv57a+/oFJ9rpSa+kwArFWACHI1IUCQPgYy0SEcVfFpc8sh0zQnYiNCLYRDCBTxCCfY55KBM9Z8hEzxsy0QuGTPSiIRO9ZMhELxsy0SuGTPSqIRO9ZshErxsy0RuGTPSmIRO9ZchEbxsy0ead6wOZ6GlDJnrGkImeNWSidxoy0bsMmejdhkz0HkMmeq8hE73PkIneb8hEHzBkot6QiSZDJjoZMtEHDZnoQ4ZM9GFDJvqIIRN91JCJPmbIRB83ZKJPGDLRJw2ZaDZkotWQib7akIm+xpCJvtaQib7OkIm+3pCJvsGQib7RkIm+yZCJvtmQiX6TIRP9ZkMm+i2GTPRbDZnodxgy0e80ZKJva+LXTPwKcItuQDGzsJdAT33ndi9ez3Emgugsu2FGB/M0Vj2UqYaOeES6be6aYfiWTikQuTp0AyasQzJHrAGuErFK0CKgMSB54tmJkc5YUHIIiYbF0pxDKSy7Lis/mHSgHksH0TSPAUMXCbnrCjH1OD8eOuShTgmCwjJb8QCs7eX9zb01yhrogAGzF6UAsT2IKyxg4BcTDVfABgZ+Qv5H5HEZRsRyJZwXeQh9hjUj0xi8bQNG9heOnA2qfX9hg37/xSPvt8b6L27Q77/U6MC+ykFENDGBVuwmFbQySQzhHl3U2iNkk0xHxHnC9jvMx4h99Lp+5tTe14Mn2hlqEL3EneOrsPEhL/wUNQ4sRCxdt2KHcAWgqKCt4iRMbeUmsOF90X8NEz2Ur54z5KvnDfnqBUO+etGQr14y5KuXDfnqFUO+etWQr14z5KvXDfnqDUO+etOQr94y5Ku3Dflqc9fMgXz1tCFfPWPIV88a8tU7DfnqXYZ89W5DvnqPIV+915Cv3mfIV+835KsPGPJVb8hXkyFfnQz56oOGfPUhQ776sCFffcSQrz5qyFcfM+Srjxvy1ScM+eqThnw1G/LVashXX23IV19jyFdfa8hXX2fIV19vyFffYMhX32jIV99kyFffbMhXv8mQr36zIV/9FkO++q2GfPU7DPnqdxry1b9kyFffvj+OCJlAMGWOd7JnjAWpVOf+xYT5nLEe6LEBIIBSr/pkZiqoFfnVr7k0e04DOAMJ6Iluse+VjkufF4YUBcGzR8iSFhcBE1QQiAKsUjuyX2DJT75fG75aeYbL3CGhITloHUIEHzLpthL4LqIXqTUV7OKoQIGOYc6OgFGEI8Rnbs/t7MCwRTHad5pAoYBYMfSkR+wK0wRhP4JxJz1OcpHjw9CFrqwTYnHRZ1jzNo3B2zfgbX/5yDmj2veXN+j3XzHu9xe/TnJGr7Nc3RKUELEzNI8Mh/xBdhdUQgdwxHsk/CxijBSS+X/k15UwgqIa2zut/e4U2SLRGHNMCnGE0KEkEaUOLa8Q3ZWhm5VMMfVEe+odhDG+eVmavZcpgiPBGmRBGV9EKVIVwINVQGs5bUcNO0gyYdRnXZBVUNR9DfA1tEDzDnnoSPI7WQo/ZA3AdgJ1CJ21S691QZbC08iTwCdHrTdCNbqVeNnhavY5I/gK6gf0RPcP4l46XpfPZA2ulHTwY/h3KNLQpQXZinPG+/NJOEL8WWn3XursjYLz73HqWOEZX1pxJCOiBfOUUfJytCRp+AYBl7AetfCDzsoYfNfcd0N2SN0QcK6zikDQ3CoI10PPCpmMiEyqWojMuIKE1u8T2REhB+FYcOwNZxSJJOl1/AS4VyYAgYkGwuwjJwg+eHtdl4630p1nmUkC+MBA9gXGujacEVFUVFhCI0AXEwGOTIEtm1d0LtaLz17xTZCSxDwBwwEPaDbiTKPeckZ0Ib4DpImuJr+6wQEQB4ThCPFBP478EyG6TNgXlH6ZJvLZAkbOnvzZ3HdDwY3ZPTPLEJweug78i/CqyCxBS2VSN+GZxwwrGlJHpWpB78szBrLc2N5pPUA7MhiMxxYAaAkllFDzTOvBOx0sy0McmG8rnGiGB3RkTPIk6jcx0F1zpzXpCc3klF9wmR3hArw6smSUdpDT2fUTYoxAwQzOVBS8ALm8fVH4aDgjcx4Jz4TpQ+5kIiBHC0PAMoQH6cCYgOweHU1nxlLGUCoi06Fb+d7Y3ndDBiF/Mr0mFgvaZ4g0pTJcOEtwIQVNBD6uQT1wJDLWYVepJqqk59u9l1BE/CuhAb2HF+DpwhQllkaFo0qnYLIZL4B0muk9A8lfxZ6Jp6XV7L0ElvLo3aBHlUbYmw8CE8CbjuixUHdgRXZlR7wQ9tgOHAELm5HvgV3t3kuSKboZNckKkA/TRnY4F7plzr3mC8ENT4BaSKKR4MWyIuZJ+5XqbPMOOeC0l7N0SAccEkh1ESPXKSD0JuEyNL6O5a4pL2W+JE+wXND6sTR7L+mcuBXmemIcsYFEla6S+pl2TNvCv1AC/KkO71kp8cJNSC+DTtFhzsWWM1L/QQjAwGdhcYQjPkVFq129gzJS0IsxKA+8S4oyD0x4Ak8Pf5362HDGEVhLDpNzgFs71DVTfgVzMSmZCyxT+COoUyStrssShMid1rwWZnN+JSOODqYYQrrRwepwVZR6JYKhslSJRnMjnpDIKEz0DWMCQZu1RrHEtbnTmh4k+sSjT1S8JmAvkpSoiUoeVO9a4MRgep3/PKKuMyYWPAg8w85jutt3yAFSLgWcN/EZm55lI/hGP2KrVZoAy2dEIVoezZYTlatA+KYuD68llTZ7L0Wx8Zy6EJIcy/plZVQpvkErkmdGshZ5obMUB6ggMmMRqWACHHaNzTvkGNKBYeHbxvCFpVQiE7bnwWaJ0IGIg48vC4aCOtNAYCQfEfSFRtfQcEYqD+DXQWvQKdGQ+fNCzmHJL/PIFFtGCADqMpGzBw/zIBHB8OHwk1v6Zu+ln1Cz6FvAE/GtgzNAOJGoqliS49E+xFvyRozS6AJi0F5GRMU7FcUa3wnswqQvHbGPsMM/hJXi14g/hnATZWYdVw+5gelP2rowkIWY1esu4bnm/MoqPEJMoUTjdKZWhPNTbMv86Ehqww/kriMpMKNXKmpMxKRNFOKhFCzavZfjCvyjzLv4Wa7Yk+khLsyBPO3eSMMc0nl8BtWn3ml9UXPFPoqrUadt9l4ilVBI/LZKOSJpUkOsKuU7whfOayDfwsE1sJBWQhBGFcvOsoRHI6ia8yuJA7NcYAnzMio6x2FHvIijK+sYZ0j9MKzEeUYNUsZaGtVeHgUKyTXvkFNollMBPsNUSFOTwl7ZbU1ZcUw4ExZYBfAgyqDO1GEwoixVwpeHULWccRlhHtQsCgjOUWFkrgFHAIozARkv1OmaVQ8wX5lTRA1oFsXncaRQAipoOGOEfQXhhnEK+E5cKhGewiNdRggo3OOinN4o9KwoTBb5Ee/MP426s6A5vxJu20G3qIYXNQ5SnDPLkurGSDOo9BGaCXAkbvEVL6fIFzE3w+Xb8yuZE6AKBpl5SdTRPh5WEakeOhuIL6BVxCEzlDBCtsRSslxxAZRVyDJjc98N3w+qWUmd2HzKxCrBVrQTQbZmRAgTzYkZamFT9UBap1VutkgIVUjzfh9Vl/K7oh+TPO5se+Q50EYefxWcw6pT8YK4MK1RiYCvBIrmF2vPTm3rSsxG4LzAZ9L8lopPFOUmyBgFSEasKl8MGNJVRWqIoA6nY20TtGtz3w1PIymSMviAMCYmUY4IUIm1CfXHJAdKQ6s8pSxXUKxEFJ49UY7KZByavZfAR+AvY+JGVZCo9xfMPAhUaotVQQCCpZGCWTBZQG6U10esAu+Y969t6yTYIQcvpQjr5ReocpEIoTcsGVQ3C97h2QHvlN+oq5P0BumozLcgr5q9lzAzkcwCBxHLJyeAH2bRb4QUsYsFhGDFYSF2cYWqSw8JPMQwgxubd8ix9YhG4e5EdUdn87msSmmBHKEiIIN9ECSEcyHdlow+BAhE7dECy3dre99NB10nJcLqSYkMmP6LCAZIY91oec1MKMUZKhWyc4g4ugmgBQPNpeGMqD/ViwdXgGZQfprIQx70Iiyml7oCyhWqzmNTXcgxiCLjPP0hESpS8w75zFomJ1N9moaJNQ6Dp2EQ8YT51EYxKskqOvcimHKWadoBHnhehpo0nJFKEbAT5x3Qag69PaoiD9yDhixJt0HsUBUN71V27YGXZCPiHA6MNdW8Q560M4alovZRcIPakwdZI52wPSueCZUrMgxJSblvUPmSaS3lgwpMfcMZKzAPe4OnAxgVpDDuC7dFdgDhrcKMVBCoi/u+p/oshKU6HJVfYgYporkHF5WQsIhUghwyqSMCsWjheoxoUTQFp+tYR7BjR7QQ+VRwHCm2UTcPudl72TPtiRGynrQuiXQix1gfOBnyK38B8mV1kiwXBBH12F6rBwlCzBzCdzRMPKjWieKgeYiTHX6jiooLod7BWkcCEa+xNqRG7Qzxynb8Ra9tjrF971TFG5mCAkeRVQGVMWA8d9w0NJ7yKxK3EGcYTuYqv3OSX8ahkKMGb8kZ/2qjmboeo8N6QG1LB+TaIVXkRohVOo8z7CACunhiDpJ8eywohXIyEoPbNe+2OyFn4jwFYz6JbMOqopZE9CV0UfriyfPUYHwdoZRi4kBhm/XLSoe5Ln3DGeVwPE6C6jwiWIyF560X0wkyVPyBoVghKnqr5hrkXcU0hV8qDciN2HBGJ2HKb/PUhBz1dFIVRpiidN1djUJ+IvWTJfhMhnwi1vcLAbVoQ9zoN9nHqTH4qxvwtnccOWdU+96xQb//2v9DnNExH1Ew5CbKYV67HxCipEEPnMBkdDrwskPWjAsKi/iwwrdHbUqM2BzUUrOfEYmYOu1tmhENzOpVh8/q8h7SKfpmKRhqmKYQ486osLbkqrDVlBFdPdfsn8LQFb23DqDLK+sVZYpIxdVhLLQXEuEBb9M5ukhdhXtAPtpgp+FSs5/R69wK6mIy/CQduF3SJpSd6md1UHhbJx33T2mv7tj+rgrYjSsWgkpDaN7xRrdgj6iXjhpRij4YIH5ypoBOxMQJR212ooyVKH+TEzv+zWAHFawG19yrje7lkazgHtgOmgADiMMAVuZK+mDRRgZARbyR50+qpRBK58guhK+SXGg4YwKiILHI9yhw7WLNizRtVDYmjugWdoYM54gLiCJ5IIaBdg/gP6rkzT05OGa+J6g4V2dtHhoQ2At2WBk9yFz3wDaA3Iq4VR1PhYwROQ9GI841Z1WGHpMxgwoo3fJIASCzatMoE0o8s8q6q+p2XnsdOtFo3BVzdohIHLBxwxnJx1FGWcU17BvrR5tTefB4GORf1JHE4taj1C9lGOgiLWaKkZp8jC1npDNQ6zIhESA2lL6YXEp9gwcooGCoJfW6oB7B32svvfbNwkIQu7hJt88ZqddBI7WPt0vgZiT0rAo+M4503McqsQtXwMVQN+2zMAKKmuq0tj3iZRrOCHWnyMwEIttDoTsSGgqVJmIiogq7nYRgDyUK2sxDDqAKW7CqsC6qkc1ZlTxF8gkl/ei1B2gUsKKaxZ8FvYnQLVQkO+UY/NpAwZCkhZKTPNJLCw1nVK5CscBqyFkdqtoV8iWsBo0QKTYiQFCgUZsl4duBCiRuSHt1GQM8Y8MZKT7TLfBVD9qif0ClmTECjncD0gv0Gb0K3iwZ5E0m9UqeaDMWBJEWt+94L0xFRqZfwf6D6mqYWAYCC4QtDAnigQZ1mW9CnVLjR7RqSyaUjwW1NJxx90YEttthy+A06FLKDoiGOHoVZRk0gNKErtZahUx7FespEmhPYW05I/4OX+92pAx3M2vng3SvwE8P8VyIsdRSBGowB7MKsejPSTtKg3bSNu94BykBdDlgjEk2aQ84BQgmd69i5cqySKKiyGd5NpVYBQhxWaxgZGPDGUfZYGwAhIXaCAvNdVCCCARk3uOYOu1H6TU/GD3iL/A1yOVSl8WXh7sazz9TV0BG9YsIkjbcyqHMnkeDqwhAQRbZKIeIaMZF0SZQCPUJp4nTnFUZpCW1hURmsIKAqVR7nc4cA6kDo4wz1O56YD68aiVi4J5mfCAhbER4Nu94o9OwA3qbhkBNQKSeBFsin2UPuNGtjPBGarQ74zMJ5COVsnR+0bnozX5GWAF1ZKRiITxB+imn43FwFCQxUgqZE8E8CqDARlDrXhkUJA4DoVmp5YwFMMpy05ITf+4xJ1MQc8GHZRqQtVMIm5tYY8Os9qrWo52iPUykeccbGCYFS7eA3eQwClBO6Urbb1GjmrfCdzpDSUaSqUVpBX+ZsblEjOasSmLwDDwhEfAkeHAkS50EhYuGO1Oux2cS4wMGnwWAVUT39rulQHWHh+EbX8CEFjnhoeiVIoxZxL6hgWrkswoDq71VRFKmBe4IqTzLAkESCSnAyZZreAwI3llyQ/U4EAnpYvBUz5jnBdDOSl+ojzL9KzOOMmfKUSzAa8doMyfWKNjpd0IAnIhLn3VqFNVTXI8KAUK54BAoO+aWusGislHPZIPOdA+2e2VQJPwA2StIqy/gXpU6WLtULlna2OjQ44dxtAslTqp+euuKUE2e6ceGM1KNjXqtrAaV7LAW2j9HriW56TAtrG2iQQNrA/OupOD0YgtDpKsG5vDwiX3POmuLdS8FVkiyk3xq0WsWsMYFQkaxiQjC90BaPRF7t7Ud0r7g7Nt7tcFhWhb4yZkSp7Y69aDHXnubOjECbdmgFqtSE7kgL2Bs4jjASR6mvVfbqfDBjOpw2HrujBYyZKDkWEXnWS6EjFF7IJCXyGCfUZzQ+wClg5E3nBFryQNTJYNq9opqgvuDx1Vf4QfB3Nq2BmJArxAY9R5FpxsasPBMwak273hTmy4SaCFJecNsALk4R8zgSlDB0SFLCe9ZL9VIoIiWgSOZXSpXuCfafUq7ejASJFQUPZVF1TjRX4gdOB6/hnnKXEBDqyYrwTSKiaH2AO/pyZaJo0GDyGFQZCWdRWYBTHIC/hOPYRc8Al0bwfqjNF4jJjezdHH8CiNNu/CdAL1VS5kCDVMZX8yfShjqHAQidqDqgmfNBFNmI5EDhRe0ZxV+17zjPSRtvpLSAQBNSa9KoMWctuvQCx6XNgwuquMwwgwiT9Lt9spChdOUmv2MC3iZVfeFVAry1kZd6m5oiZV8QS2GtUKdNKoIru2JKqeSXsgAYKCpa/YzwiGxFd2g23Z1XW4ftBcPFIpQYwZX8CvV+x3fIMRRxkd1I96Z/T3hIzdnVUaFUBQ5ZAV6SnLglzrFH5SkdhUNkARllqo5iHeZtbG3UEMsyh4NZ2QSDPiHBUk4CwskVWpIItrTSgaBqHWU5Po+aUZTSdKuKMZCIi/yLNr9jF7oc9C0R9fPi4p1BEyKbyBV/sW6I6MSYCZCLIBee0uRdORQkg3s8g3tfv+Fj4EoQTNY3cgA3R288Mlybz3VxkBUqNpAPpCw4E0IL35mty16Ce1+RjwjVkG1M+qO1GRoj3Zb0+lOb4AkvYvHmqIkkXptb+fhrXw/5YpIZ5v9jIlcRoALACIqk4swNQtm7ELKekVVu10WaqLKPoQ18uysyY0ldD3QpDSc0fMBxGUcKSCIQhzpcNLLShLnnfjWrKy6SI9kuHHQ/heZI0IcLnJsOCPdpvM0vLJo+VtS96KtEyOVz4ncOAPUgIIEfTAjolBbxbXcqaXxZJt7tVWV5LsGwscMrCmu1/uIoHC0G/AXNI3ZAlISa6FU/AoefeI5wTAxAKl9x1u7AsiIebftFnvFZA2+w74suz2CcmesiUUGRuoMBlHEfbX9IK7d2HBGFb3xZgRMlWx8VPGYnBnBqxT5OhjUiptxYn3S/BnjQbhVvZjw4pp3vKHnCug4e4YaeEj4ZPwlQAIhVhqJ6MyiZnk5RpZ1+aMbQQqaoZtDs5+R0EcxdpG2hL8y5THrtddOlNHp/TmGkEomUy9Rl8Nv8Ag6vYGHvCBQDJac8buadwdIXMPuXQFJStXiWd5SlQP4ExlOGOu0GTiNqpPvNmhR/Va1jfwR+2Y/Y9Db4sjlQbtSqbhSK4UsarunrLb2uUBr8W1BL4RC+Ca9Icma4nHhcVJzhibF591S8bttWrhFflksSx8noUHkBQHD7QpwEwVEnCPco1RtoQfTLr7hjGjBKQkZwOL1thRzq9In7QnQRiXWIlVTHAshTGaIDyb/xSKcRHyZ9BnWvE1j8F0b8LbvPnLOqPZ99wb9fufG/T50P7L2rv6VDfr90q/ZuN96VxoMT+luUlVf++7prHQW8UF7OHynhQzHoZqjHfcIaAwzRYAJbbCrafy1Dfr9CzfuN6pJG4nQ49T8EWB6FQUHsohvoB0LAgJTQ7Wa2nPQZphJ76/OA6kVd9cXre13btDvX2Tc7y9+Pc24nd9jtx694Rz3hvPG748F6gSJ2GN5yHhZL6z2es23SvozUQBAQ9TGKCy6V3Vdu4URE8hOvTvjxh9vDrrDvrzG4Hs2mIPfe+Q5Ru373g36/dfveGqsvXe1/LbX64Gdg5XqWGXQOFaNQgbVZXyFXvIY+U8PUcyLZJ3e4hv1h3CQITZrT2+E9zrhR2+dz3JA6LiKiuq80I7ek8Rk7lgn5TWM/aB956hkmCxgdH/tYRCw2NAhVC9ukm8FpYMDtOEiDn5CBGNr9Ao+pBgGNOEn4RxrIdyOXZeaOAgw4/cAcULm1816iwlq6kVdKY7pRcpJZyH1iPYMKQ16HXUVtiR0+23moMbgXRvMwe878rWn9n3fBv3+G0+Rtfc3G29F/UH+CfNCuWTUtsmk94t1BkG3AhpgXtqpNY56SSQgHwOcQ2/L6FCedu1pIwYcEWoEoyKNLKqaAPi87lPtQL8SJDho4U5I9Rz1tu6oLeohQ6b31x4Oh1qegw6A0/iNcIBVywRuSVEFdkaVIZC2FtW8R73qXaapr6g+vT4fQpP3ehAA9Asi6igvhrwCMEsZVm2O1Ium2lpKiabyKCgH9PNSsfNiownaEjaZgxqDv7nBHHz3ka89te/dG/T7bx25t5LG+esb9PvRI/dWyi9/Y4N+v+zIvZXW9t/aoN+/+Cnirf62obcynOPecN74ZizWvDtvAtCnugJFTR1ms4ODZFe9jUf1ctJejLTonUYW1VSQtBM0kyLwJrFWY/C3N5iDf+fIc4za93c26Pd7niL67u8aeqtHDb3Vywy91f7a85PeUaTY6ma9CBUpwc6BshE1m93G6xJJYksdk+rm9HFMEJCk10bmpLdvt5iDGoO/u8Ec/P4jX3tq3/dv0O+/9xRZe+819FaPGnqrlxl6q2btwTOKDhwbuiEmlVsp4488xaIdHECNVZsFJ0/Co4Q4jEv1qr/pHaTcU9/dYg5qDN67wRz8gSNfe2rfD2zQ779/5N5KGuc9G/T7lxy5t1J++Xsb9PuxI/dWWtt/f4N+v/wp4q1+0NBbGc5xbzhvfDMWa3V5HchXtZtY9zXkpK1YBISJ5+Z17q7OUVnnUkLMu/15ZCoFkag3GX+8OegO+/Iagx/cYA6+78hzjNr3vg36/Q+eIvruhwy91S8x9FaPGXqr/bUXvF7upkI8L0Mh7zqpRX5hcDoHuauh5LQ7E2uqZCk+Qud/5EEvwk8I3rDFHNQY/NAGc/CHj3ztqX0/vEG/3/8UWXv/0NBb/RJDb/WYobfaX3ssqwQtnBBKrtCcLuu8Jp2YrRu+/azXBuegPcpx0ZHYK33lF+l4gJB8v0ne0xj8ww3m4D868rWn9v2jDfp9bqO19yXG7fz2M3af9QFD/arP+NITfT3UT0rX7euRQ32actV+jD3U/2j9ndtgLv5j47l4cg66w7685uCfO2P3eZqH/3iD5/i0U8cdy07zGad/vPHxlZyESJ2rrrInwaE3HRIvrujGafaOmep1cjRZzs8168BP5qwPOuR8GU8bPsN/sr/+aqf7OfygQ0bSsE56y0ZLT29JDsvQZai+XgrRwQQx6lhOt6w6KqefWEL/f+OiO+zLW/b5fLP+Vo8UDzGtwetksGns0zj4ftKJa7rsaph12VBxbneVlU74X9e1c1NC+PfdFvNGY/JPNlgvHzzy3P//a+54nZnbT24tnt7g+GrSmUY+0zvnh6Dz75POcO8ZHh3O69ZYB4RlmWodarZ8hv+0WS96nTEX3YHhS8KqLWv0qw4txLJ1uphm0LvkyxcuTtILgzTdaXtw0QQ6teF6sezzP9ufN7rOLfK9GFAdd6lTaJVceeZZJybtLoAaB72amyW/K5+6xnFydcGJr2mLeaMx+acbrJcLW/P4A/WO4tgHN+j31x45l9Z8vLBBv5/YiEt/qXE7P2So6w3H2u8/v+CqjsbQSRoAKyz3AKciHqxDCboJIk669xCcpYMc4Wq4/sSk1/E5Cxxvk70Cem4f2mDe/PMjz6tq3z/foN//4o6nxnq5eIcd//1aQ/7brJcOedOPy5jXZRjj2s86ocSPRVDbDc7FoEN++mlOi240mHoAtwvRw7sTTGqLeaPndnGDefPhI18vat+HN+j3v3yKrJd/dYcds/1aQ2bbrBe9/w2ACkWHZPjkC784s1J1CcOyzB7/6mLSBVY16o3/sOqoHiqaiKx5Gx2q5/avNpg3l458vah9lzbo90eOfD+MtMS/2KDfrzzy/TDKCf9yg35/3ZH7Dq3tj2zQ71/xFNkP868NfYfhHPeG88bvj0XQ1Q0UPeusa0LGMObdSXvjkCkRkuyWcR6gn0MunU6nmbQ7k/w3fOHw8L78eHPQHfblNQb/eoM5+G+OPMeoff9mg35fforU5D9quB/mlYb7Yb7O0A81a2/Qpc+U3RclJBfRm8i2OOoAdN3roePFRp0yprPddLhTQguOOn1q1QHAm+x31hh8dIM5+G+PfO2pff92g37/u6fI2rtiuB/mlYb7Yb7O0Fs1a293pFZasm6N1bmhVP5mOqrjZUF3cD0VMCJNREUNpZ/5PJ2YXHvdEBE32YumMbiywRz82JGvPbXvYxv0+98fubeSxrm8Qb+fPHJvpfzy7zbo96uO3Ftpbf/7Dfr9K58i3uo/GHorwznuDeeN3x8Ln+YUVMbncVWPKl3HPizIvXV3ULfLs+41QtXlGAkXupB9Wtde5WTdRr2JvtMY/IcN5uDVI88xat/VDfr98aeIvvuPht7qSUNv9SpDb9XEwbKMuzvpdhc/pjXpaOuoY9wJy9rdVV3VgdB+TuOsS54Gh+eqOiGfP1z7LeagxuA/bjAH/9ORrz217z9t0O9rT5G19wlDb/Wkobd6laG3avLezF+mdV2C14nRuUcxDS6xHKMOjRxq7ipreVz5eL/WZRpGpwtec8f6LtOyxRzUGHxigzn4n4987al9/3mDfv+XI/dW0jgf36DfX3/k3kr55doG/c5H7q20tv/LBv2enyLe6rqhtzKc495w3vi5yVdwcUTgrDuZclnrVFey5+x8vy6RJUIVKytdpWGcCBB+WGbdjeX6qdSUNjnjXmNwfYM5+MkjzzFq3yc36Pd/PfJ+a6z/6wb9/m/7erGLXRdxYmvf6cZJjyfSzeRTjOuCuOr7ETs397rIN/shdDJVDoezVMxMDaf2vk6faOehOXa/nYf2+cZ+n9d16hO+MaS5W4eqa+fGWRdaDW5dcaddWXMdaAXZcFxXj05OSxd1vWWKqXx98845rdIVcrKjBcOry/Bo58SvKEUJpHfKnqMvQfeWVv4u6A7D4t1c0az7MScMo250y4usrW4bdNGhbitimx7rnqg4R7o91sUvs0s8Xj7IjRMqvfLLmnPG5jwNfI1D0EVrE/57jOQ31w+pgwOpPjHoIr3Eo9CRY/0cJbnnOSIINmFDGoMbG8znTx35Olb7PrVBv//7kfdbY/3fN+j3p/fXcsi6PGpeSypDBTUVbCxZeWE1RnhTXb5wfDnBqjhWsOt0sY1fd3feE5pO7X09/WT/fWU56+IrinbEP92+1VHRU2yaF4IZEdPF5HUhT1fi7m4lGM8wRK/r4tJ+/Do0Fn7aMBbe3G9XmRG+dYC99boiz3cJr19joWY5Yu5BVXRs7AquQS9kdSPVSQSxT2EZQWRNLEQZxTygk4heU+4n0EAl2uk2vXHufEoUQV2/5kGvbcZlmfxc5qgbx3Ioc2q0XN7dpVz0jsPEiLoegjbWOukOJeqq60QoG8cEP6wr3zMucWIYKpYGtzLmRlevC89ppV9x6Bf9UMz8rK6qC2tFQ9bahxlHMPfQE5rju2Hge0kS07hOwxZrQ2Nwc4O18Zkjjwlq32c26Pf/OPJ+a6z/xwb9/uz+Wu7WucRh1Y21fe1YC8OYdfVfXBABbkFaDEx6XZUShhgiBSNYIDxQAIClc2rv68tOtBO37HQhKmvNYXUIqVPCOCMz0hw7Iqpn4Q3A7lwQE0scdLLO1OU0+VKILPux8NC4+mnDuPpZw7h6q3lHBpHVDS7rEvUg/cgTBKEUXYm6xJna3ahrB1OSz0z8Vh8KoammGl1yjcb0VPgizzWWeRoXOA2BjDJHgsDCWScKHwm1qXpKJVgTHN2q1+AhnQ5RmNq42qUM5cn6TtS8Lyt4NC9oyk6Xr0ddb+3n2QUQq6Maoxv9dJ34NOae2N1qzDCuzk8pV/0N2ZRcXJaVnBumOrpAsQX5TArQLeeLNrjobd4qMJv49yZ7OzUGtzZYZ5878vii9n1ug37/zyPvt8b6f27Q7x/ZjzEpT2EiNs06Lz3qIuWguxYXBVliz6jwuajmsPIpFYe85jxQkUfSoCyad9S//GT/xyGmFOepi6tueRx8j+vT1jDqHqiiVRdDshwHcagEluXjUVkVkTNPufhGYx4Yoz9tGKM/axijf8QwRt/e7+Oom4ujjuTgb0IMhKUx6sJRoMDCYNO5TArVLb4jdeKOjoa5zohDPrSfmxjtcleghamHirhxnuYefEJW7Vc6j9KlyMWcGeApKpPh/QnOzCZGNCRdd9owhbH6DHYUh+FhT7r5etG16dn3hOxp0q3mU8yVJBJpGvX1OUw6fqPPVM8a7btMuud+9kwqvwIY+KjSTUNXmM3TusaJ4t7Yd/S+kkCGZWWImGk5MzrFbcIxNQa3N1iznz/yWKX2fX6Dfv+vI++3xvp/bdDvU1+x7z2HUtFBAdOfmbwheBRunVXOWfF0Y6z4xFDH1One3NgtAa7HwusxqNTIT+19nTnRTmQOtLA4PmoaVhE0XXe+ziOyDFlHWNYGkqqzJYdhnnooYKVWBnHQDee14a2HxvtPG8b7zxrG+x8xjPf743roHPkJX7HPFIiAYqAhlGlmcIh7Csza5rCmXMoU9A2wBgIrwVk1oGnudFNKzXM3NHUr6kBTGenlsPp+ik4xmai9IniHmgbNGYJ3reSYtSPMDnO/wjMUpSHtseG+OssKBb/GmKIH5dIhKkxMrhVIWyMlytWvCGrSSXL9nKODCSvJDAzo3DWaHMJFXXOA5w+F6m5cEiOle9gDnIM5DBPz49gv0avUuS7Bkd9YLPBrOPAm78BrDHb/MV7/X/IVxx331L4v2aDfX3rk/dZYf+kG/X7afr8JJRSuQtbGwZE6y5ijT/z00iGLcJ5ZpwGr0lOJP6hwdFKnix/woGkJw6m9rztOtDNEZFDs+FSw8lpKAqiEbp38RAUGtFg8v9wF4mofXYCqED56yio6ba7EMTT1tQNzx6cNc8dnDXPHjxjmjv14f2jueJph7ji93y5mGjU+wiWPp4+rrkid+ZNeVYfqncuJZLIsNJQh0nhgF/sJhK7KWggtz+nWNFAQjHSR/56wlIysioK5DJnBoPKHK6HuNw+MZ1wZ9PkLIn2hRtvkDoL4EvMKcyG7lECFYxoLz79T+Q8LQQURLxGmQnVyXXZQf57rjn1PPU1rPmucSmaKJ1gPMsoNPbNXyGauY09BWNsGK7qpB4zrzyihTkM/+LkLS97mnSWNwekNYsnTjzyGqn1P36DfX3bk/dZYf9kG/f7yr2j8tSPashJGaKWnzq6ISWD3XUaLQUEpjy8Q1ZV/GnuH218SaWbRexM1NV7hK072f5DF7pIfVO8qPSh2XnxHaYywnxM+vAvaSxR11qKL0zJWlJhQq17P8LHJHQfmoU8b5qHPGuahHzHMQ/u549A89DTDPPTlhnnozH4fqeeQYngWRH4/MDHkGSL2oHhXVBbtiP9Yhq6OujaYZnoaVVUJIhHMrYdZvQhV6Qj0TL6sF0/h+ZRDBxJKmvAv/A213DTPQ6x6P6NmHn7Xd/zj3DCrxS0raZAHEbE8jqldOx3s4Jgl1BzqhDkHkFKbjQP134wbp45B4YPSQZ0bZuVnvm2inlELrY5UgsdJF6UMndbtQqsHF4eQtKMc4wWlKqmGxYe+rBOkdou4pDE4s0FcuuPI47Had8cG/f6KI++3xvorNuj3VzY8IvRjXcfBDbGvuyMeqdbNFUKBHkT9kUsmpYZuWVxcaopwhaiXntaVKlt3au/rK0+001MwnKk3rlQlCLtwB/Tksi4di8/PUJBQ8qBg78OMch2pOWofiC/LiN7LuWFWB+a0TxvmtM8a5rQfMcxpjYc5MKc9zTCnfblhTvtKw5x2tnle4+znsjLisiSwrXGMOUxdCjr81PtSu6FjWeBgSAU5rImPmaln9H0gPbV1mEK5JVCgK11P7RlzlNaFOUcZPLAiKJ+4vl9m4TCPzhM2Xirf12tKLnO7H7MqrcTdyeXMTqhd8boA2RVqNhTP1TeaQYV8WSGEPNOBx9Hpvdy5xzXt59pJ3m1Wb+bIVKYYlEpHoX+gzFT4QbpEnYlBzSxyhnAps6cexQRXPo1bxDiNwdkNYtwzjjy2q33P2KDfX3Xk/dZYf9UG/f7q/bVMcuJfhDhKnF0P6g6UKx0C1aMnuzHA44iF4zK5SoroJyQbEdJrmzmppNlPfvZEOyUvRzBeyT1V1o6I4UseY7+iL/Fnu53Q5FL4PhXTlTw1gcy1b4ZiJ/SkqcMcmh8/bZgfP2uYH3/EMD823urA/Pg0w/z45Yb58SsN8+NXG+bHO/d5BfWltQzzQtuntFIbGvtCQWrR+/MMDL9/CgOVrAQMn8dIsoQizixFSlsMbJMfJ9oL/yC96DGUNKUIO8RmwQKpfqEzM0+IGVom6kLUifrEc9USTQOspMmPZNroF2ycNt2OkaXBWvFp6bpu7nCfcER+WVgWz8fVhSIs+Zd/ROqGEIb9/Kj9vzEM9GzleZVhguezDrLOCmS+Ekn0ikpOVK3mSqW3n/olSxMsjkkybBIvNQZ3bhAvn3nkeULte+YG/f6aI++3xvprNuj3T9xfy0MddaoyoZMIm8dpIaz15MN5gLnE3O0OAmPxQSLJnB2B0FPEpRQcOirRTX58xsn+p+gEQsA9S+WDx3nhY7tCaJqidkL0SeESqUlJmxTqAiteJetKVuF/2vcVDsu1nzbMtZ81zLU/Yphrm/0nB+bapxnm2i83zLVfaZhrv9ow1/5Ew1x71367On67ynrjbva4kQGHhPKP2flpXZzTxJjXfhmZrf088jc0yfW+Dn7IS5Nrk26B1hEyPFxa5UYKf2ugbLgOrvqckk7EIe1CVvWm3jzuqg8urKzcLg1Nrv1/t/f24XZkaVn3SffpmdPTB+bAHOAABzhAgAABVq1a9QVBowQIEDVi1KhRU1WryqhRo0ZttdWorbbaaqutttpqq62OOuqoo446Kioqfn9/fysiILz66vkj13vleq/3d+/Jnq61Z/eZgf0U7Hmv3kOT5Ox9aq9Va63nue/fs6oqr8q8JRJ4l/mxHcuRgqHz/IBw0dWNI06gDdxQEFIar1vbDBXdJKviPFED02ONsUCAY6nxyPxqXRSVG+uS9D9QJ9Tzn/QQa851zdQou64Y6Hgos6ok/46z3D9DY/BJM8TeT97ynKP2ffIM/f6ULe+3xvpTZuj3URKvgmTkQLW6GQfiCNUNCu+x7ImURQ1brZqeeE/VnKOQ67wSC0aUgAl9bXYmr3eutNOzQCiY+KwAW5HCim6saGCm56hRrWhcF2oq9UXbUUb049hrU2Lvmr4vqoHQm/DVDfP2qWHefmiYtx8Z5u0k126Yt3cN8/aeYd7eN8zbB4Z5+9Awbx8Z5u1Pnfax6odcW3m9Y6JVLKYs5lW3eMKJJwqEBkSb03Icc9M5bZEkB7clo+MzN4zpNf297mnFGc6prpZjM7YdkzpjqVCZdK5qcaHBsZxY9boytShZpSwp8HLO/G7T+4jwHie8qDsqnU21CANdQBcQmnJp/95joRfXgnFeNfl110ZWBIx4TPbnuEIXOTeUfUfOty7nz4axdMwh/HDR9hXTqGwo0YYGxB05NNNYRd+2Klm2s+zt1Bh86gxx/NO2PH+pfZ82Q78/fcv7rbH+9Bn6fZx45N61IRtD35G3KaQgk0PUAtdjvEYyIwmEHOlziqVj5uo4tFnXQZUU59p2Z/I6WGlnppsDsKxdI27WQZUC6xiMxKJvWNy6Xz4V2EiDK925g+oP+duVuviyJ8Al+3M21ACnhhrgoaEGeGSoARKGvKEG2DXUAHuGGmDfUAMcGGqAQ0MNcGSoAY4NNcBnTMfRq0esMcadXOzR/C21454pnpeV7hLLCqWtkZZkON6WbCqkDRLPXZtX6R5dH3s9prthkeuyubYfWN3D4oHi/Eae61lpg/YM6toMMHSfN82Qdy6jQs3ZSJg75KCp4th3nP1MBgTWp7vw6GEAw0CZ29cs6ozETZW47AeWftPpVkt5C8RPODkjzwzA43eOM9TqemvfRUB+OVBrIyj0lQOvQ+wpLueB04H6yOAJPrRDPcsz2zQGnzFDTvjMLc+Fat9nztDvz9ryfmusP2uGfp9MY8yoS3MJ/jUrLOuo/+SVz/mHB0Ah3ccwaj57JLFzVMIIPH2TUXhmUfrajTuT1yes9n+oCFXE8K5qFQQbshConYSb8y0K8b4IPQ0doPUjsawSbIvkYMpsbkzryBvqiVNDPfHQUE88MtQTyd6oDfXErqGe2DPUE/uGeuLAUE8cGuqJI0M9cWyoJ04M9cRnJ3oC61FyXjPVA/yY1ZTC66rgNAeWiNhBoTDUV75lIMUWdYPsEeXA91XJfU4zrQhWCFU9XfTftBWpXTcZpIQe+6anptBR56/51ZKv43Q54LzSOZTCQfCnGoAW6CFenNeiYxnzvZikvM4pubetH8JQMM9Lyvd95J2KJaUNOYAAygEs2vTeWFQj2obaRSioAOSDKhkstybjLFWV7pLGEXS3Gt0kCOlUVQSNXvfaD1oYOoZ1ftEYfPYM+eVztjyvqn2fM0O/P3fL+62x/twZ+n1+upaLEblNOK+HxhODqo7gkWcduXYco4+VtnLqtnANZToCFSvP8S8Aw+Czsih3Jq9PXGkngSm6LJZFbFXba6jcgd0WUQ8pEeuxXWy4GSJvDK7RNecltoLSIvK8bpukFrChNjk11CYPDbXJI0Ntkl4vupk22TXUJnuG2mTfUJscGGqTQ0NtcmSoTY4NtcmJoTY5b6hNPi8591kED5C+R85+2bBOWAas8lbslEbUY1W2qoaMA4yjYwoT3TBJHXLA+zG9B3s50gzqnyN5nfpCN9DO0XmVRyKBYshYMiiMomCGEnZqDVKZEwHGkUnSpnqCogbLBHXACOpSLdZvQNy42HGaqc5wojM/lDlKSvc1LhtIBUyjb3S/pUSbdHp8YmyagoXtyoKJU44xa9rOjRmzjrJtZFq2zBvXgVCKos98XbPgiC+cUR3DOldpDD5vhlz1+Vueo9W+z5+h31+w5f3WWH/BDP2+kMQY+FxOIm0G4hkLxY1l2yPfO2Z1yS/FXHivV/4LfVmVntgdPMywbZzrE23yrpV2ZoWnelnokVtUAIlg/CDLOx8zIhjrcegIWnx3ljkCdpmxJgEoFXlUjzsI6Z7ADXXOqaHOeWiocx4Z6pyk3rGhztk11Dl7hjpn31DnHBjqnENDnXNkqHOODXXOiaHOOW+ocy4Y6pwvnPaxJafrxCMrxoxKS942DC0niJPBn7rpT8dK1g7G6EvnYps7PqfrGHRpQ7Kvw/eBNV9o/VedLijnjC+2TBAx6qzPcYLMmXHUjXvrPrZtNmSuZ4CJI2CVVOcEkeY2a9t8UN1p4ITk3rOKQx/rEPKm0KWMNbKnGbWxLEBfRsJSrAltyf3JwTSFbtNSQGEaPlLpDjB6EGJF8ZvF2gcmQ+WIpaoN5Ry/pZqTQ8Iz3c55lvuTawy+cIa890Vbnu/Vvi+aod9fvOX91lh/8Qz9vjiNMSj1gkhLMGYRVrnuPJ7rOSQUTZuqALpQRa2LxaZmDqWHnPS95nlFpuurROccrvY/r7TJutYTCF1ToiWafCCtBnJjoc3VkVWTtbmeNNq7QLCkKYQ4r3vuVTHZ17GpZjo11EwPDTXTI0PNlOzH3FAz7Rpqpj1DzbRvqJkODDXToaFmOjLUTMeGmunEUDOdN9RMFww100VDzfQl03Esx7xybU7Jh7lVFOBrZlJBp8aGqdl2LZV0Pcm1aIA4jbbTjeiOcnT9WJR9kbChnnhZuZDpiXdIlKyDA/UtwSI6DtI13eApwIN0EF5tPS5uw6NNMExbKvJl+nw+fRcet6ZeVlJeIsgMONyBIzNJUG+tHoAVRr4hD6FpOKnFYk404j5ZWrdqKExlGQNetOgrDsvkzmLWu6IFcQ0tsa8thy5UnqPnul2dtu+EqicNNLPcI0hj8CUz5NAv3XLtoPZ96Qz9/rIt77fG+stm6Leb9hsMO+oeXSpgDQBPPZ60YD7XfV5TqS07T0ZiIZJgCTwqCpPUKqfEQhTodiavT1rtP55ETLjUFeQDCDnopl6dHsbUqIzcsZjoR08XMg5K1ZvYOPRljiwIZZlopk3116mh/npoqL8eGeqvpG61of7aNdRfe4b6a99Qfx0Y6q9DQ/11ZKi/jg3114mh/jpvqL8uGOqvi4b6yxnqr2zaRwGauhsobxXMHV2F2A0jJa5KO2d8nkGKiAsNAzdyEvpCoz7WvU5n4ZvkflaUvSjvET6CcFTLLIw54dVnbc16YJEUzFgUk+5QxdeNBX+jPKbCWsMyT/chI9S6oYmZbnrFWguFD5n3mR4dMnRY7hBIIiClumTCdPnAOu3rcRi1PajKy5RZlcQvehJYIG3QbSgD68hFcTGWM/OeljCyrFldGE2X0Xaujsy0Og6z3CtYY5DNkI/9lusQtc/P0O98y/utsc5n6HeYxhhCUYU26PuaUN+OzGBCuTbVEXnxN6R8tAUrRQ/RXDxQp5A2KfMuV75MriH+5JV2khWGMui2dHBt4nOv+4e3I0GiG3tCV1fXeJZ8LFioxD9WZdlpaXUly5tYnl5DvJmWOzXUcg8NtdwjQy2X1OY21HK7hlpuz1DL7RtquQNDLXdoqOWODLXcsaGWOzHUcucNtdwFQy130VDLOUMtFwy1XDHtI5ImL/HXoyuqBlQ1Zj50FfE9i9q8RBShMkn8WQTCvKFYoZJdoKY4Zrjyled41g1Ei84EVNZAWKQGMtTt4tIx712s8yzzY1nURBPqhdA06n59VTD9qs6nWk7PHmK1dlRMCJWsYIciq0dI2JAptBKrO8YyIjipu0S4neZR72KvW3gnWo4Rc63usUrgqZifBZqtJGxzaklnsdIT8ljXruJcta33VVlSlqXCCWkLYZZ9VhqDYobcXm65plH7yhn6XW15vzXW1Qz9rpM94LorAgqmHwhYOQt20CPBBmaFHp3Ch3FqbiCNovhqlEPVKBGylsgCbUzut/0pK+0k+ZSowTEfu7aIuvmS0rMyUVOTKrzTQ2EAdnSh7jMcXa1gOXok0aj7pCbXlW+oC08NdeFDQ134yFAXJixtQ124a6gL9wx14b6hLjww1IWHhrrwyFAXHhvqwhNDXXjeUBdeMNSFFw11oTPUhcFQF9aGurBJuMBiCzyaiziQ5+g6apGQrdLVve7O59pej4IuB51APYKUudgKgPGVJUgpYXx6NG8IhL1mcesezgpTF+hG+bMuKY5WjAWHz0tOw0hEqQfOY1YwvToWWp1cG6in95IHXM2E7nxPQ/gUoZbAHyjPEpJoAigxlywcq4EBaHQT0tjyKzHdf1+UA0NYFn6gkDo0Y+WrrB/G2msHj2+c5nigc20ZyD6wEeBl7fsi631ZzvPsYI1BM4NO+PIt10dq35fP0O+v2PJ+a6y/YoZ+X0ryIZmng3yXevgR6J7f7UjGbeFYsHUIemo3kXPsYuQTrEyi/lCXREcyQ5ntTF5HK+3EH6GixsCxqQAUMHpkR6ykmrR/v2pcofRLHieDITGGoLCVZahErFpWpPvSNtOYp4Ya86GhxnxkqDETXbihxtw11Jh7hhpz31BjHhhqzENDjXlkqDGPDTXmiaHGPG+oMS8YasyLhhrTGWrMYKgxa0ONeclQY37lSu2JKVgU8EXqwrEfGD49FIilJPnnQYaUmOq8iTlfOIxV5zLiHWEAcZaVicYcSDIuBN7OfEF8H5qMOFrq/Do9l6Hoi750ZU5cKNswDHqYXpchZksgSJPci9oRCqq8jkXuRxAg48kkgHgy8ZGapAHdFSMfFteaMofBmI4D5fDQvCcd9onGbJtYRx+pJztIJUq1ZJn3Wds2/KWvuo4k2XWE445lm9EHAomu0ic6spBmuZ+VxuArZ9AcP2DLtZba9wNm6PcP3PJ+a6x/4Az9vjxdywKPsPfKtei0keRFSvCFdvANfiAyNwR1DjbA4EHqeV2y6mLHP/hJWRQ7k9enrrQzKxs9zDbHclYdjYjk4xyNE/X0Z9bWoNvZRsRR1E3hAkKDRVmX9UiIZYGn97TcUK+eGurVh4Z69ZGhXk3qyBvq1V1DvbpnqFf3DfXqgaFePTTUq0eGevXYUK+eGOrV84Z69YKhXr1oqFedoV4Nhnq1NtSrlwz16mVDvfqDpuNYwf8YF93DgFobnWxGPfSyI85kWeWLvucUIugIgIwrMKVmzVK713UaY5Xef7XJ3MhUH6txURRHnvJXImHZoVOjHolURbo+6vpBQRogZk4r9eQSZk16T5KKtZ/rKlrnWgIeYdSJgtYBMZkTuzh/rFPmfNM2le7ijvLkvAA69Qzt5DllrmaM6971uumb9x0l+4Y1VWWOUM/ZyQJJqvngA0VhpFo3WT+y7LqMpFB3Ooa1ftEY/KAZ9MsP3nLdpvb94Bn6/VVb3m+N9VfN0O8r0xhTk90KQklVsET7xZMHRqoPNTm0HCkMjCNm07M86tCPxGO+Gd3jCOFj36S18k9b7T+xsCe2k2y0G6YgcRV6mKFyP9UF1hZRuc2J7D3GE/1KcaQKLC/EX1fEIb3/6mba99RQ+z401L6PDLVvek+SzbTvrqH23TPUvvuG2vfAUPseGmrfI0Pte2yofU8Mte95Q+17wVD7XjTUvs5Q+wZD7Vsbat9Lhtr3sqH2vWKofb86OZYv24xl146xLukMaZAZOfR6bsDoSZO6iCYbou+gPn5ou5zCPlOiKcceypuw2qoMLLqS8Elqq+q6HzjNnuFmdtQ9NUotAHqXlSQD3aAmRxNnxB0yduHbRPvqTmFZTxD2zPch8xmMqWLFo7eJBl2toE6cYaLXimxEC6grM45udMDm5LmBPudMDt2gXaQZyxsJ3/Kfi40ehsSKITVRM2VtjKw19Ho/tExX/ox6tpqOYa2FNAZfPYMW+pot14Bq39fM0O+v3fJ+a6y/doZ+X53GZJYEYbTMCuwnyhJhwJLtdUua0KLRxpZihB6QSYobg7ZtsxJJwrWe1UH63Jm8Pn21/3UXdaebgZRICO8H3bRKd0xoFN9p3tCzwssRZVfWQQ8EKxzLiEoKtRXEaXLNz4Y6+tRQRz801NGPDHV0cp+aDXX0rqGO3jPU0fuGOvrAUEcfGuroI0MdfWyoo08MdfR5Qx19wVBHXzTU0c5QRwdDHV0b6uhLhjr6sqGOvmKoo68a6uivm45jOw6Z1CS8lNkTnJ54XUeOyHws9MjMnpHoA5Gp84RVMsbgIM4sgDKPTfoczw52lceSdB1J2P0YOOkhOi2cTBFHadxlJQuQoFRyJpjHZTkyl0hfQ55cb0WQ6AlYpJWYeZalC1mFLmBo9ViPkXVJlHbaApv7EVpGkus7FD8rN8+YRNNjgbX7grmM5Fb6J4EzCP2QQY4VoUNPMmb2NgrgAPMhL9qc09oTeIqsneV+jxqDr5tBV339lutJte/rZ+j3N2x5vzXW3zBDv69N13JUSiW4eBJVDjnGg+reD9jbgDDyZZ0Tp8hKdV83EjhIxlgO2o2EnhirncnreKWdOOq8HFqUGumOIN/HgDqkriOxqMeDOSWioURLU9jJyHTk8pzQNfpKNwFLdPSGmvzUUJM/NNTkjww1ebqvdjNNvmuoyfcMNfm+oSY/MNTkh4aa/MhQkx8bavITQ01+3lCTXzDU5BcNNbkz1OTBUJPXhpr8kqEmv2yoya8YavKrhpr8mqEm/yHTdjGfRwZ3IOj1ekpdo7M3gJNz5nXVLHYo5wqzRDJCpMscWbbvOTPElTwm+zqGjOFlUjFvBt3jk8jfQsk5RMuEBXV39DeWVQTAOWItwZeFykltXI+aTq51Q3qzEBsCF7x9YFIR2sfANI8DgYBV7zRjIXREGY9AH6q8Jgj1TnfdapLn6mYdjD2A6ckyBFRWPuuMCF05FIkPKAHmVNTD/xqO1hHIXKln4bEuS6bKLJpcY/BDZtBoP3TLtana90Nn6PcP2/J+a6x/2Az9vp746y4nBA/aeRxI+HroXUSTZ01bjq4rxo5jSMIhVuNIoHRej9QdyrGgxtTkO5PXZ6y0k8BbUV5iOeLeUfFFMTTSmeisEt2Kt+2I/zklMVJU1ZVkXEIAGY2YKrWT7EPeUN+fGur7h4b6/pGhvk/Y9ob6ftdQ3+8Z6vt9Q31/YKjvDw31/ZGhvj821Pcnhvr+vKG+v2Co7y8a6ntnqO+Dob6vDfX9JUN9f9lQ318x1PdXDfX9NUN9f91Q3//wabt6XzIvS+XZoC3PTIOe3OER5kw6RgK8zexHPet5RwS0qN0e41DEzPUrz1hqmnJgauastzaC2Is6J5OxrENwVdMOnRu8bnhWtj4nh5MgFQc7aKBvGYf0OsPYt64gQzO1ApqbpTnWBQqFtY7M97nuQNtw9mKbk6xJbC3TF7bI0CJfkn3b5E5yCpl2iPk4tsrujHeW0cGx8i0TRTfdqMkDTQVjL8lntClqpMaijDqGtd7TGPzwGfTeN265zlX7vnGGfv+ILe+3xvpHzNDvG4l+QBTH0OmBF02uPWQELVZLjaBDQhOKe4RC18cCWUiW163PxOfHljJZkd6v9jNX+//BB8+P/A/p1aMW6m5RDpPdLsEBepJ8OepKC5d16F0XWlIdVTY9TNun97LY0CucGnqFh4Ze4ZGhV0ifF7CZV9g19Ap7hl5h39ArHBh6hUNDr3Bk6BWODb3CiaFXOG/oFS4YeoWLhl7BGXqFYOgVakOvcMnQK1w29ApXDL3CVUOvcM3QK1w39Ao3DL3Cj0zmREBj5xXxNRZF4KyVXdm2jeYh/WXF5IVDpce8aCKhi9BZu0hiImqD/V363Pmx9pxlBZGM7Mko6WZ1iAqisfI9c0hPMtLDwAD8zGroZNUSWtDlfF9SCyAc6+55SPZAA4jvQWdrUJLNIqPV1xia3HVAfBcq1AuTjxTE7GV8yB7TWkAZuqrrdQPmTPeE7ducD/YDuV7JmoiMYPKKhRJamRuGKgtZ7gCrcSiaQcew1o4agx85g3b8UVuumdW+HzVDv3/0lvdbY/2jZ+j3zWmMqRvsQkv8JC11tW7n3SCthoIEpfSCQC4wwiUSvGOZtopkqP18JJuhWhKv8Fkr7WTheCp6NQ3M2sITmIkHzreAhjgM2RBb5LXvdfFLQ+7xMcepuNwXxAqCdvpssQ19x6mh73ho6DseGfqOnWfsfMeuoe/YM/Qd+4a+48DQdxwa+o4jQ99xbOg7Tgx9x3lD33HB0HdcNPQdztB3BEPfURv6jkuGvuOyoe+4Yug7rhr6jmuGvuO6oe+4Yeg7bhr6jh8zHUdGhoqCQifTagx5wznWrQdrbV+oqDIUDflj6GIkTZYSKmXpEe2RzEWKT3wHJ7qptPVIDzxxui227pXd9QT6UUG5JhYRdHEJRUFVIaL+gaUkSaJU7pJn6pH1OcOj8lPLVxWcPT+UjmKGAkWtiErgCbVH43RZ6YRnixzZwAzEfKTX15IBIpKFX2D8WG6tJ4E3vZ7LRxbG2CBLOmmJkgbSeBJtTjKOlE+KvpzlmXoagx8zgw79sVuuv9W+HztDv3/clvdbY/3jZuj3rVQHEi8KQh/alaCKRqqIWF3IHFGP0FdjtTtfSuNkHRShIrt2vMeXURnvdiavk5V2Zsj71iO/dM15RiDO48g6rkloqD9EHDl21EOLiM9o2bpl+VcFyXaUeciapEaxoYc5NfQwDw09zCNDD5P4jg09zK6hh9kz9DD7hh7mwNDDHBp6mCNDD3Ns6GFODD3MeUMPc8HQw1w09DDO0MMEQw9TG3qYS4Ye5rKhh7li6GGuGnqYa4Ye5rqhh7lh6GFuGnqYW4Ye5sdPx5GVXVCAoAn8YkMMILvWul64L4N2WDNxmScjcbvIXIXsAcPWpDYCLGEtpvuscuKnbsdHYB04+UzGgqlQEImzQgGX1FlUHlxbkBoYa45F2spblkXFIE+PVeacA76vK13mpSY6VE8gV+oW8cRr4kvoC2wNp9HpbDJ9GkIno81ZS+6PmTXSQ2UeI2qjI5DlnavysRpZiqNOT9fGkkhPmGOiehZk18Gd0SddWTXzXEehMfjxM2jan7DlWl7t+wkz9Psnbnm/NdY/cYZ+307iVYX4KLMOnYLIHvhL53WnoJz4XerJsAi4WvaD2Z45tDxJgPTb9dQIkZY7k9dnr/Y/8CkKnpKPYxPHgBJvZWNK/BCKqaNSA5NoOqln3avI6YZgXoXRHutTp88M2swPnRr6oYeGfuiRoR9KrqPY0A/tGvqhPUM/tG/ohw4M/dChoR86MvRDx4Z+6MTQD5039EMXDP3QRUM/5Az9UDD0Q7WhH7pk6IcuG/qhK4Z+6KqhH7pm6IeuG/qhG4Z+6KahH7pl6IduG/qhNtl/QrmGxNJnrJmWXIoLwlCgoxAXRHeZIhQQX9aEkhxHLGBaFIwhGTDLk71k5M621J2iCNU+9K7VvU2ZpRSF4sAMbskHzE8kS0FKihBoGhrrbEQUVLpH1NQPcYwBCcaUrPU0gJKTVTdogoGJqnpRQS5mrFldGJthkRbJoMQBlAz8OvFDCBIWq+JfpUvbve4YWRZokLIPZCR+ky9DiXnkF2F5YBk2qCsmOKfOz7KXTGPQzqCPuy33BWpfN0O/+y3vt8a6n6HfcdpvkmZVwjQUi/1I/CYeByAFqSH0JHH0aNHpERkADYJnWesDIxLCOaBEcq+nz1lpJ0EvJ0AEirRDiwUp9bC4skNLliTLQrppHJE7hORaF4BVuoKrQTZR3CW5xGQv2Ybe6tTQWz009FaPDL1Vct3Jht5q19Bb7Rl6q31Db3Vg6K0ODb3VkaG3Ojb0VieG3uq8obe6YOitLhp6K2forYKht6oNvdUlQ2912dBbXTH0VlcNvdU1Q2913dBb3TD0VjcNvdUtQ29129BbRUNvNSR6zFNRCk030suB2EuexXkgF1oU0DDUjGbBImDd4G2EpRnMmgzttbUuT++jy/xsWDUxuJFRbmuSUU4/VWZiYZJy3WJ8B7Ku/uaGRtvYip4lO2iT3dQPVWUrDdMqsRL1Wz3oDROF3Gk5zc040uRad+olkuc91TLvqTWxilUG84m3IgmyTnsNTFEu4k+u+3tVbTcSN1mY6uRAPqmQT7qQhxOCtfSIldg2cXH9grXW1hgMM2jtccs9hto3ztDvn7Tl/dZY/6QZ+n1n2m/MCOuSHI0kGrVqu77KcRDMaxYSaSxX2igHT87PUUiDQ+fga5A6fF9ync7nrrQz0x16yYJEQ1+TX6EU2rTadU2GTyqaEa1ZNSXYAtmfN5lvSLJYB1QVOWdMnsW2qU87NfRpDw192iNDn5bsl9vQp+0a+rQ9Q5+2b+jTDgx92qGhTzsy9GnHhj7txNCnnTf0aRcMfdpFQ5/mDH1aMPRptaFPu2To0y4b+rQrhj7tqqFPu2bo064b+rQbhj7tpqFPu2Xo024b+rRo6NPuGPq0n5xoWmYvRaWGtN2QLwZfRw1swKsFV/c5BayKDE6Q7WJkCLFGfc8SDXpedd4nNbCq7btAUGtdFSOqiRBde3rJOfbku5I4H6pyaPTcEsRdUTAYFLrIWWSbwbfps/5yn9W+IoP1ZaswrNCTKwgREAKzBLtIyOD0lH3O/KfMRUdCj1ps02dmowQrjBf1LWIdq7UnOrB425GqXjX0OesEjYR66atIgqHMxjpnypBQBg2vjmGt2zUGP3kG3f5TttyvqH0/ZYZ+/9Qt77fG+qfO0O+7SZ7Ws7HJ36jKWLBo8TVZlE0g94x1S7jxHZmX4ElcJMNR92IxZVKfhK/Ep51faSclZD6eUQ3Xs1NQiCStWoSHIlrV17Wvs5y4QbKrCRhEXyDOgCYj61b4keR5J5t6vlNDz/fQ0PM9MvR8SQ1sQ8+3a+j59gw9376h5zsw9HyHhp7vyNDzHRt6vhNDz3fe0PNdMPR8Fw09nzP0fMHQ89WGnu+Soee7bOj5rhh6vquGnu+aoee7buj5bhh6vpuGnu+Woee7bej5oqHnu2Po+e4aer6fNu1jSVwn1VdUvKq8cvQvMhmGHInYUxhrET6NHoHZ5TXLuiYolS1+qe7rxVPbk3tZeAmu0NbOsXzqrCJmUOsjRxRSBswgT/An05WFbonBiWIGMcYsK1ZrrBLPV3e+HBEZDlkxkGeJTjkTaVBMa/IsYk6ZajpakWWkJYkr+lmzCtAqyb0sXGyalmjHSilbcs5IGGhGqnAUMGhZ3stAjr1TQld8aAvqivUQmHQs4myWfY8ag582gwf46VvufdS+nz5Dv3/GlvdbY/0zZuj3vWlMHkvXkaMHVE+G5s3yPgeCZBGVBVtx1N9RS53yiM8xabrJtgPxEHH0mCu3M3l93mr/aQPBDu2PeMOpEfhJ42WN6/AjFgMN1NOmQnew0T7qyjt+nuPY8IGsrqQ2t6F/PDX0jw8N/eMjQ/+YPuNyM/+4a+gf9wz9476hfzww9I+Hhv7xyNA/Hhv6xxND/3je0D9eMPSPFw39ozP0j8HQP9aG/vGSoX+8bOgfrxj6x6uG/vGaoX+8bugfbxj6x5uG/vGWoX+8begfo6F/vGPoH+8a+sd7hv7xZ07b1RAHacjQNiT+pueXiepj4VrWMSOln3GqqDAQYcnhEYvJiCPFKAX2bXoPdoJ9wZJtJOb6nBidETZLanIs86xvy5b8lfcduYk5wdrvM4IP4blTy1kUU//o0Gk1KpeyYal7IfJn0YaFiCxoHdZTj2plzlHvzPyQE5hLFBErCAFNz5Nr8KSkyBNjniEAkYbOZ11ZDUzPklhQqlNdwQktqHSOBMaaQMTkQHIQ9Xsdw9pPaAx+5gx+4mdtuY9S+37WDP3+2Vveb431z56h3/ena7mOujMPEgJ1g3ur5H7QHzVqHIlMSus7jAMLmPWNzWsiq7PTTVCpJPK/ncnr81faiTctUcq6b+LgyUbYIIATebnKQDFZLHTnHYJZVrVYlIHvCi1qDC2As4h1eg/2Db3oqaEXfWjoRR8ZetFkb+eGXnTX0IvuGXrRfUMvemDoRQ8NveiRoRc9NvSiJ4Ze9LyhF71g6EUvGnpRZ+hFg6EXrQ296CVDL3rZ0IteMfSiVw296DVDL3rd0IveMPSiNw296C1DL3rb0ItGQy96x9CL3jX0ovcMveh9Qy/6c6bt0j3tPUsQT5qNFCwZzoG6x4gE4JdzVhCVw4Lsy5yhksnyHRjFgODo2ryJ6X35M0JhVkX0Ap3IySOs4ELlTIRGyXqvx0xPMa1YucQHR6KkxuJHzOFYI2mnXrQlxGE7s0HRqRuVwH2ZFa3sJMuenmdBUyIwJL7vCkUkwnRk6oy0LX12cDMSeHWnGj90degY8BDpWTfo6sKR7NNz8BLlmGGzMzz04OlKj1MlVs2yf1Vj8HNm8CY/d8s9mdr3c2fo98/b8n5rrH/eDP1+NvEsqEPyaTmSA7B1NaGXZE8+dhgOWFONV5TJGFnuuWJyhsSrKHeO1O/rcmfy+oLV/pP+a9eMUSX+tiZSo5NLV6PnWdi012UIpcZ7vqskdeK6yrZAzyqEEFOSWuaGvvbU0Nc+NPS1jwx9bXJPyw197a6hr90z9LX7hr72wNDXHhr62iNDX3ts6GtPDH3teUNfe8HQ11409LXO0NcGQ19bG/raS4a+9rKhr71i6GuvGvraa4a+9rqhr71h6GtvGvraW4a+9rahr42GvvaOoa+9a+hr7xn62vuGvvZZQ1/786ft8kiltg2ZQwQVpYs15lFFl4KpPjah7MlmRGM1iwnSlugybHBwkpDE3fRZDa4uGTZWPsOSowJ8RD6MuNlyRFcwLASJgQSMgWSNehb54t6oJHbCY3Jv0uyDj9WmM0zGgHzSgQkYTUROdnrmHWm8zioOjqyufEGgrVjTudcp6dPrMsvWe9fXnlhakw4Gepsvdi4Sa4tKT+Ku+tgj33rfEgi7vO+bkFFvZdJ38+zR1Rj8/Bl8zi/Ycn+n9v2CGfr9C7e83xrrXzhDv5+b9pvMh4QqcrRsU7B0ifEl0ztkVe7JaKgRUgWOiHpqCVJCk3qClkPnxA64tDN5XVhpp0duoyQKx9rjNzBRtAfLQJKrC0JaRvYKehAlgKwi8SB6ZVRpqGRfmd6bdEOPfGrokR8aeuRHhh452aO7oUfeNfTIe4Yeed/QIx8YeuRDQ498ZOiRjw098omhRz5v6JEvGHrki4Ye2Rl65GDokWtDj3zJ0CNfNvTIVww98lVDj3zN0CNfN/TINww98k1Dj3zL0CPfNvTI0dAj3zH0yHcNPfI9Q49839AjP2vokZ8z9Mi/KFnbBBxt+R1YOpnv0SE1HrhFukYyc1S+4U9kd2zpgqP1A4K7Ya5FVliW1H6ZzU4psCqaYiG72oFyE7O0axt6RuxHSPU4z54UgnBudBPalnEmrdXBJc/vqMiALCzSR8eZcpL8sUGQt2iBQVetZkPetC2ZJWfc8Ot46oKVolvj6jZMU7/dUdoqONt5pWtnByJiq2d5VPzYUyAjL2HiW1SHd3oIo9ZHEVpCV1uDCWodw9ozaQx+0Qye6RdvuVdU+37xDP3+JVveb431L5mh3w+SfnctwglPg1fOJC0JKOg4dEOleybnYzbKMvcE04BMZM4X2oJfEPlZQGFn8vrClXZm2FY8sdc2DEx3FwfWdteQlxs9FrEo0D/IHgIi3075GUMyNs0io8hTuKT2u6HfPjX02w8N/fYjQ7+d1H439Nu7hn57z9Bv7xv67QNDv31o6LePDP32saHfPjH02+cN/fYFQ7990dBvO0O/HQz9dm3oty8Z+u3Lhn77iqHfvmrot68Z+u3rhn77hqHfvmnot28Z+u3bhn47GvrtO4Z++66h375n6LfvG/rtZw399nOGfvuBod/+pUkdS+I5l3DsPIVmT/W4H5mNuvIX40osQnSifZmDg0aXocgcRWYEFjXcNvHboSx6TnXI+hC6sax77HpL0CD9B7rSEHRJQHlFvGJuqO0Z8cJLntUM/tRvS7bnKG5mOgk1ZqzmHBRQc5piVRShIcN5CuQkw4pKdSXlgnYJUvpIq9Rvo9g41UQwIl7WqFFDTjWbrnYt0q3rZEWajtEsmPRIzCxnXL0vupZpuNiDau2/NAa/dAb/9cu23Heqfb9shn7/8i3vt8b6l8/Q7+eTXNEFlB5xGJVA8CanNTU5MsN5DropNgvDl3CzMi9GgjBLKbqoXSheLrzemby+aLX/pKlRazeLdUA7kxsBaVWZ9blTapNKz2vYFyiLLjgcYJXrybM9URt/mtwreEPvfmro3R8aevdHht49ue53Q+++a+jd9wy9+76hdz8w9O6Hht79yNC7Hxt69xND737e0LtfMPTuFw29uzP07sHQu9eG3v2SoXe/bOjdrxh696uG3v2aoXe/bujdbxh695uG3v2WoXe/bejdo6F3v2Po3e8aevd7ht79vqF3f9bQuz9n6N0fGHr35w29+6+Y9nFEornSl6Q2LT3ivkw6k5XZmvNjllgoyLBoLTx5zvsdK4pkPhZ5U1bJc36kCgviQRgJpAWmILQDAp8WlOhyp7s8Z40ahJr1eR28biHU1UyMSr+S1MobFihaKM8JoCgUNzQeH1A0EnQMTF5XcgoODc3cLHNCTeCrRyQ74YmFkdTde/J7FoLHfiBtCCt8Mja6m1HmSSIsmtH7LNC0QQakRNgSEBApus11pWNYezmNwa+Ywcv9yi33sGrfr5yh379qy/utsf5VM/T7hUSD5wWKX1qb5IMcRPcNeLcME4trr8uuI94PfohBVpdSek7GHWPVtVqlyXN+vni1/yhSFxvyXa7HIqNMS9YlaRk3TKglo+lG8CShIpIZXT/wH3wNa9m3xI2kVr4pBzg15AAPDTnAI0MOkNTKN+QAu4YcYM+QA+wbcoADQw5waMgBjgw5wLEhBzgx5ADnDTnABUMOcNGQAzhDDhAMOUBtyAEuGXKAy4Yc4IohB7hqyAGuGXKA64Yc4IYhB7hpyAFuGXKA24YcIBpygDuGHOCuIQe4Z8gB7htygGcNOcBzhhzggSEHeN6QA7xgyAF+daIxW53yjJjalCxy2p91VRWLURHDl3ruUqaKPH3CmNO5wYdYkJMZ+6wbkuvKKyQc1X89t4mavYRFgaj2qALSvO5WhsLLcBES70ODVGlIdcgBEiRBo0hq+D72zUA8JuCyYrQJuGxayv8Ir5rJzmAFPQm4kEpHPA+lJzk0sRxQQSVC5l3JOLJ8mJ+8SgRklTkCBLqGr+gRsSgo2gcR8Jmvau0OIKogVchNOZG40zGsfaHG4FfP4At/zZb7YbXv18zQ71+75f3WWP/aGfr94jTGIN2JjXms+9xrO3xZkroIUbiOQRvl20DQblqS9YjGg/dRwR9IboMHshXJs58urrQzw4kj2bUbpoo9Vs8TL4hnDWumJ9FXbdc3eFLIQkF4RwJgcHq8exvLDoebXle+GVM4NWQKDw2ZwiNDppDU8DdkCruGTGHPkCnsGzKFA0OmcGjIFI4MmcKxIVM4MWQK5w2ZwgVDpnDRkCk4Q6YQDJlCbcgULhkyhcuGTOGKIVO4asgUrhkyheuGTOGGIVO4acgUbhkyhduGTCEaMoU7hkzhriFTuGfIFO4bMoVnDZnCc4ZM4YEhU3jekCm8YMgUXjRkCr8u6aO21bc1Y0RfWfmI+aoj66Dn2r5FANWOoDTqNs1M4VY3dRtaRWEmIfEluS7AtTnyjv/w8KNUwMC4EoMVyzLhAML7oLRKI1hZmHYmHeQiwzYwuMm96nxOMo86Qww4v1prJzPKOcf/ZB0TvZLPyIipfuQ8IHSKNqDGPDOfoJDsLSCSI0oYrFoeC9HrCk/KZ/4PCJ6uQPig77S/ggGux1DmyCWmrC4VYGh1DGuPqTH4dTN4zF+/5d5a7fv1M/T7N2x5vzXWv2GGfr+UeM+myDHgZCaH5NcsBw22BFemNnKH1dMUnRIrbrlZ5OkuuKIlofM76T3Yv2SlnR4XJ2LXK7pyPDK/p6ks8tqP4oNDi0fKGzRZqds9khX72mPOez0BoUjuVbcpnzg15BMPDfnEI0M+kewt2JBP7BryiT1DPrFvyCcODPnEoSGfODLkE8eGfOLEkE+cN+QTFwz5xEVDPuEM+UQw5BO1IZ+4ZMgnLhvyiSuGfOKqIZ+4ZsgnrhvyiRuGfOKmIZ+4ZcgnbhvyiWjIJ+4Y8om7hnziniGfuG/IJ5415BPPGfKJB4Z84nlDPvGCIZ940ZBPvGTIJ37jtF1Ygd7poW2R1FA5svYQUGmcrKJlnQxN1el+9W1NjEdRE6xLUkRf0P+WJJlc+xBb4sFYNxlqL3Pkt6A01+AYauJEGDkBMSf0tygqhog5otk9NKQbUlX6jDhXEW11S3+iO9m1LZuc2FjrKXAINjfWxBGPBxp1QUPGeSX8OoUgRGKXFSt7HgrOERGl0MPYKx896ZVI2GmNM7s6XEuDNkFZuRGbQIxDUHhOe638omNY+1WNwW+cwa/+pi336Wrfb5qh3795y/utsf7NM/T75WlMbkbW8dDjoaumiNKXwZEbyfMVRyVMlwQs8jdJlpCFmHIDi8zpDiAVa3Zn8vrSlXZ6EktDjmGNDChIjyKJIWuJthKv2CjMMK6k7YmxxO+OdmPidcNNFm5Wtsl9AjdkHaeGrOOhIet4ZMg6knvpb8g6dg1Zx54h69g3ZB0Hhqzj0JB1HBmyjmND1nFiyDrOG7KOC4as46Ih63CGrCMYso7akHVcMmQdlw1ZxxVD1nHVkHVcM2Qd1w1Zxw1D1nHTkHXcMmQdtw1ZRzRkHXcMWcddQ9Zxz5B13DdkHc8aso7nDFnHA0PW8bwh63jBkHW8aMg6XjJkHS8bso7fkuQO/E4Z67IotTEcxxPJJtkQJPJCU6BByBFoIO10GLOOOEIY0u0QGXW6s/JMhNr70RHeB9YtKoCha/Oav+kKjg4fhKiLPVGaceSMdxJSLCHfo1+IuNP9Ez3hF0FVDwjVGhfCSS7xCXAJFnX0evoZegnRQ8ZukeoFoaxmdeM9ygq9Nz0W5xbXg17NycgcSRe1MyF8S9TyQc8ELzgMhqoqfYY/iHpEBINUO+JruXiemrX31Rj8lhm872/dcs+v9v3WGfr927a83xrr3zZDv19JPEtWE/5zoumo3UehZQF7vHTAefaZH3wZIm8FUmGfjywSMGSjDIsUJ6HsTF5f9mHtdEhxYmiOFhWGzAOyoYjIk0BuQkGQgvDjLRgAT4VhQFhEPaaEkNi65PqOTbnJqSE3eWjITR4ZcpPk+o4NucmuITfZM+Qm+4bc5MCQmxwacpMjQ25ybMhNTgy5yXlDbnLBkJtcNOQmzpCbBENuUhtyk0uG3OSyITe5YshNrhpyk2uG3OS6ITe5YchNbhpyk1uG3OS2ITeJhtzkjiE3uWvITe4ZcpP7htzkWUNu8pwhN3lgyE2eN+QmLxhykxcNuclLhtzkZUNu8oohN/ntyfwizyFzgu5ASbIhlxYgEqIfA0yHPHO3CMo7ZSzbthl7hhxp29Nqj6hM9ohIdbaeiOnIf0zB1jmWb4VHYObWme6RSbQh8KrbuR7niB3DTEBkqtAl98XIUCsoZh9DQbCHtjiyYa1r+5GaDbJX0q1G17RZ1WTlAO8YyWYkGIIaszbZI5Iz6sRD55ByBSmMo5Sx6KmMt4wdHc7cKDNV0LCyrBmVFgHW686hOYJNx7D20RqD3z6Dj/4dW84P1L7fMUO/f+eW91tj/Ttn6Per0xgTULO4qCDVHcQrCbVQQq/rVXBUuvVNG1DErMGK3AQHJfD2xFMEMEt8Z/JyH9Z/RCNr2w91hQQhDte6XU4/skxhi+QlrHLURXA9+hIPXOmSs5awj4sahnHKTTZlMKeGDOahIYN5ZMhg0vtibMZgdg0ZzJ4hg9k3ZDAHhgzm0JDBHBkymGNDBnNiyGDOGzKYC4YM5qIhg3GGDCYYMpjakMFcMmQwlw0ZzBVDBnPVkMFcM2Qw1w0ZzA1DBnPTkMHcMmQwtw0ZTDRkMHcMGcxdQwZzz5DB3DdkMM8aMpjnDBnMA0MG87whg3nBkMG8aMhgXjJkMC8bMphXDBnMq4YM5nclc0InusWOsQYlInTbj4g9wKQE4mKhCN+iwtBweR0LIiBNdkpBaIShSxhMEdHYhAhmzUDTHW2XyHXYqg41g7IkybKeRUMwc7g/oieaFUHpo8/T63Qk5ppuBAGRM/qOjFxgpWq+HdEVGH8ZmIBuKZp+RC0w/7EVPU5AnCdhMB6BEAkMTYH248Ook4hxQdF3HJR0VErZD8wdfrHDE7GuXYluYsUzw3UMa0+uMfhdM3jy373lLELt+90z9Pv3bHm/Nda/Z4Z+v5Z69cVTeEixRYaZIlRBNsmzhPOujaESRMCU6XbDOFCYB0liWITUiHlIni+arfYfOY+/ZBGhyHXDU8firFpxDqQAKacnN5IkCOAlQopOELYDEgOpjfIYknuTbshzTg15zkNDnvPIkOck1+lsyHN2DXnOniHP2TfkOQeGPOfQkOccGfKcY0Oec2LIc84b8pwLhjznoiHPcYY8JxjynNqQ51wy5DmXDXnOFUOec9WQ51wz5DnXDXnODUOec9OQ59wy5Dm3DXlONOQ5dwx5zl1DnnPPkOfcN+Q5zxrynOcMec4DQ57zvCHPecGQ57xoyHNeMuQ5LxvynFcMec6rhjznNUOe83un41iRiAibHKRl+fuyL3UJEo4BaZhBU1jxiKCRxrVD5yJWoED7DF7GC6mTPmsGNdTir0hnnHsmaeMDkRAPgSAMTAPH+SFt0jvUasEXkGMROujOMetSngN3oS/MJtQtopm1kuvqCl3a5LJxlILGKyIAiopIzl8QOS6Uue7g0hF4pjyHMe6YPUzRKlRjJTFBvMN1RM16zmSVV2VECvYMTYflYlBK1BTHbOiyjmHt7zUGv3cGf//7tpxrqH2/b4Z+//4t77fG+vfP0O/XpzHGox3cgAkjjWak7MXdX+VMlKo8E5+E1kvAIxkcKzDgarq2bMCgGN/kmbN+tf+00ld1K/WHPsJb4bUgqQMmEV2CiEZYt/QAldESQvKG7MCBRwlhAG/CczZkQ6eGbOihIRt6ZMiGkvvCbsiGdg3Z0J4hG9o3ZEMHhmzo0JANHRmyoWNDNnRiyIbOG7KhC4Zs6KIhG3KGbCgYsqHakA1dMmRDyX1XNmRDVwzZ0FVDNnTNkA1dN2RDNwzZ0E1DNnTLkA3dNmRD0ZAN3TFkQ3cN2dA9QzZ035ANPWvIhp4zZEMPDNnQ84Zs6AVDNvSiIRt6yZANvWzIhl4xZEOvGrKh1wzZ0OuGbOgPJOPIKsxRdJyPgVSZSX+XTNy2RGFUVVFj1DAk3il74iswmI6zWZK4sDzp9VbeNVXJSq4VMDEKZc6CypHwQz6iSEixzF0yC39zhMOoDF4iYqq2xUQl96nBOlYdJo7fa4qiqEjcfVUSx7RNSJgICVIzMAwckc93wbVt11U430UoTJ8ZpGyqkWM9y5LSKiJUlYXMM5OI225UDhmVY1u5IdqOxCC2EEg4yTqGNSvQGPyBGVjBH9xyRqL2/cEZ+v2HtrzfGus/NEO/3z1dyx4lkqNAkW+4T1IC8h23ggREIbY4g1bJg/XRDb6OFTLdRdISOgrnVvY7k1e+2v+A3luYqA7jC6VtmqyV7SSVI98CwYx3SBqoC5ZSIECPxDF0JLDADXnChjbkTKeGnOmhIWd6ZMiZEja0IWfaNeRMe4acad+QMx0YcqZDQ850ZMiZjg0504khZzpvyJkuGHKmi4acyRlypmDImWpDznTJkDNdNuRMVww501VDznTNkDNdN+RMNww5001DznTLkDPdNuRM0ZAz3THkTHcNOdM9Q85035AzPWvImZ4z5EwPDDnT84ac6QVDzvSiIWd6yZAzvWzImV4x5EyvGnKm1ww50+uGnOndhpzpDyfrsQ89sXWsWZnokZ4pMRB2EOMxIqcxEqxV30hl5nI2zHo+h6csKnRtm3CmUPu2R75halFTjaZHRTBDmDCesciJC6RDGY1cd1wue+Y1Aio0HWOJH5juGwL5+LLB2nKGm1CM9KhhFRLtY2Au1KjNzil70bmMRYNtxNJqi5SXxks4Uxa98t8Ig5L+lECjd+R7dE4VoWOt7DFDNKDZ8QLwNERkxIqgt8tCx7DmDhqDPzwDd/gjW85b1L4/MkO//+iW91tj/Udn6Pd7pmuZfMeHY8Bdk8CQVQ4lofjmqq7P46DNgErihLqqQjqEFj+FlcGSZmXKmcJKO72XyYHtRhwazqNyue5Bjo/1NCbPSEi6nDRU8A7idVZjwQPaLCA3ClJcypk2Y1anhszqoSGzemTIrHaesWNWu4bMas+QWe0bMqsDQ2Z1aMisjgyZ1bEhszoxZFbnDZnVBUNmddGQWTlDZhUMmVVtyKwuGTKry4bM6oohs7pqyKyuGTKr64bM6oYhs7ppyKxuGTKr24bMKhoyqzuGzOquIbO6Z8is7hsyq2cNmdVzhszqgSGzet6QWb1gyKxeNGRWLxkyq5cNmdUrhszqVUNm9Zohs3rdkFm925BZvceQWf2xJBYicmgweaVpOPttzvIfWERdPrLsu9IVSIjO6yI4kgdKELfLEu2ZrC1nMHmGV6HwwCwn3GNwCiY41KdkfTiCS40iboeq1PU6dTFoshdd1+GdHPo3I9MkzKpvyPsFJxYhVlXSMsjBoms5tbGMJfOWNURiKiut8rEmcXYNAta3BDlc1pSl9bSVYIwoZMkQyUPfgeFKznqLXUY0OOhbHDXPyf+R2IFrI8cgW0tsnY5hzTA0Bn9sBobxx7ec3ah9f3yGfv+JLe+3xvpPzNDv905jTCxYRG5gahfoi9aJKhUBB4qGLsgMPdrdw2IbUO2ox5g7XW5adE4bGIvl7acXr2KlnSxsREdAcyuJ4gCLvBGgKmMtEQDFYeUBgXAUZSGf0yjZkZh0H3sQWvIMrw3516kh/3poyL8eGfKv5F7UG/KvXUP+tWfIv/YN+deBIf86NORfR4b869iQf50Y8q/zhvzrgiH/umjIv5wh/wqG/Ks25F+XDPnXZUP+dcWQf1015F/XDPnXdUP+dcOQf9005F+3DPnXbUP+FQ351x1D/nXXkH/dM+Rf9w3517OG/Os5Q/71wJB/PW/Iv14w5F8vGvKvlwz518uG/OsVQ/71qiH/es2Qf71uyL/ebci/3mPIv95ryL/+5LRdyoPaklWWqJEsxwdoXvkxY7YTqtsQIWDYUCkUTENg5g9IIyQOymNI+VdgipOFyx5DBgwjiQlGZS0Tn/iDNyddIKZx3IhMPUgE6zuiq0iAi9SXsDSkCPqgalvEU8vK6YuQOdZwxf+vHKexoAGjHirFdMWfonSIPHyyyhnI9D7gnKsi9z0h18UCX9URyVpcByemYjnoBlichBqhW2BuasJqS8pGAeSsx8X9ka15iMbgT87AQ/7UlnMgte9PzdDvP73l/dZY/+kZ+v2+JOdro2GE0EAZWMYIeSBvRTqrMRe6MBds0w5jWyAYka8NYqCvui461hRMeGfyKlfayZd6qQ9WGpJjCMhvFzIiGUG6I1Z04l/aCCmzRT5Cv/kaP8LPe6nvhH9tyNJODVnaQ0OW9siQpSX8a0OWtmvI0vYMWdq+IUs7MGRph4Ys7ciQpR0bsrQTQ5Z23pClXTBkaRcNWZozZGnBkKXVhiztkiFLu2zI0q4YsrSrhiztmiFLu27I0m4YsrSbhiztliFLu23I0qIhS7tjyNLuGrK0e4Ys7b4hS3vWkKU9Z8jSHhiytOcNWdoLhiztRUOW9pIhS3vZkKW9YsjSXjVkaa8ZsrTXDVnauw1Z2nsMWdp7DVna+wxZ2p+Z9hGtTf6nOy1iJwRxqwFW5VG/OIXeFZgb5rFXn0LL6XeuZyKRA0bNiXQvWc58amFZKAGP1mtZ5BX4DUzHW2R8znzTA8jGCtEC94qeXDCQRhvdJGvK0tC+fc16wQ1zkKFE3LuSj0eyZkOAZEBIoV30iBsEN0cCi6Hai0w3kR/S+2wNEYFfYCVaBRka4zoXmbBFRuCuIwssJyyKHOYMLqof8ddVJfIEp+4XjxezZisagz8zA1v5s1vOlNS+PztDv//clvdbY/3nZuj3+6cxRs7OYxAwEE3VNOQLTDtpHv2MBixHLXUcJCIE5CQjq9vSQaIaVkZ0yV6yaqWdyKy+kabHPQluDfkAjECVxoA0wAsP+PQB6lKRZFhCDSzPK6ORAcnL2ZSlbcrlTg253ENDLvfIkMslLG1DLrdryOX2DLncviGXOzDkcoeGXO7IkMsdG3K5E0Mud96Qy10w5HIXDbmcM+RywZDL1YZc7pIhl7tsyOWuGHK5q4Zc7pohl7tuyOVuGHK5m4Zc7pYhl7ttyOWiIZe7Y8jl7hpyuXuGXO6+IZd71pDLPWfI5R4YcrnnDbncC4Zc7kVDLveSIZd72ZDLvWLI5V415HKvGXK51w253LsNudx7DLncew253PsMudz7Dbncn5+2K7qKj9O9DMsmOqU7gPWKyyRmFBKzJWuz0iE1ERmch575kIHrlOJ9+mzErmuRC5wIFC0tIbdkLHcCGqeLuDW0nau1ljAGqJagKzSZsQ0eCgkVmmSPG57FR0IRX4N0EjkbiMZl1REka86gZDkuoUWW48HxLTmxMnZk0SLis5JrPPFkWAwycxN0qzOmI1OWON23keFn5JE70bEehgGwgWtkRfEN/YBX5LzqGNacRmPw52fgNH9hy/mU2vcXZuj3X9zyfmus/+IM/f5AkitIInCNVmK2l9UfmiLrMIhlhzRpBCECEZnF0uSwj1abP4EFwmmIpGxn8qpX2rlgaYtbC5JzosRkAL3LxDZYDLJZI7pH4MAq+rbDHZQZpq3KwGnonCLZ47Yh4zs1ZHwPDRnfI0PGl3K5zRjfriHj2zNkfPuGjO/AkPEdGjK+I0PGd2zI+E4MGd95Q8Z3wZDxXTRkfM6Q8QVDxlcbMr5LhozvsiHju2LI+K4aMr5rhozvuiHju2HI+G4aMr5bhozvtiHji4aM744h47tryPjuGTK++4aM71lDxvecIeN7YMj4njdkfC8YMr4XDRnfS4aM72VDxveKIeN71ZDxvWbI+F43ZHzvNmR87zFkfO81ZHzvM2R87zdkfB8wZHx/aTqOcDuSQgy6krUqGNZhqIBktdJJwMV25HRGA+oXSDPMFTJz1rNKER7F2CR774iPriMD0hLyEV6byM4p6jJ0aoUjIwmzXJuiqMGAeAB0Ir4HZQ5JJBMkz7hkxTQtMgceB9JzaA4Cu4Q9SUBrKtODC9AXi6DGgkDP8mXRQTM8sTPZe9cRtVEHBUaupoNwjRH/T/TH54cgz8jJ6tGuYiJ5IaWvk8hJHaGCrY5hzXw0Bn9pBubzl7ecdal9f3mGfv+VLe+3xvqvzNDvb0r8D7isFTfyMO2KPOazjuPGAgcrKdk3wB2UTItZQKHq1m5kNcwVHjvUS6y3eDUr7YS352RUzFjI81q3P3TKGr5ZPMLD0SKiJPIaT0uKZ7Gz+Imco6Aj3rz5sL13G/DCU0Ne+NCQFz4y5IXJMy435IW7hrxwz5AX7hvywgNDXnhoyAuPDHnhsSEvPDHkhecNeeEFQ1540ZAXOkNeGAx5YW3ICy8Z8sLLhrzwiiEvvGrIC68Z8sLrhrzwhiEvvGnIC28Z8sLbhrwwGvLCO4a88K4hL7xnyAvvG/LCZw154XOGvPCBIS983pAXvmDIC1805IUvGfLClw154SuGvPBVQ174miEvfN2QF77bkBe+x5AXvteQF77PkBe+35AXfsCQF36TIS/8q9M+YujCgFLLWhZulhOgY1EOet5DM6Ja+45MDB5Azi2Ueytt7iGIuE7mRpXwQmIK8qXmjBKsMe5xYfJYWi2IAltLc6EYQ8SH1z4nyBGdCeZtUTMpQp7sCWxGpRjW4IA6pgcwwzKOeg4q4hnZihVeXE5bsR4x0rmUIZEO5VouUvuUF8rxgQIx+wGC0vXaBSkvk6OKPCo2MsxOGh9/32OCsEtVHpFXTCbe1jGs+ZHG4K/OwI/+2pZzM7Xvr83Q77++5f3WWP/1Gfr9zYn/gc4PJLGOsExEbp2jEICDJqYOUoLdoIg2kDtYcAjngqBUAiJwHeSPYWfy+vKVdvomuKYVvyEx99goVywS7FgOEUPgtaM44wvE0LTXsMMBwDpIoY4k7l26J3Az9nhqyB4fGrLHR4bsMeGFG7LHXUP2uGfIHvcN2eOBIXs8NGSPR4bs8diQPZ4YssfzhuzxgiF7vGjIHp0hewyG7LE2ZI+XDNnjZUP2eMWQPV41ZI/XDNnjdUP2eMOQPd40ZI+3DNnjbUP2GA3Z4x1D9njXkD3eM2SP9w3Z47OG7PE5Q/b4wJA9Pm/IHl8wZI8vGrLHlwzZ48uG7PEVQ/b4qiF7fM2QPb5uyB7fbcge32PIHt9ryB7fZ8ge32/IHj9gyB6/yZA9frMhe/wb03aNuNCy17W4DHhdc+4UXvGdDKaTC83JRKxrHJIuEMZblEWGjA+O5Ti6hD3qQ50UCR2s0bxdPQSE60AvQk2AQp0isxpAAsY0IgmQoTkTGQuA2xkS9ojtRy0NnWiCQx0TQGEbetZG5roOU4QxJqmjCTEdUh8agFxPHIi6lji5Hplkjwtj4PkVXeSM861J4ZihKh+JY3QqtIuhJHdEAg+0s8cTEloJ052OYc2iNAZ/YwYW9Te3nMGpfX9zhn7/rS3vt8b6b83Q72+ZruVhwUDINcR3KWsfewlLzCxhi/U8oAE68F4usE5C8S0fgQPoymU80M7k9RWr/W9L0X9cDOu20Y0081ChCIou1tgNrDXmT0vIEbcwTC62AMVR/1+sb0zY44Yc89SQYz405JiPDDnmzjN2HHPXkGPuGXLMfUOOeWDIMQ8NOeaRIcc8NuSYJ4Yc87whx7xgyDEvGnJMZ8gxgyHHrA055iVDjnnZkGNeMeSYVw055jVDjnndkGPeMOSYNw055i1DjnnbkGNGQ455x5Bj3jXkmPcMOeZ9Q475rCHHfM6QYz4w5JjPG3LMFww55ouGHPMlQ475siHHfMWQY75qyDFfM+SYrxtyzHcbcsz3GHLM9xpyzPcZcsz3G3LMDxhyzG8y5JjfbMgxv8WQY/7taR9HzgaqDP5HnA5EExBAxmJCl/cRjIcBcHAIRhHPIGXMm3XuiQUYjDF9dnDsK4dS5QMMUNW1ZSuZmmXEqVH3USQYO13InRGsiJFFR871cBF6Xge+e7rvMY91ixclnkQW3YhzCVldy0rxH6mGuKhcMCoV9CNgRXIBGSXBgR5IOCZBmDDoZU8yH1hFZUtnIA0IaAQTgQbjSEBkcuQoc3zWQMgdiJfInGaWPZQag789A9f6O1vO89S+vzNDv//ulvdbY/13Z+j330v9osoOEcfbIAfJzZB+YnypCe8Al2gj3cy0gfh1OfQH04JZG5F72KJs3Jm8Lq20MyO9kgIHKEYPOKyRokgYAB9rkYgo/tK7IkO2Y0bIToRGBJsIJvAJQjDlmJsy0VNDJvrQkIk+MmSiyR7KDZnoriET3TNkovuGTPTAkIkeGjLRI0MmemzIRE8Mmeh5QyZ6wZCJXjRkos6QiQZDJlobMtFLhkz0siETvWLIRK8aMtFrhkz0uiETvWHIRG8aMtFbhkz0tiETjYZM9I4hE71ryETvGTLR+4ZM9FlDJvqcIRN9YMhEnzdkoi8YMtEXDZnoS4ZM9GVDJvqKIRN91ZCJvmbIRF83ZKLvNmSi7zFkou81ZKLvM2Si7zdkoh8wZKLfZMhEv9mQiX6LIRP9e4ZM9O8n8asjfnm4RahQzCzs3tPTLLjFhddd3hFBdC+7qkMHczZGnZRm8IF4RLpNnjXD8PVBKRC5WoUKExaQzDnWAFeJWCVoEdAYkLbh3ImRdlhQcgiJhsWS3IdSWHbsR36x0A31WDqIpq72GLqckDuOENMM58dJhzwMTQFBYZmNeADWdt8lz61R1kAHVJi9XAoQ24O4wgJ6vphoOAI2MPAN8j9HHseqRiwPhPMoD6FjWDMyjcHfn4GR/YMtZ4Nq3z+Yod//cMv7rbH+hzP0+x8lOrAc5CByNDGBVuymiGhlkhjCPXe51h4hm2RaI84LbL/DfNTYx0yPn9mZvL5ypZ1+8KKXuHN8FTbetz2/RY0DC5HHEEbsEK4AFOW1VZyEqa3cBDa8L/ovYaKb8tVTQ7760JCvPjLkqx+2t3MDvrpryFf3DPnqviFfPTDkq4eGfPXIkK8eG/LVE0O+et6Qr14w5KsXDfmqM+SrwZCv1oZ89ZIhX71syFevGPLVq4Z89ZohX71uyFdvGPLVm4Z89ZYhX71tyFejIV+9Y8hX7xry1XuGfPW+IV991pCvPmfIVx8Y8tXnDfnqC4Z89UVDvvqSIV992ZCvvmLIV1815KuvGfLV1w356rsN+ep7DPnqew356vsM+er7DfnqBwz56jcZ8tVvNuSr32LIV/+eIV/9R4Z89R8nvrbBbYScOR5kzxgLUqnu+5cXmM8O64EeqwACKPVBR2amglqRX+XYxmTPqQdnIAEzoltelkrHsWyJY5AGWGaGkCUt9gImqCAQBVhlCGQ/z5JvMg6X7BPlHPZdQEJDctA6hAgO0uhpJfBdRC9Sq4nYxVqBAh3DnK0BowhHiE+X3rczgGGjYnQWNIF8BLFi6EmP2BWmCcK+BuM2Op3kIsfB0IUujg1isdcxrHmbxuAfz8Db/smWc0a175/M0O9/atzv5WuVM2a6l6vrvRIidobmkeGQP8juiEoIAEe8R4GfRYyRQlr+Rn4dCSMoqjp9pnW2uItslGjM27xQiCOEVrEQUQpoeYXoEKvQKZli6on21DsIY3y475O9l0UOjgRrkAVlfBGlSFUAD1YBreW0HdUvIEmDUe/0gKyIoi4HD19DCyTXkPtAkl/IUvghawC246lD6F679FoPyFJ4qjkT+ORc641QjW4lXgZczZQzgq+gfkBPdH8l7qXb63JM1uBISQc/hn+HIlWh6JGtOGe8P0fCEeLPYrr3UvfeiDj/EqeOFe7wpQOOpEa0YJ5alLwcLUkavkHAJaznWvhe98qospA874bsUITK41w7FYGguYMgXAk9i2QyIjKpqicy4woKtH5ZkB0RchCOHseecEaRSJJe4DfAvTIBCEw0EGYfOUHwwdvrcel4Kz3zrGWSAD4wkGWEsY4JZ0QURRWW0AjQxYIAR6bAlnUjOhfrxbFHfBOkpGCegOGABzQbcaZRTzkjuhDfAdJEV5NfXeUAiBXCsIb4oB9r/kWIjg32BaUfm4Z81oOR24z8mTzvhoIbs7tjliE4M+g68C+HV+XMErRUS+omPHOaYUVVEahU9eh9eUZPlqvTZ1pX0I4WDMZp8wC0AiVUoOaZ1lXmdGNZTmLFfBvhRB08IJAxyZOo34KBDskzrUlPaCan/ILLDIQL8GrNklHaQU63rmwQYwQKZnBLRSETIJe3jwofCWdkziPhmTClb4NMBOSoZwhYhvAg3TDGI7trR9OZsZQxlIrIdOhWPpunz7shg5A/mV4NiwXtU+U0ZWC4cJbgQgqaCHxcg3rgSGSswzBQTVRJL0v3XkIR8a+EBvQeXoCzC1OUWKoVjgY6BZNt8QJIp47eM5C8lZdMPC2tZO8lsJRT7yqdqqKGvWVeYAJ4E4gePXUHVmSIC+KFsMd24AhY2Ix8CexK916STNHNqElWgHyYNrLDudAtXVtqvhDc8ASohUI0ErwYR8Q8aX+gOptcQw44LeUsHdIBhwRS7cXIdRcQelPgMjS+juWuKS9l3hcZwbJH6+cx2XtJ58StMNcN44gNJKqEgdTPtGPaRv6HEuCnunnPSIkXbkJ6qXQXHeZcnnJG6j8IARh4JyyOcMSnqGi1qHdQRvK6MAblgXcpcpkHJjyBp4S/NmWecMYaWEsOk3OAWzvUNVN+BHMxKZkLLFP4I6hTJG0Y+94LkTuteS3M5P6VjDg6mGII6UY3VoerotQHIhgqS5VoNDfiCYmMwkTfMCYQtE5rFEs8JM+0pgcFfeLUF1S8GmAvkpSoiUquVO/q4cRget3/uUZdt5hY8CDwDDuP6U6vIQdIucLjvInP2PRWNoIPZjW2WqUJsHyLKETLo9nagsqVJ3xTl4fXkkqTvZei2HhOPRCSHMv6ZWUMUnyVViTnjGQt8kJnKQ5QQWTGIlLBBDjsIU+uIceQVgwLH6v9B5dSzJmwJSe2lQitiDj4+NhjKKgzVQRG8hFBX2h09AlnpPIAfq20Bp0SDZm/7ck5LPm+q5lifQ0BQF0W5Owqg3mQiGD4cPjG9WWy9zJrULPoW8AT8S3AGSCcSFRVLMnxaB/iLXkjz6XRBcSgvYyIindgsYQzwu8g03UfiH2EHf7hR4pfNf4Ywk2U6XS7esgNTL/R1oWKLMSsHhcJzyX3rxyER4gplGic7qmVw/kptrX8ak1qww+0IZAUmNEjFTUmYqFNFOKhFCzSvZf1CPyjzNtnnVxxRqaHuDAH2mZxRRrmkM7jM6g+lU7ri5or9lFcjTptsvcSqYRC4tsGyhGFJjXEaqB8R/jCeVXkWzi4BhbSSgjCqGLZWZbwaATVvTR3gA6US33X14rOebUgXsTRkXWMM6R+6EfiPKMGKWMt1WovpwKF5JJryCk0y6kAn2EqpKlGYS8utqaMOCacCQtsAPAgyqDO1GEwoixVwlcGoUo5Y1/DPKhZRBCco8LIXAOOABQ7AjJeKOgxqxnAfGROETWgWRSf65pCCagg4Yx5Sb4Tbqgbj+/EpRLhKTzSZYSAwj0uyumKwowVhckiP+Kd+VetZxYk96+E2wboFtXwqMZBituWZUl1o6YZVPoIzQQ4Erf4SianyIuY28Ll0/tXMidAFQwy85Koo308rCJSPXTWE19Aq4hDZihhhGyJpWS54gIoq5Bl6uR5N3weVDOSOrH5lIlVgh3QTgTZoUWEMNGcmKEWNlUPpHUxys1GCaGhHBLOqLpUtij6McnzhW3POQ+0kdM/CM5h1al4QVyY1qhEwFcBiuaLtWfnpbSuxGwEzgt8FprfUvEFRbkGMkYBkhEblC8qDOmoIjVEUDenY20TtIfkeTecjUKRlMEHhDExiXJEgIFYW6D+mORAaWhVRinLRRQrEYVzT5SjMplXyd5L4CPwlzFxtSpI1Psj7hsEKrXFqiAAwdJIwSyYVkCultdHrALvmPevpnUS7JCDl1KEzeQXqHKRCKE3LBlUNwve4dkB75TfqKuT9CrpqJaPIK+SvZcwM5HMCAcRyycngB860W+EFLGLBYRgxWEhdnGFqktXBXiIYQY3JteQY+sRjcLdBdUd3ZvPtaqURsgRKgIyWHpBQjgX0q1v0YcAgVx7tMDyYUyfdxOg66REWD0pkQHT/yOCgRlYN1peHRNKcYZKhewcIo5uAmjBQF1MOCPqT/XiykWgGZSfJnKSK10Ii+mlroByhapz2lQXcgyiyDhnvyoIFUVyDXnHWiYnU31qqoY1DoOnYRDxAvOpjWJUklV0LkUw5SyLZgF44Hkt1CThjFSKgJ04b49Wc+jtWhV54B40pC/0NIgFqqLhpcquJfCSbEScw4GxppJryAvtjGGpqH0U3KD25EHWSBC2Z8UzodoBGYakpNxXqXzJtJbyQQUWZcIZB2Ae9gZPBzCKSGHcF26L7ADCG4UZqSBQF8/KkuqzEJbqcFR+iRmkiOQ5uKiEAotY6t7pJCEiEIsWrseIRkVTcLpu6wh2DEQLkU8Fx5piG3Vz3yZ7L0umPTFC1pPWFSKdyDHWB06G/MobIF9WJ8myRxBRjy21epAgxMzKf0vCxL1qnSgOmoc4WeA3qqi4EOodrHUkEPEaa0Nq1M6QTNmON0ptc8zT605VvJEpiHAUWRVQGQPGecdNQ+MpvyJxI3GG4WSu8p2N/DIOhRxVZZac8Z8lmimUGB3WA2pbOqAdAlJFboRYpftx+gVEQBc3zEGSb4kFpVBORmJwQ3JtuxNyJs5TMOZIZBtWFbUkRD6hi9IXZ56zBuMLhFKKiRWFbdYvKx3myvx5V1J/Jr/iJKjOI4LFWDjfujCdIEPFHxiKFaKiN2quQd5VTFP4pdKA3MgTzugkTPm2jJqQo55OqsIIU5QeFo9GIT+R+skSHJMhb4j1ZU9AjdoQV2ez7OPUGPyzGXjbP99yzqj2/fMZ+v0vvo84o2M+omDITZTDMu1+QIiSBjPgBCYj6IaXAVlT9ygs4sMI3661KTHH5qCWkv2MSMQiaG9Th2hgVo+6+awe3kM6Rd/0EUMN0xRiXBgV1pZcFbaaMqIbppwxx6KQCPGtALp2ZL2iTBGpuDqMhfZCIjzgbbqPLlJX4R6QjzZYaLgi2c+Y6b4V1MVk+Ek6cLtCm1AWqp/VQeFtRNNIY1HuFNtfVAFDPWIhqDT45BpvdAv2iHpprRGl6IMB4jc7CuhETJxwrs1OlLEKyt/kxMD/MdheBavKJc/VRvdySkZwD2wHTYABxGEAK9uB9MGizRkAFfFqzj+plkIonSO7EL5i4XzCGQsgChKLfI8C1y7WtpemzZWNiSN6CjtDhnPEBeQieSCGinZX4D+q5MlzcnDMfMarODd02jxUIbB77LAyupe5LoFtALkRcas6ngoZNXIejEacS+5V6UtMRgcqoHTLKQWAdKpNo0wo8XQq646q22Xa6xBEo3FXzNkqR+KAjRPOSD7OZZRVXMO+sX60OZUTj4dB/uW6JbG4dS31SxkGukiLmWKkpizPU85IZ6DWsUEiQGwofTG5lPqqDKCAgqGWVOoB9Qj+UnvptW8WFoLYxU26o8T7IDoH7eMNBbgZCd2pgs+MIx2X+SCxC1fAxVA3LVthBBQ11Wlte8TLJJwR6k6RmQlEtodCBxIaCpUmYiJyFXaDhGAJJfLazEMOoAobsaqwLqqRyb0qOYvkE0r6eaY9QLWAFdUsfqYnN4OEqUgG5Rj8WkXBkKSFkpM80kULCWdUrkKxwGrIWQFV7SL5ElaDRsgpNiJAUKC5NkvCtz0VSNyQ9uoyBnjGhDNSfKZb4KsStEX/gEodYwQcDxXSC/SZZyp4s2SQNy2pV/JEm7EgiLQ4vca7ZyoyMuUI9q9UV8PEMhBYIGyhLyAeaFDX8iHUKTV+RKu2ZEL5WFB9whkXV0Rgux22DE6DLqXsgGjI60xFWQYNoNSgq7VWIdOZivUUCbSncEg5I/4OX+8WpAx302nng3SvwE8J8eSbaVwuUIM56FSIRX822lHqtZM2ucbbSwmgywFjTLJGe8ApQDC5SxUrR5ZFISqKfJZnU4lVgBCXxQpGNiacsZYNxgZAWKiNsNBcgBLkQEDmPY4paD9KqfnB6BF/ga9eLpe6LL7cX07mfUddARlV9iJI2nArh9JlnBpchQcKsshqOUREMy6KNoFCqE84TZzkXpVeWlJbSGQGBxAwlepMd2fOPakDo4wz1O56YD68aiRi4J46fCAhrEZ4Jtd4o9OwA7qahkBNQKSeBFsin7UZ4EZPZYQ3UqNdGJ9GIB+p1ErnR90XPdnPCCugjoxUjIQnSD/ldDwOjoIkRkohcyKYawEU2AhqPVMGBYnDQGhWkXLGCBhluWnJiT+XmJPGi7ngw1oa0GqnEDa3YI1VndqrWo92ipYwkeQab2CYFCzdAnaTwyhAOaUrbb9FjWreCt/pHkoykkwtSiv4yxabS8S4mdZciFiNEgFnghNHstSdoHDRcGfK9fhMYrzH4LMAsIro3nKxFKjucDJuJb6ACS1ywknRJUUYsxz7hgYaco4VGVjtrSKSMi1wR0jlThYIkkhIycrbKdfIMCB4Z8kN1eNAJKSLKqN6xjyPgHZWek99lOk/MOMocxZtLhbAiUs4o8OoCnZmCyEATsSld7prFNVTXI8KAUK54BAoO+aWukGvslHJZIPOhDvpXhkUCb9A9vLS6j24V6UO1i6VS5Y2NtqX+GEcbU+Jk6qfrroiVJNnyjrhjFRjc11WNniV7LAW2j9HriW56WZaWNuCBlWsDcy7koLThS0MkR410PnkGm8ivO61xbqXAosk2UY+NeoyC1hjDyGj2EQE4TOQ1oyIvdjaDmnvcfbpc7XBYVoW+MmOEqe2OpWgx1J7m4IYgbZsUItVqYlc0PZgbOI4wEkeJn2utlPhgxkVcNg674wWMqSi5DiIzrNcCBm19kAgL5HBWYvihN57KB2MPOGMWEtOmCoZVLNHVBPcHzyu+gq/CObWtjUQA3qFwKjrKIKe0ICFZwo2Q3KNN7XpKIHmCylvmA0gF+eIGRwJKjg6ZCnhvdVFNRIoomXgSGaXyhXu+XSf0qIejATxA4qeyqJqnOgvxA4cj69hnjIX0NCqyUow1WJiqD3Ae/FCysTRoF7k0Cuyks5yZgFMsgH+E49hF5wCPTaC9UdpfMgxuS1LF8fP0V5M8zYQm0mvpUyBhqmML+anEoYkGnAOeagRnWoJpsxGIgcKz2vPKvwuuca7KrT5SkoHANQUulQCLea0XYdecLq0YbBXHYcRZhA5k26xVxYqXDRFsp+xBy+z6j6YSkHe2qhL3Q0tMZIvqMWwVqiT5iqCa3uiyqmkFzIAGKgJyX5GOCS2IlR62q4el1t67cUDhSLUmMED+JXq/YJvEOIo46O6Ee/M/pLw0Sb3qswVQlHkkBXoKcmBL3WKPyhJ7SqqIAnKLIPmIN6l08beSA0xKnsknJFJUOEfeiRhJyxQqFJDEtGeVjIIRC1QkivLQjOaSpJ2RTEWEnk55yLdz5gJfVaa9uj6rlexjoBJ8Q2kyv9Yd2RUAkxDiAXQa28pko4cSrKBXSackWXBYSBK0AxWNzJAzw7uObLcW0m10RMVBm0gr0hY8CaEF7+z2Bbd+3Q/I54Rq6DaGXVHajK0R7ut6XTQFSCFrsVjTVGSKEptb+fkjXyeckVOZ5P9jAW5jADnAURUJnthahZMHXzR6hJV7XbpqYkq+xDWyLOdJjeW0JVAk5hwxowDEJdxpIAgCnGkw0YXK0mcB/GtTlm1lx5p4cZe+19kjghxuMg64Yx0m87T8IFFy7uk7l5bJ2oqnw25sQOoAQUJ+mBGRKG2imu5U0vjzCbP1VZVkk9VhI8OWBNdqesRQeFoN+AvaBqzBaQk1kKp+ApOfcF5gmFiAIr0Gm/tCiAjtottt9grJqvPAvalX+wRlDtjTfQyMFJnMIgo7qvtB/kY6oQzquiNNyNgqmST5SoekzNz8CpFvgCDGnEzTqxPmr/FeBBuVS8mvLjkGm/ouQI6zp6hBh4SPhl/CRBPiJVGIjqzqFlejpGt9DibxUaQiGYInU/2MxL6KMb20pbwV6Y8Zn0otROldrp+jiGkksnUK6jL4Tc4BUFX4CEvCBSVJWf8l9M1RDsIJ7pWQJJStXiWt1RlBf5EhhPGgjYDF7Xq5IsNWlS/VW0jf+Rlsp/R62px5HKlXalUXKmV9rrWKigLltrnAq3Ft3ldEArha3SFJGuK04XHKZJ7aFJ8XiyVbLFNC7fIl+WxL/NGaBB5QcBwiwJcQwER5wj3iIO20INpAabvSuIEiF/IABavq6WYWwN90p4AbVRiLVI1xbEQwmSGODD5L4/CScSXRsew5m0ag385A2/7V1vOGdW+fzVDv//1zP3edD+y9q7+0xn6/W2fPHO/da00GJ7SXaOqvvbd01npLOKD9nBkQQsZjkM1RzvuEdAYZooADdpgUdP4FzP0+7/P3G9UkzYSocep+SPAdCkKDqQX30A7RgQEpoZqNbVnr80wja5f7SpSK+6ujFrb/3qGfn+7cb+Xr13jdv4bu/WYGc7xzHDeZNOxQJ0gEUssDxmv1QWrpS7zHST9mSgAoCrXxigseqbqunYLIyaQnbp2xtXr5qDb7JVpDP7NDHPw3255jlH7/u0M/f53z3xsrL1/n/LbUpcHBgcr1W2VQeNYNQoZVJfxFbrIo+a/EqLY9pJ1uoqv1g/hIFWerD1dEV7qDj+66ryTA0LHDaiokAnt6DpJTOaCdVJew9hX2neOSobJAkanaw+DgMWGDqF6cZN8FJQODtCGi7zKGkQwtkaX4EOKYUANfhLOMUbCbR1CkcRBgBnfA8TxLV/X6SomqGkm6kpxTBdSNroXUolobyGlXpejjsKWhO5snjmoMfj3M8zB/7Dla0/t+w8z9Ps/foysvf+UeCvqD/JPmBfKJbW2TRa6vlj3IAgjoAHmpZ1ada2LRDzy0cM5dLWMbsqTrj1txIAjQo1gVKSRXlUTAF+m56kG0K8ECQ5auBNS3eW6WrfWFnXfQqanaw+HQy3PQQfAaXwjHGDUMoFbUlSBnVFl8KStXjXvWpd6x6YpB1SfLp/3Psl7JQgA+gURdZQXfTsCMGOsRm2O1IWm2lpKiWbgVFAOKLt+wM6LjRbQFj/LHNQY/KcZ5uB/3vK1p/b95xn6/V+23FtJ4/y7Gfr9HVvurZRf/uMM/f7OLfdWWtv/ZYZ+/4+PEW/1Xw29leEczwznTZaMxdgu7jcB6FNdgaKmbmazgINkV12NR/Wy0V6Motc1jSyqJiJpG2gmReBZYq3G4L/OMAe/dctzjNr3rTP0+799jOi7bzP0Vt9h6K2+09BbTdde1ugaRYqtrtOFUDkl2M5TNqJms9h4HXOSWD/Uherm9LEuICCFLhvpCl19O8cc1Bh82xxMccvXntr33+dgih8ja+87DL3Vdxh6q+809FbJ2oNnRN1wrApVXqjcShm/5ixG7eAAaozaLNhkJDxKiFXdD5nqb7oGqS2p784xBzUG3zGH5tzytaf2feccmnPLvZU0zn+bod/fteXeSvnl22fo93dvubfS2v4fM/T7//oY8VbfZeitDOd4ZjhvsmQsxsG1Y0W+GkLDuh98W2grFgGh4bxluu+u7qMydjH6vF3szyNTKYjkupJx3Rx0m70yjcF3zbH2tjzHqH3fPcfa+xjRd//T0Ft9l6G3+m5DbzVdez7Txd1UiLu+iuRdJ7XIF3qn+yCHwce2WNwTqxnIUhxC9/9oK10I3yB4/RxzUGPwP2eYg/9ry9ee2ve/Zuj3//0xsvb+t6G3+i5Db/Xdht5quvZYVgW0sEEouUhzQqv7NemO2XrCd9bpssHOa49y3uuW2CN95Yt0ewBfZOUseU9j8L9nmIP/Z8vXntr3f2bo96lxv59caV82QpvHXDdSQ3OXzunhSA1zsAgtsb9r8qoodTuBXrtPdTGUK+uYt30odJFYKY0zzc2Zbh7RN3rCRRVHsh86zPdVoPd6kIFrimx0+DJd7aHbhpSslM5Bwfnr2PtF7E7iTYh546OPFGmblhTqc85abHRnY93oK8/84rJoGri4EbM2zpcZKz7rm7pvgubi6TP24/12u2M5tW0ZC5d/LufoE4/H7MnJ+0/x39t23uiT2vLVk9974vGfv+cPf+af+fRvfeLHTt760HHWvbd3xnvvOOO9jz/jvYMz3js8471POuO9Tz7jvU85472jM9771DPe+7Qz3vv0M947PuO9zzjjvc88473POuO9kzPe++wz3vucM9773DPeO3/Ge593xnuff8Z7X3DGexfOeO8Lz3jvi85474vPeO/iGe99yRnvfekZ733ZGe+5M97LznjPn/FefsZ74Yz3ijPeK894rzrjvfqM95oz3vvyM977ijPeu3TGe195xns/4Iz3fuAZ710+470fdMZ7P/iM977qjPeunPHeV5/x3tec8d7XnvHe1TPe+7oz3vv6M977hjPeu3bGez/kjPd+6Bnv/bAz3rt+xns//Iz3vvFN3nvb4z+XcfLpx38u87Pyt/Lx5cf/dpu9sqcnx7U+fu1C9fRO+jJuf/70zhuaZ67zszzmDMd3b398nCsP3jj+al/0+rjH/z43OZfL35EGW+op/f1g8jt6ffXk2OdW3vuaNd87Z5+ZE8Xy+LszHJ+Xf9ea9u9O+qbXVz3Y+dDre/m92eoPnnl8/pda7Mk17Ti30qYnd958zHfW/OzcmuM8sfLZc2/y/dN+P7nz4WPwZm1bdx531vxsXdue/Aht213TttXjPnFGP97se6ZtWp6fj9v58HN9buW9dW3XuC7nze6D9P3Lj3/uNnhV9Qf93OK8PD7+UzsfPg+m3//UyueXmvsdk/ZPz8Xl72U7x0pXEbdjW7QRHt1+4srxdybnU+fpsx///a28deYrnzmv+Jlj7Nq8tS5OnJW3VtejXstctZrT3jk5nl7TvLU89pxaQLfcnnnMsnftvHkuWOaWJTtYPc9P7bx5Xnhq5bNLFiKt+a43Od7bzjjex+28+Xjr95Zc5Ok1x9gxPF/r2nFuTTs+1mP7yeN/f3/H9juP3/jYju118ZYnOftl5UmWrFZ//+TJ76/qtSfXHGfVi8yRx6Ze5KkZjs9UGJf56skH6fGX50+v3cl7uyvvPTV576nJ+fy8c+nnnp987v8fPi6474mPs15jy3zrJud5nc9Y9+fOSpuXr++LOS1bujz+21baYHN855bn4qk152L53W+fpW/BfTTnevr979iZc3277NzK9y3bs3p+Vsd+b5b25OMn7HyQ/6zqnd0152a1HW9baePTM7VxXUxctmldTFy2Q20tH3fqnWv6OB3j1XxyVo45eJPfX7Zn9fe2c91/UGd+T+bi8vN7az4/nSPL9i7P+TSu7K383rr5dO6MY++ttOXpN/n5ZeNz9CHNP/mOt5/Rr+l7T6+0bfnfUp9P35ueg7evvPfM43+/7U0+vzzeUyufX9bE1MavW9EB0zW1HPM5/Y1istpxbSVPLvuxaP+DtN/r5uf080+8yXmafn7d/DxY+fz0HK6LiavxbpVjXjY5P25cHm81X07bt+77l+1725t8fnm8p1Y+v6zjTefHOk1g2Ee/OrbTePvUmnP+0WiIaV+/PzTE8vu/rzTEO1ba82Zxe3nuzprn0/dWY+m69fTMmu9561hvHeutY711rLeO9dax3jrWW8d661hvHeutY711rLeO9dax3jrWW8d661hvHWt6rLevvDdlalMWPf338nOXH//bbfTKh3X1x3Nmx39j78U8bDIfn15zXg3bX6/bc7esoYvN/uOV791//O/lnqXp707Pw1Mrn/+XO28c8589/vu6mt3qXpLpsZd1i2cmv7u/0r6dnTfm1MevHPeyyTnLP8Tv3/kRzsXHr5yL5ef/3eM/tda6c2n7l7+zMznm/uRnT6z0951rPj/t9/Lzy/P1cZP33rny3v7K+VrXrnM7H86iz53RrrftrD83q7WK5ee/9fGfOjfDufXHnP5s2p/VesnBpA3nzuj/Uyuf//ZJG77u3PpjPrmmXed2PryG9AmT9+aYg5846cO68f+ElT4uP//dkz4u5+C6muH+pD967T6Yoz/ra4bT8X5q8r3Tfu3svNHv6edX5+Mnrvn8dGyW5+xg5fPTMV+Xx955xjGnc236mek6+4SVdq7O02k9evp7yzz91Mrn/5/Hf2oefs7K3J3GkdX5vC5HftzkWOs+v/8mbfh/H/+5rt44/f051sN0vq9bDwcrbV5+/olzb7T5rPWwHO/vj/WwbM+i/ZPvnfZrZ+eNfk8/v7oe1q2f6disrofpPF3Nuat5Q39O9dDqfpd37sxxzt6YA9MxXrfm3izuf/yaObAu93w053fdeLxzzTlc5t51c3RdflmXj595k++ertvpZz7+Tfr/SZP+D1uwbvfXnJPVdfupH+W6Xf7s+2PdTjXdR7Nup5//nq7b5Tlbt27fufLeNI8tv/Mj5Y1VLafX0i+s0+z7k+NOvYReb3+QHnfx5+RnT02Oq9fe9PMr7z09eW/3Qfo973j87+U1jKvHWrbjqZXPf9njA3xIy05+Z/n7B2u+/20r35+0e83Ppudr9VhPrvnZ8vM6pxce/5LW97Zft1I8PsD393Ury/P0thnOk3u892nR/8fHf3LnjfO0PDfT7183v5efW7b16Xna6lbXyHRMp3Nu2ZcnVj6/+vfVNXR1EkumfZzGn7PWwjOT99bFiGUb163RZx58z461t3Kst29wrGW7DtZ8/u3fy3atO9ZqrPmexI4vn8QO6zUZirbq20r3Gs6GkBUfaU2uG79p/tZred6mcfxta/r21Mrnr597o8/fuKIRnlrzffpce8bnzr3Jn4tjrPnZ7oP0Z+vGaDrey88vv/sda9q4fG86F6baQq/9x/+enq/psZbteGrl8z9hJe9N1+fy99fNxenaXv2udd//0az1Z9Z8XuPzo1dyybTvhvExW7ZtNVdMf7batnbGdTXUTXTNOLRZlvnoho+0rqy/39d12fjOhSr2Ywz5R/r+5b2qPsav/4/fV9eIznOdlCvnvc5o/TWi666f+N5e/7/ueruvWXlveu+Qr115b7pv+urKe9NrDb7u8Xur16t+0qT9en39gzf6dm7lvW+YvPfEynvXJu99KD+vtN947rbz1thc/q417V9+1zOPz98X7rzxms6NJ3Y+3Iuu3r9yb+Wzq5xy+tmnVz47ne9PfITjnjvjs+8447ir1yysXjf2jjX9Xv33Eyvtn87L1Ws19Lr8+E+32SvbWdOf1XP8tjc5F+vqQHtvci7WnePVcT638tnpnFgdjyfe5HvWzYnVf5/Vtw/psZXvWV3nq++9Y+W9c2uOue7+FNOa5rb79+U9Kb+//fuSaS3P10xxzX2IE8xz/A9plplyfj6NNTsr3zU9b+s8y+r8/RCHmKet7Yc83qQNT65852obp59ZvQ+ZXk+s/Ht35edPfhSfXf2+6XsfYn9n/N7Ta9o6/dn0+rfV1+q4TGt+64719sn708+/feWzc43hu9a0abXty/fm2S/zwftc6fXMPMd369bU9Dq9Z1beW86rdfPz3Jv8+4mVP8/67LkzjrtuTi2PuRyraXuX/fj/AGmAHc6HJhYA",
  "debug_symbols": "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",
  "file_map": {
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "22": {
      "source": "// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n",
      "path": "std/hash/poseidon/bn254/perm.nr"
    },
    "23": {
      "source": "// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n",
      "path": "std/hash/poseidon/bn254.nr"
    },
    "24": {
      "source": "pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n",
      "path": "std/hash/poseidon/mod.nr"
    },
    "61": {
      "source": "use ec::bjj::BabyJubJubParams;\nuse ec::Curve;\nuse ec::scalar_field::ScalarField;\nuse std::field::bn254::assert_lt;\nuse std::hash::poseidon::bn254::hash_2 as poseidon;\n\n// The maximum depth of the Merkle Tree the inclusion proof will be coming from.\n// This value can get updated by overwriting this line.\npub global MAX_DEPTH: u32 = 1;\n\n// Generator point of Baby Jubjub curve.\n// ref: https://github.com/noir-lang/noir-edwards/blob/main/src/test.nr#L6C8-L6C13\nglobal BASE8: [Field; 2] = [\n    5299619240641551281634865583518297030282874472190772894086521144482721001553,\n    16950150798460657717958625567821834550301663161624707787222815936182638968203,\n];\n\n// This is a 251 bit value.\nglobal L: Field = 2736030358979909402780800718157159386076813972158567259200215660948447373041;\n\n// There are 3 main steps in the Noir program.\n// - The first part generates the Semaphore identity by obtaining\n//   the public key from the secret key and consequently hash the public key.\n//   This resulting hash is the identityCommitment.\n// - In the second part, it is verified that the identityCommitment is indeed\n//   part of the merkle tree by verifying the merkle proof.\n// - In the third part the nullifier is generated by hashing the hashedScope\n//   with the secret key.\n\n// There are 4 public values: the Merkle tree root, hashed scope, hashed message,\n// and the nullifier. Whether the scope and message are actually hashed doesn't\n// affect the circuit; the names just match how they're used in the Semaphore sdk.\n//\n// The message is tied to the circuit by adding it as a (public) input to the circuit.\nfn main(\n    secretKey: Field,\n    indexes: Field, // a single field representing the index-bits for the merkle proof\n    hashPath: [Field; MAX_DEPTH], // the Merkle Tree inclusion proof\n    merkleProofLength: u32, // the number of non-zero elements in hashPath\n    merkleTreeRoot: pub Field,\n    hashedScope: pub Field,\n    hashedMessage: pub Field,\n) -> pub Field {\n    // Part 1\n    // Ensure secret_key < l.\n    assert_lt(secretKey, L);\n\n    // Identity generation.\n    // The public key is derived by multiplying the generator point with the secret key\n    // interpreted as a scalar.\n    let generator: Curve<BabyJubJubParams> = Curve { x: BASE8[0], y: BASE8[1] };\n    // ScalarField is parameterised by the number of 4-bit slices it contains.\n    // Since secret key is already know to be max 251 bits, there are 63 slices.\n    let secretScalar: ScalarField<63> = ScalarField::from(secretKey);\n    let pubkey = generator.mul(secretScalar);\n\n    // Obtain the identity commitment by hashing the public key\n    let identityCommitment = poseidon([pubkey.x, pubkey.y]);\n\n    // Part 2\n    // Verifies membership by repeatedly hashing with the elements from the merkle proof\n    // Depending on the index bit, we swap the siblings for hashing or not.\n    // Finally, it is checked the resulting root equals the expected one.\n    // The index bits are bounded by the max depth of the tree. The maximum Semaphore tree depth is 32.\n    let index_bits: [u1; MAX_DEPTH] = indexes.to_le_bits();\n    let mut node = identityCommitment;\n    for i in 0..MAX_DEPTH {\n        if i < merkleProofLength {\n            let sibling = hashPath[i];\n            let (left, right) = if index_bits[i] == 0 {\n                (node, sibling)\n            } else {\n                (sibling, node)\n            };\n            node = poseidon([left, right]);\n        }\n    }\n\n    assert(node == merkleTreeRoot);\n\n    // Part 3\n    // Obtain the nullifier by hashing the hashed scope and secret key.\n    let nullifier = poseidon([hashedScope, secretKey]);\n\n    nullifier\n}\n\n#[test]\nfn pass_merkleproof_len1() {\n    let secretKey = 2736030358979909402780800718157159386076813972158567259200215660948447373040;\n    let indexes = 1;\n    let mut hashPath = [0; MAX_DEPTH];\n    hashPath[0] = 17197790661637433027297685226742709599380837544520340689137581733613433332983;\n    let merkleProofLength = 1;\n    let merkleTreeRoot =\n        14749601632619677010117355190090900871659822873947496064081607008658671249718;\n    let hashedScope = 32;\n    let messageInput = 43;\n\n    let nullifierOutput = main(\n        secretKey,\n        indexes,\n        hashPath,\n        merkleProofLength,\n        merkleTreeRoot,\n        hashedScope,\n        messageInput,\n    );\n\n    assert(\n        nullifierOutput\n            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,\n    );\n}\n\n#[test]\nfn pass_merkleproof_len2() {\n    let secretKey = 2736030358979909402780800718157159386076813972158567259200215660948447373040;\n    let indexes = 3;\n    let mut hashPath = [0; MAX_DEPTH];\n    hashPath[0] = 222;\n    hashPath[1] = 5580148635681152038824579634153994374025422922042242905608547916566050510583;\n    let merkleProofLength = 2;\n    let merkleTreeRoot =\n        15463896243170667872144918581954291954064138644202866266871757140238856236252;\n    let hashedScope = 32;\n    let messageInput = 43;\n\n    let nullifierOutput = main(\n        secretKey,\n        indexes,\n        hashPath,\n        merkleProofLength,\n        merkleTreeRoot,\n        hashedScope,\n        messageInput,\n    );\n\n    assert(\n        nullifierOutput\n            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,\n    );\n}\n\n#[test]\nfn pass_merkleproof_len10() {\n    let secretKey = 2736030358979909402780800718157159386076813972158567259200215660948447373040;\n    let indexes = 1023;\n    let mut hashPath = [0; MAX_DEPTH];\n    hashPath[0] = 1023;\n    hashPath[1] = 7703609393926148861806470850414101587282113463695008072842235608796379066550;\n    hashPath[2] = 11844355347052921836263554861941946966048634969958623466081587590542465759133;\n    hashPath[3] = 19139877065885635288462009770448247355705152266967089952432395406553642434273;\n    hashPath[4] = 15968895708437223385516840363948747630018846839139338811061474982723265688336;\n    hashPath[5] = 1157389113544196424312834359849712044068249869160475042631259223915679649526;\n    hashPath[6] = 9850169485007128596840836882853679679304108948486378818337816937810456934767;\n    hashPath[7] = 7328698264973484546168581905250553935177218888248684409634832044961836320061;\n    hashPath[8] = 3637363514134115024343666241307349483158812906758472113070175697206757306389;\n    hashPath[9] = 7516686158158401448998320090358910253731148596461412688165783659432576569650;\n    let merkleProofLength = 10;\n    let merkleTreeRoot =\n        2057311462964865392236711171061056405638996999335557516757935831793017666139;\n    let hashedScope = 32;\n    let messageInput = 43;\n\n    let nullifierOutput = main(\n        secretKey,\n        indexes,\n        hashPath,\n        merkleProofLength,\n        merkleTreeRoot,\n        hashedScope,\n        messageInput,\n    );\n\n    assert(\n        nullifierOutput\n            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,\n    );\n}\n\n#[test(should_fail)]\nfn fail_secret_key_outofrange() {\n    let secretKey = 2736030358979909402780800718157159386076813972158567259200215660948447373042;\n    let indexes = 1;\n    let mut hashPath = [0; MAX_DEPTH];\n    hashPath[0] = 17197790661637433027297685226742709599380837544520340689137581733613433332983;\n    let merkleProofLength = 1;\n    let merkleTreeRoot =\n        14749601632619677010117355190090900871659822873947496064081607008658671249718;\n    let hashedScope = 32;\n    let messageInput = 43;\n\n    let nullifierOutput = main(\n        secretKey,\n        indexes,\n        hashPath,\n        merkleProofLength,\n        merkleTreeRoot,\n        hashedScope,\n        messageInput,\n    );\n}\n\n#[test(should_fail)]\nfn fail_invalid_merkleproof() {\n    let secretKey = 2736030358979909402780800718157159386076813972158567259200215660948447373040;\n    let indexes = 1;\n    let mut hashPath = [0; MAX_DEPTH];\n    hashPath[0] = 2;\n    let merkleProofLength = 1;\n    let merkleTreeRoot =\n        14749601632619677010117355190090900871659822873947496064081607008658671249718;\n    let hashedScope = 32;\n    let messageInput = 43;\n\n    let nullifierOutput = main(\n        secretKey,\n        indexes,\n        hashPath,\n        merkleProofLength,\n        merkleTreeRoot,\n        hashedScope,\n        messageInput,\n    );\n\n    assert(\n        nullifierOutput\n            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,\n    );\n}\n\n#[test(should_fail)]\nfn fail_other_merkleroot() {\n    let secretKey = 2736030358979909402780800718157159386076813972158567259200215660948447373040;\n    let indexes = 1;\n    let mut hashPath = [0; MAX_DEPTH];\n    hashPath[0] = 17197790661637433027297685226742709599380837544520340689137581733613433332983;\n    let merkleProofLength = 1;\n    let merkleTreeRoot = 2;\n    let hashedScope = 32;\n    let messageInput = 43;\n\n    let nullifierOutput = main(\n        secretKey,\n        indexes,\n        hashPath,\n        merkleProofLength,\n        merkleTreeRoot,\n        hashedScope,\n        messageInput,\n    );\n\n    assert(\n        nullifierOutput\n            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,\n    );\n}\n",
      "path": "/Users/elena/Documents/hashcloak/clients/Aztec/semaphore_grant_related/semaphore-noir/packages/circuits-noir/src/main.nr"
    },
    "63": {
      "source": "mod scalar_field;\nmod test;\nmod bjj;\n\npub use crate::scalar_field::ScalarField;\nuse std::ops::{Add, Neg, Sub};\n\npub struct Curve<Params> {\n    x: Field,\n    y: Field,\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### T R A I T S\n// ####################################################################################################################\n// ####################################################################################################################\n\n/// Parametrises a Twisted Edwards curve\ntrait TECurveParameterTrait {\n    fn a() -> Field; // twisted edward curve parameter a\n    fn d() -> Field; // twisted edward curve parameter d\n    fn gen() -> (Field, Field); // generator point x/y coordinates\n}\n\n/// Defines methods that a valid Curve implementation must satisfy\ntrait CurveTrait<Params>: Add + Sub + Eq + Neg + Default {\n    fn new(x: Field, y: Field) -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn dbl(self) -> Self;\n    fn mul<let NScalarSlices: u32>(self, x: ScalarField<NScalarSlices>) -> Self;\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self;\n\n    fn eq(self, x: Self) -> bool {\n        self == x\n    }\n    fn is_zero(self) -> bool {\n        self == Self::zero()\n    }\n\n    fn is_on_curve(self) -> bool;\n    fn assert_is_on_curve(self);\n    fn assert_equal(self, other: Self);\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### C O N S T R A I N E D    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> std::default::Default for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Returns point at infinity\n    ///\n    /// Cost: 0 gates\n    fn default() -> Self {\n        Curve::zero()\n    }\n}\n\nimpl<Params> std::ops::Add for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self + other`\n    ///\n    /// Cost: 7 gates\n    fn add(self, other: Self) -> Self {\n        Curve::add_internal(self, other, Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::ops::Neg for Curve<Params> {\n    /// Negate a point\n    ///\n    /// Cost: usually 0, will cost 1 gate if the `x` coordinate needs to be converted into a witness\n    fn neg(self) -> Self {\n        Curve { x: -self.x, y: self.y }\n    }\n}\n\nimpl<Params> std::ops::Sub for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self - other`\n    ///\n    /// Cost: 7 gates\n    fn sub(self, other: Self) -> Self {\n        Curve::add_internal(self, other.neg(), Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::cmp::Eq for Curve<Params> {\n    /// Compute `self == other`\n    ///\n    /// Cost: 6 gates\n    fn eq(self, other: Self) -> bool {\n        (self.x == other.x) & (self.y == other.y)\n    }\n}\n\nimpl<Params> std::convert::From<(Field, Field)> for Curve<Params> {\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    ///\n    /// Cost: 0 gates\n    fn from((x, y): (Field, Field)) -> Self {\n        Curve { x, y }\n    }\n}\n\nimpl<Params> CurveTrait<Params> for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n\n    /// Construct a new point\n    ///\n    /// If you know the x/y coords form a valid point DO NOT USE THIS METHOD\n    /// This method calls `assert_is_on_curve` which costs 3 gates.\n    /// Instead, directly construct via Curve{x, y} or use from((x, y))\n    ///\n    /// Cost: 3 gates\n    fn new(x: Field, y: Field) -> Self {\n        let result = Curve { x, y };\n        result.assert_is_on_curve();\n        result\n    }\n\n    /// Return the Identity element (point at infinity)\n    ///\n    /// Cost: 0 gates\n    fn zero() -> Self {\n        Curve { x: 0, y: 1 }\n    }\n\n    /// Return the Generator of the group\n    ///\n    /// Cost: 0 gates (assuming Params trait returns values known at compile time!)\n    fn one() -> Self {\n        let (x, y) = Params::gen();\n        Curve { x, y }\n    }\n\n    /// Validate a point is on the curve\n    ///\n    /// cheaper than `is_on_curve` (assert is cheaper than returning a bool)\n    ///\n    /// Cost: 3 gates\n    fn assert_is_on_curve(self) {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        assert(t2 == t3);\n    }\n\n    /// Constrain two points to equal each other\n    ///\n    /// Cheaper than `assert(self == other)` because no need to return a bool\n    ///\n    /// Cost: 0-2 gates (can do these asserts with just copy constraints)\n    fn assert_equal(self, other: Self) {\n        assert(self.x == other.x);\n        assert(self.y == other.y);\n    }\n\n    /// Return a bool that describes whether the point is on the curve\n    ///\n    /// If you don't need to handle the failure case, it is cheaper to call `assert_is_on_curve`\n    ///\n    /// Cost: 5 gates\n    fn is_on_curve(self) -> bool {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        (t2 == t3)\n    }\n\n    /// Compute `self + self`\n    ///\n    /// Cost: 5 gates\n    fn dbl(self) -> Self {\n        Curve::dbl_internal(self, Params::a(), Params::d())\n    }\n\n    /// Compute `self * scalar`\n    ///\n    /// Uses the Straus method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows:\n    ///      1: computing the Straus point lookup table (169 gates)\n    ///      2: 252 point doublings (1260 gates)\n    ///      3: 63 point additions (441 gates)\n    ///      4: 126 table reads with runtime index (252 gates)\n    ///\n    /// Cost: 2122 gates + cost of creating ScalarField (110 gates)\n    ///\n    /// TODO: use windowed non-adjacent form to remove 7 point additions when creating lookup table\n    fn mul<let NScalarSlices: u32>(self: Self, scalar: ScalarField<NScalarSlices>) -> Self {\n        // define a, d params locally to make code more readable (shouldn't affect performance)\n        let a = Params::a();\n        let d = Params::d();\n\n        // Construct tables of precomputed point coordinates.\n        let (table_x, table_y): ([Field; 16], [Field; 16]) = self.compute_straus_point_table(a, d);\n\n        // Initialize the accumulator with the point that maps to the first (most significant) scalar slice\n        let idx = scalar.base4_slices[0];\n        let mut accumulator: Self = Curve { x: table_x[idx], y: table_y[idx] };\n\n        // Execute a double-and-add subroutine\n        // 1. Compute `accumulator = accumulator * 16`\n        // 2. Extract 4-bits from the scalar multiplier and\n        //    use them to retrieve the corresponding point from our point table\n        // Note: this is similar to the \"double and add\" scalar multiplication method, except we use base16 instead of base2!\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            let idx: u8 = scalar.base4_slices[i];\n            let x = table_x[idx];\n            let y = table_y[idx];\n            accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n        }\n\n        // todo fix\n        if (scalar.skew) {\n            accumulator = accumulator - self;\n        }\n        accumulator\n    }\n\n    /// compute `points[0] * scalar[0] + ... + points[N-1] * scalar[N-1]`\n    ///\n    /// Is cheaper than `mul` when processing >1 point due to reduced number of point doublings\n    /// uses the Straus MSM method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows\n    /// PER POINT costs:\n    ///      1: computing the Straus point lookup table (169N gates)\n    ///      2: 63 point additions (441N gates)\n    ///      3: 126 table reads with runtime index (252N gates)\n    ///\n    /// Additional costs:\n    ///      1. 252 point doublings 1260 gates\n    ///\n    /// Cost: 1260 + 862N + cost of creating ScalarField (110N gates)\n    ///\n    /// TODO: use windowed non-adjacent form to remove 7 point additions per point when creating lookup table\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self {\n        let a = Params::a();\n        let d = Params::d();\n\n        // Generalized version of `mul` for multiple points.\n        let mut point_tables: [([Field; 16], [Field; 16]); N] = [([0; 16], [0; 16]); N];\n        for j in 0..N {\n            point_tables[j] = points[j].compute_straus_point_table(a, d);\n        }\n\n        let idx = scalars[0].base4_slices[0];\n        let mut accumulator: Self = Curve { x: point_tables[0].0[idx], y: point_tables[0].1[idx] };\n        for j in 1..N {\n            let idx = scalars[j].base4_slices[0];\n            let P = Curve { x: point_tables[j].0[idx], y: point_tables[j].1[idx] };\n            accumulator = accumulator.add_internal(P, a, d);\n        }\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            for j in 0..N {\n                let idx: u8 = scalars[j].base4_slices[i];\n                let x = point_tables[j].0[idx];\n                let y = point_tables[j].1[idx];\n                accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n            }\n        }\n\n        for j in 0..N {\n            if (scalars[j].skew == true) {\n                accumulator = accumulator - points[j];\n            }\n        }\n        accumulator\n    }\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### H E L P E R    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> Curve<Params> {\n\n    /// add two points together\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `add` :(\n    fn add_internal(self, other: Self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let x2 = other.x;\n        let y1 = self.y;\n        let y2 = other.y;\n        let (x, y, lambda) = unsafe { __add_unconstrained(x1, x2, y1, y2, a, d) };\n        let x1x2 = x1 * x2;\n        let x1y2 = x1 * y2;\n        std::as_witness(x1x2);\n        std::as_witness(x1y2);\n        let x_lhs = x * lambda * d + x - x1y2; // equals y1x2\n        let y_lhs = y * lambda * -d + y + x1x2 * a; // equals y1y2\n        let y1x2 = y1 * x2;\n        let y1y2 = y1 * y2;\n        std::as_witness(y1x2);\n        std::as_witness(y1y2);\n        let y1y2x1x2 = y1y2 * x1x2;\n        assert(x_lhs == y1x2);\n        assert(y_lhs == y1y2);\n        assert(y1y2x1x2 == lambda);\n        Self { x, y }\n    }\n\n    /// add a point to itself\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `dbl` :(\n    fn dbl_internal(self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let y1 = self.y;\n        let (x3, y3, _) = unsafe { __add_unconstrained(x1, x1, y1, y1, a, d) };\n        let x1x1a = x1 * x1 * a;\n        std::as_witness(x1x1a);\n        // t1 = a*x_1^2 + y_1^2\n        let t1 = y1 * y1 + x1x1a;\n        std::as_witness(t1);\n        // t3 = y_3 * (2 - a*x_1^2 + y_1^2) + 2*a*x_1^2\n        let t3 = y3 + y3 - t1 * y3 + x1x1a * 2;\n        // t3 == t1 implies y_3 * (2 - a*x_1^2 - y_1^2) + 2*a*x_1^2 == a*x_1^2 + y_1^2\n        // i.e. y_3 = y_1^2 - a*x_1^2 / (2 - a*x_1^2 - y_1^2)\n        assert(t3 == t1);\n        let t4 = x1 * y1;\n        std::as_witness(t4);\n        // x3 * t1 - t4 == t4 implies x_3 * (y_1^2 + a * x_1^2) = 2 * x_1 * y_1\n        // i.e. x_3 = 2 * x_1 * y_1 / (y_1^2 + a * x_1^2)\n        let t2 = x3 * t1 - t4;\n        assert(t2 == t4);\n        Self { x: x3, y: y3 }\n    }\n\n    /// Compute a 4-bit lookup table of point multiples for the Straus windowed scalar multiplication algorithm.\n    ///\n    /// Table contains [0, P, 2P, ..., 15P], which is used in the scalar mul algorithm to minimize the total number of required point additions\n    ///\n    /// It is cheaper to use ([Field; 16], [Field; 16]) than it is ([Curve; 16]).\n    /// This is because the compiler will represent [Curve; 16] in 1 ROM array (vs 2 for [Field; 16], [Field; 16]).\n    /// This means that any index into the ROM array for [Curve; 16] requires an additional arithmetic gate to process.\n    ///\n    ///      For example consider `let P: Curve = table[idx]`\n    ///      `table` will be a ROM array with 32 elements in it.\n    ///      The x-coordinates will be located at `2 * idx`\n    ///      The y-coordinates will be located at `2 * idx + 1`\n    ///      If `idx` is not known at compile time (for Straus it isnt), 2 arithmetic gates are required to evaluate `2 * idx`, `2 * idx + 1`\n    ///      before they can be used as arguments in a memory lookup protocol\n    ///\n    ///      Now consider `let P_x = table_x[idx]; let P_y = table_y[idx]`\n    ///      In this example, `idx` can be directly used as the argument into a memory lookup protocol for both tables.\n    ///\n    ///      For the Barretenberg backend, the cost of a Read-Only memory lookup is 2 gates,\n    ///      so splitting the x/y coordinates into separate tables means that the cost to lookup a point is 4 gates\n    ///      2 extra arithmetic gates would increase the cost by 50%, which we avoid by returning `([Field; 16], [Field; 16])` instead of `([Curve; 16])`\n    ///\n    /// Key cost components are as follows:\n    ///      1: Defining two size-16 lookup tables (2 gates per element, 32 elements = 64 gates)\n    ///      2: 15 point additions (7 * 5 = 105)\n    ///\n    /// Total Cost: 169 gates\n    ///\n    /// TODO: use windowed non-adjacent form to remove 8 point additions\n    fn compute_straus_point_table(self, a: Field, d: Field) -> ([Field; 16], [Field; 16]) {\n        let mut table_x: [Field; 16] = [0; 16];\n        let mut table_y: [Field; 16] = [0; 16];\n        table_x[8] = self.x;\n        table_y[8] = self.y;\n        let D = self.dbl_internal(a, d);\n        for i in 1..8 {\n            let Q = Self { x: table_x[7 + i], y: table_y[7 + i] };\n            let V = D.add_internal(Q, a, d);\n            table_x[8 + i] = V.x;\n            table_y[8 + i] = V.y;\n        }\n        for i in 0..8 {\n            table_x[i] = -table_x[15 - i];\n            table_y[i] = table_y[15 - i];\n        }\n        (table_x, table_y)\n    }\n}\n\n/// add points together, return output + lambda ter\nunconstrained fn __add_unconstrained(\n    x1: Field,\n    x2: Field,\n    y1: Field,\n    y2: Field,\n    a: Field,\n    d: Field,\n) -> (Field, Field, Field) {\n    let lambda = y1 * y2 * x1 * x2;\n    let y = (x1 * x2 * a - y1 * y2) / (lambda * d - 1);\n    let x = (x1 * y2 + y1 * x2) / (lambda * d + 1);\n    (x, y, lambda)\n}\n",
      "path": "/Users/elena/nargo/github.com/noir-lang/noir-edwards/v0.1.1/src/lib.nr"
    },
    "64": {
      "source": "/// ScalarField represents a scalar multiplier as a sequence of 4-bit slices\n///\n/// There is nuance to ScalarField, because twisted edwards curves generally have prime group orders that easily fit into a Field\n/// We can therefore obtain cheap conversions by simply summing up the bit slices and validate they equal the input scalar\n/// However...when converting arbitrary field elements (i.e. scalars that are multiples of a TE curve group order),\n/// we must perform additional checks when converting into 4-bit slices, as we must validate that the sum of the slices is smaller than the Field modulus (when evaluated over the integers)\n/// This is expensive and we would rather not do it! therefore ScalarField<N> is flexible.\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n///\n/// N.B. ScalarField bit values are not constrained to be smaller than the TE curve group order.\n/// ScalarField is used when performing scalar multiplications, where all operations wrap modulo the curve order\npub struct ScalarField<let N: u32> {\n    pub(crate) base4_slices: [u8; N],\n    pub(crate) skew: bool,\n}\n\nunconstrained fn get_wnaf_slices<let N: u32>(x: Field) -> ([u8; N], bool) {\n    let mut result: [u8; N] = [0; N];\n    let mut nibbles: [u8; N] = x.to_le_radix(16);\n\n    let skew: bool = nibbles[0] & 1 == 0;\n    nibbles[0] += skew as u8;\n    result[N - 1] = (nibbles[0] + 15) / 2;\n    for i in 1..N {\n        let mut nibble: u8 = nibbles[i];\n        result[N - 1 - i] = (nibble + 15) / 2;\n        if (nibble & 1 == 0) {\n            result[N - 1 - i] += 1;\n            result[N - i] -= 8;\n        }\n    }\n    (result, skew)\n}\n\nunconstrained fn from_wnaf_slices(x: [u8; 64], skew: bool) -> Field {\n    let mut result: Field = 0;\n\n    for i in 0..64 {\n        result *= 16;\n        result += (x[i] as Field) * 2 - 15;\n    }\n    result -= skew as Field;\n    result\n}\n\n#[test]\nfn test_wnaf() {\n    unsafe {\n        let result: Field = 0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0;\n        let (t0, t1) = get_wnaf_slices(result);\n        let expected = from_wnaf_slices(t0, t1);\n        assert(result == expected);\n    }\n}\n\ncomptime fn get_modulus_slices() -> (Field, Field) {\n    let bytes = std::field::modulus_be_bytes();\n    let num_bytes = std::field::modulus_num_bits() / 8;\n    let mut lo: Field = 0;\n    let mut hi: Field = 0;\n    for i in 0..(num_bytes / 2) {\n        hi *= 256;\n        hi += bytes[i] as Field;\n        lo *= 256;\n        lo += bytes[i + (num_bytes / 2)] as Field;\n    }\n    if (num_bytes & 1 == 1) {\n        lo *= 256;\n        lo += bytes[num_bytes - 1] as Field;\n    }\n    (lo, hi)\n}\n\nunconstrained fn get_borrow_flag(lhs_lo: Field, rhs_lo: Field) -> bool {\n    lhs_lo.lt(rhs_lo + 1)\n}\nimpl<let N: u32> std::convert::From<Field> for ScalarField<N> {\n\n    /// Construct from a field element\n    ///\n    /// if N >= 64 we perform extra checks to ensure the slice decomposition represents the same integral value as the input\n    /// (e.g. sum of slices != x + modulus)\n    fn from(x: Field) -> Self {\n        let mut result: Self = ScalarField { base4_slices: [0; N], skew: false };\n        let (slices, skew): ([u8; N], bool) = unsafe { get_wnaf_slices(x) };\n        result.base4_slices = slices;\n        result.skew = skew;\n        if (N < 64) {\n            let mut acc: Field = (slices[0] as Field) * 2 - 15;\n            for i in 1..N {\n                acc *= 16;\n                acc += (slices[i] as Field) * 2 - 15;\n            }\n            assert(acc - skew as Field == x);\n        } else {\n            // TODO: if num bits = 64, validate in sum of the bits is smaller than the Field modulus\n            let mut lo: Field = slices[(N / 2)] as Field;\n            let mut hi: Field = slices[0] as Field;\n            let mut borrow_shift = 1;\n            for i in 1..(N / 2) {\n                borrow_shift *= 16;\n                lo *= 16;\n                lo += (slices[(N / 2) + i] as Field) * 2 - 15;\n                hi *= 16;\n                hi += (slices[i] as Field) * 2 - 15;\n            }\n            if ((N & 1) == 1) {\n                borrow_shift *= 16;\n                lo *= 16;\n                lo += (slices[N - 1] as Field) * 2 - 15;\n            }\n            lo -= skew as Field;\n            // Validate that the integer represented by (lo, hi) is smaller than the integer represented by (plo, phi)\n            let (plo, phi) = comptime { get_modulus_slices() };\n            unsafe {\n                // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n                let borrow = get_borrow_flag(plo, lo) as Field;\n\n                let rlo = plo - lo + borrow * borrow_shift - 1; // -1 because we are checking a strict <, not <=\n                let rhi = phi - hi - borrow;\n                rlo.assert_max_bit_size::<(N / 2 + N % 2) * 4>();\n                rhi.assert_max_bit_size::<N / 2 * 4>();\n            }\n        }\n        for i in 0..N {\n            (result.base4_slices[i] as Field).assert_max_bit_size::<4>();\n        }\n        result\n    }\n}\n\nimpl<let N: u32> std::convert::Into<Field> for ScalarField<N> {\n\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    fn into(self: Self) -> Field {\n        let mut acc: Field = 0;\n        for i in 0..N {\n            acc = acc * 16;\n            acc = acc + (self.base4_slices[i] as Field) * 2 - 15;\n        }\n        acc -= self.skew as Field;\n        acc\n    }\n}\n\nimpl<let N: u32> ScalarField<N> {\n\n    pub fn new() -> Self {\n        Self { base4_slices: [0; N], skew: false }\n    }\n    fn get(self, idx: u64) -> u8 {\n        self.base4_slices[idx]\n    }\n}\n",
      "path": "/Users/elena/nargo/github.com/noir-lang/noir-edwards/v0.1.1/src/scalar_field.nr"
    }
  },
  "names": ["main"],
  "brillig_names": [
    "decompose_hint",
    "lte_hint",
    "get_wnaf_slices",
    "__add_unconstrained",
    "directive_to_radix",
    "directive_integer_quotient"
  ]
}
