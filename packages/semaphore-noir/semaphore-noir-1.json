{
  "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
  "hash": 10053271030530289897,
  "abi": {
    "parameters": [
      { "name": "secret_key", "type": { "kind": "field" }, "visibility": "private" },
      {
        "name": "index_bits",
        "type": { "kind": "array", "length": 1, "type": { "kind": "integer", "sign": "unsigned", "width": 1 } },
        "visibility": "private"
      },
      {
        "name": "hash_path",
        "type": { "kind": "array", "length": 1, "type": { "kind": "field" } },
        "visibility": "private"
      },
      {
        "name": "merkle_proof_length",
        "type": { "kind": "integer", "sign": "unsigned", "width": 32 },
        "visibility": "private"
      },
      { "name": "hashed_scope", "type": { "kind": "field" }, "visibility": "public" },
      { "name": "hashed_message", "type": { "kind": "field" }, "visibility": "public" }
    ],
    "return_type": {
      "abi_type": { "kind": "tuple", "fields": [{ "kind": "field" }, { "kind": "field" }] },
      "visibility": "public"
    },
    "error_types": {
      "2920182694213909827": { "error_kind": "string", "string": "attempt to subtract with overflow" },
      "5019202896831570965": { "error_kind": "string", "string": "attempt to add with overflow" },
      "6485997221020871071": { "error_kind": "string", "string": "call to assert_max_bit_size" },
      "16761564377371454734": { "error_kind": "string", "string": "Array index out of bounds" },
      "17843811134343075018": { "error_kind": "string", "string": "Stack too deep" }
    }
  },
  "bytecode": "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",
  "debug_symbols": "7d3djuW6deDxd6lrX5Drk8yrBMHASZzAgGEHjjPAIMi7D/v4VHV7q6vkVlOV/xZ1Y3T7bG6R1KKKa3Xpx/9++dff/fN//fv/+f0f/+1P//nyD//43y9/+NO//PYvv//TH8ff/vtFfvm//vM/fvvHL3/7z7/89s9/efkHqRa/efndH//1yx+z/M9vXv7t93/43cs/RP2f32w+rEXLrx/WYv724Zrf+bC0ePvmlm3nw9XKWzc8v/3wP/3mRck9l9JfPywqH3/YU3/9rPf+9aPtyyANPUj3t0HuffijQTp5kBr5+mHt+hCDQe659fb6Ydf8+MPVm/z64RqlPAwz1xhmu8wwU14/XNPr8ZXZ7xl5mJFarjMlWd6m5G+fbD84JfWekscp+extVTd7/eaeP/UQrPq8XTdy16c9gXyJUQZ6lLOeE7nEKL+/sYrylj6E2s4o9e3DqvK1LxG/XKCffAEpP3+BkPp6gfjmPv16gfrTF/CSr/fWq+S3F/ix2yUC6ouC+mKgvjioLwHqS4L60kB96Zy+aAH1BfTcVdBzV0HPXQU9dxX03FXQc1dBz10FPXcV9Nw10HPXQM9dAz13DfTcNdBz10DPXQM9dw303DXQc9dAz10HPXcd9Nx10HPXQc9dBz13HfTcddBz10HPXQc9dx303A3QczdAz90APXcD9NwN0HM3QM/dAD13A/TcDdBzN0DP3QQ9dxP03E3QczdBz90EPXcT9NxN0HM3Qc/dBD13E/TcbaDnbgM9dxvoudtAz932znPX9a0vX77zo76ktNffVErpX38VM/yXC/jZF4izL5BnX6CdfYF+8gV6OfsC9ewLyNkX0LMvcPZK7mev5H72Su5nr+R+9kruZ6/kWsrpV6inX2HCYtby+uHU6psr6OlXsNOv4KdfIU6/Qp5+hXb6FfrZV6jl9CvU068wYU2nv/4ue2bat1fYfnjsqt9+AX/8ueWmQ/rZHWr69t6LNLdNh+yzO9Tf3joYf7a+6ZB/codU6usb1+PPsr1l8dkdsvjaIctthyY8vlp5fdkm2zdvmR8M6vbZHdoL6v7ZHdoJaimf3KG9oJb62R3aCWqZ8KT++nZntl5+MqhFP7tDO0Et9tkd2gtq/+QO7QZ1fHaH9oJ6wpO6y2vNLru1nw3q9tkd2gvq/tkd2glqLZ/cob2g1vrZHdoJav35J3Ur8hqmregmE1edcIUob1dI2Vzh55+lbRQ9Xq8wns07k1qzv77DObZLuu2Qf3aH+tunx5+lbjoUn9whqfn2/vdYEtuFmZ/dIfGvjy6JTW6p7dM71PRrh3psOtQ/u0Na7a1Dug1qK7Ds2yos+zaBZd+msOzbDJZ9m8Oyb4sXVvZtCcu+rcGyb+uw7NsLLPv2+sLKvl1g2bcrLPt2g2Xf7rDs2+OFlX17wrJvb7Ds2zss+45ydvYd9ezsOwSWfYfCsu8wWPYdDsu+I2DZdyQs+44Gy76jw7LvLLDsOyss+06BZd+psOw77YWVfafDsu8MWPadCcu+s8Gy7+wvrOy7FVj23Sos+24Cy76bwrLvGS+tTM2+m8Oy7xaw7LslLPue8NLNTvY94a2bnex7wms3c7PvCa/pzM2+u8Cy766w7HvCa0Nzs+/usOy7Byz7nvEa09TsuzdY9t07K/uWUljZt5TKyr5lxjtbM7NvKcrKvqXYCyr7luKs7FtKsLJvmfF62szsW0pjZd9SOiv7llpY2bfUysq+ZcabeDOzb6nKyr5lxpt4M7Nvqc7KvmXCm3gfZ98y4dW6j7NvqY2VfUvtrOxbpLCyb5HKyr5FhJV9iygr+5YZ78rNzL5FnJV9iwQr+xZJWPYtDZZ9S4dl31pg2bdWWPatAsu+VWHZ94Q38eZm3+qw7FsDln1rwrJvbbDsWzss+7YCy76twrJvE1j2bQrLvie8ibeTfU94tW4n+7aAZd+WsOzbGiz7tg7Lvr3Asm+vsOzbYeqaOExdkxnvyk3Nvh2mronD1DVxmLomDlPXxGHqmgRMXZOAqWsSMHVNAqauyYQ38eZm3wFT1yRg6poETF2TgKlrEjB1TRKmrknC1DXJs9U1ybPVNZnwrtzc7Dth6pokTF2ThKlrkjB1TRKmrkmDqWvSYOqaNJi6Jg2mrsmMd+WmZt8Npq5Jg6lr0mDqmjSYuiYNpq5Jh6lr0mHqmnSYuiYdpq7JjAO8pmbfHaauSYepa9Jh6pp0mLomHaauaTlbXdNytrqmBaauaYGpa1rsBZV9a4Gpa1pg6poWmLqmBaauaYGpa1ph6ppWmLqmFaauaYWpazrjXbmZ2bdWmLqmFaauaYWpa1ph6ppWmLqmAlPXVGDqmgpMXVOBqWs64028mdm3CkxdU4GpayowdU3lbHVN5Wx1TRWmrqnC1DVVmLqmClPX9NNPrdvLvhWmrqnC1DVVmLqmClPXVGHqmhpMXVODqWtqMHVNDaau6YxT66Zm3wZT19Rg6poaTF1Tg6lrajB1TR2mrqnD1DV1mLqmDlPXdMabeFOzb4epa+pnq2vqZ6tr6jB1TR2mrmnA1DUNmLqmAVPXNGDqms54V25q9h0wdU0Dpq5pwNQ1DZi6pgFT1zRh6pomTF3ThKlrmjB1TaecWjcz+06YuqYJU9c0YeqaJkxd04Spa9pg6po2mLqmDaauaYOpazrhTbyd7Ludra5pg6lr2mDqmjaYuqYNpq5ph6lr2mHqmnaYuqYdpq7pjHflpmbfHaauaYepa9ph6pp2mLqmHaauWYGpa1Zg6poVmLpmBaauWbEXVPZtBaauWYGpa1Zg6poVmLpmBaauWYWpa1Zh6prVs9U1q2erazbhXbmp2bdVmLpmFaauWYWpa1Zh6ppVmLpmAlPXTGDqmglMXTOBqWv26afW7f34E5i6ZgJT10xg6poJTF0zgalrpjB1zRSmrpnC1DVTmLpmn35q3W5Qw9Q1U5i6ZgpT10xh6popTF0zO1tdMztbXTODqWtmMHXNZpwrNzX7Npi6ZgZT18xg6poZTF0zg6lr5jB1zRymrpnD1DVzmLpmM96Vm5p9O0xdM4epa+Ywdc0cpq6Zw9Q1C5i6ZgFT1yxg6poFTF2zGW/iTc2+A6auWcDUNQuYumZxtrpmcba6ZglT1yxh6polTF2zhKlr9umn1u1l3wlT1yxh6polTF2zhKlrljB1zRpMXbMGU9eswdQ1azB1zWacWjc1+24wdc0aTF2zBlPXrMHUNWswdc06TF2zDlPXrMPUNeswdc1mvIk3NfvuMHXN+tnqmvWz1TXrMHXNOkxd8wJT17zA1DUvMHXNC0xd82Ks7NsLTF3zAlPXvMDUNS8wdc0LTF3zClPXvMLUNa8wdc0rTF3zKafWTcy+vcLUNa8wdc0rTF3zClPXvMLUNReYuuYCU9dcYOqaC0xd8wlv4n2cfbucra65wNQ1F5i65gJT11xg6porTF1zhalrrjB1zRWmrvmMd+WmZt8KU9dcYeqaK0xdc4Wpa64wdc0Npq65wdQ1N5i65gZT13zKqXUzs2+DqWtuMHXNDaauucHUNTeYuuYOU9fcYeqa+9nqmvvZ6ppPeFdubvbtMHXNHaauucPUNXeYuuYOU9c8YOqaB0xd84Cpax4wdc0//dS6vR9/AVPXPGDqmgdMXfOAqWseMHXNE6auecLUNU+YuuYJU9f800+t2w1qmLrmCVPXPGHqmidMXfOEqWvezlbXvJ2trnmDqWveYOqazzhXbmr23WDqmjeYuuYNpq55g6lr3mDqmneYuuYdpq55h6lr3mHqms94V25q9t1h6pp3mLrmHaaueYepa95h6loUmLoWBaauRYGpa1Fg6loUe0Fl31Fg6loUmLoWBaauRTlbXYtytroWFaauRYWpa1Fh6lpUmLoWn35q3U72HRWmrkWFqWtRYepaVJi6FhWmroXA1LUQmLoWAlPXQmDqWsw4tW5m9h0CU9dCYOpaCExdC4GpayEwdS0Upq6FwtS1UJi6FgpT12LGm3hTs2+FqWuhZ6troWera6EwdS0Upq6FwdS1MJi6FgZT18Jg6lrMeFduavZtMHUtDKauhcHUtTCYuhYGU9fCYepaOExdC4epa+EwdS2mnFo3M/t2mLoWDlPXwmHqWjhMXQuHqWsRMHUtAqauRcDUtQiYuhYT3sTbyb7jbHUtAqauRcDUtQiYuhYBU9ciYepaJExdi4Spa5EwdS1mvCs3NftOmLoWCVPXImHqWiRMXYuEqWvRYOpaNJi6Fg2mrkWDqWsx5dS6mdl3g6lr0WDqWjSYuhYNpq5Fg6lr0WHqWnSYuhb9bHUt+tnqWkx4V25u9t1h6lp0mLoWHaauRYepa9Fh6loWmLqWBaauZYGpa1lg6loWY2XfWWDqWhaYupYFpq5lgalrWWDqWlaYupYVpq5lhalrWWHqWn76qXW7QQ1T17LC1LWsMHUtK0xdywpT11LOVtdSzlbXUmDqWgpMXcsZ58rNzL5TYOpaCkxdS4GpaykwdS0Fpq6lwtS1VJi6lgpT11Jh6lrOeFduavatMHUtFaaupcLUtVSYupYKU9fSYOpaGkxdS4Opa2kwdS1nvIk3Nfs2mLqWBlPX0mDqWtrZ6lra2epaOkxdS4epa+kwdS0dpq7lp59at5d9O0xdS4epa+kwdS0dpq6lw9S1DJi6lgFT1zJg6loGTF3LGafWTc2+A6auZcDUtQyYupYBU9cyYOpaJkxdy4Spa5kwdS0Tpq7ljDfxpmbfCVPXMs9W1zLPVtcyYepaJkxdywZT17LB1LVsMHUtG0xdyxnvyk3NvhtMXcsGU9eywdS1bDB1LRtMXcsOU9eyw9S17DB1LTtMXcspp9bNzL47TF3LDlPXssPUtewwdS07TF1rBaautQJT11qBqWutwNS1Vuzk7LuVs9W1VmDqWiswda0VmLrWCkxdaxWmrrUKU9dahalrrcLUtTbjXbmZ2XerMHWtVZi61ipMXWsVpq61ClPXmsDUtSYwda0JTF1rAlPX2pRT6yZm301g6loTmLrWBKauNYGpa01g6lpTmLrWFKauNT1bXWt6trrWJrwrNzf7Vpi61hSmrjWFqWtNYepaU5i61gymrjWDqWvNYOpaM5i61j791Lq9H38GU9eawdS1ZjB1rRlMXWsGU9eaw9S15jB1rTlMXWsOU9fap59atxvUMHWtOUxdaw5T15rD1LXmMHWtxdnqWouz1bUWMHWtBUxdazPOlZuafQdMXWsBU9dawNS1FjB1rQVMXWsJU9dawtS1ljB1rSVMXWsz3pWbmn0nTF1rCVPXWsLUtZYwda0lTF1rDaautQZT11qDqWutwdS1NuNNvKnZd4Opa63B1LXWYOpaa2era62dra61DlPXWoepa63D1LXWYepa+/RT6/ay7w5T11qHqWutw9S11mHqWuswda0XmLrWC0xd6wWmrvUCU9d6sRdU9t0LTF3rBaau9QJT13qBqWu9wNS1XmHqWq8wda1XmLrWK0xd6zPexJuZffcKU9d6PVtd6/Vsda1XmLrWK0xd6wJT17rA1LUuMHWtC0xd6zPelZuZfXeBqWtdYOpaF5i61gWmrnWBqWtdYepaV5i61hWmrnWFqWt9yql1M7NvhalrXWHqWleYutYVpq51halr3WDqWjeYutYNpq51g6lrfcKbeDvZt52trnWDqWvdYOpaN5i61g2mrnWHqWvdYepad5i61h2mrvUZ78rlzOzbYepad5i61h2mrnWHqWvdYepaD5i61gOmrvWAqWs9YOpan3Jq3czsO2DqWg+YutYDpq71gKlrPWDqWk+YutYTpq71PFtd63m2utYnvCs3N/tOmLrWE6au9YSpaz1h6lpPmLrWG0xd6w2mrvUGU9d6g6lr/dNPrdv78ddg6lpvMHWtN5i61htMXesNpq71DlPXeoepa73D1LXeYepa//RT63aDGqau9Q5T13qHqWu9w9S13mHq2tifn82ujUuc7a6NS8DgtfFdMHltfJe9oFLw8V0we218FwxfG98F09fGd8H4tdEj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5OoY5RJlkRXI1THKZy2LrECujlEuURZZgVwdo3zWssgK5OoY5RJlkRXI1THKZy2LrECujlEuURZZgVwdo3zWssgK5OoY5RJlkRXI1THKZy2LrECujlEuURZZgVwdo3zWssgK5OoY5RJlkRXI1THKZy2LrECujlEuURZZgVwdo3zWssgK5OoY5RJlkRXI1THKZy2LrECujlEuURZZgVwdo3zWssgK5OoY5RJlkRXI1THKZy2LrECujlGuUBapS5Cr9VnJ1boEuVqXIFdrsSWW2pOWReoS5GpdglytS5Cr9VnJ1boEuVqXIFfrEuRqfVZytS5BrtYlyNW6BLlan5VcrUuQq3UJcrUuQa7WZyVX6xLkal2CXK1LkKv1WcnVugS5WpcgV+sS5Gp9VnK1YslVrfb6tVq9fXx7xq18/bB5q9tRUjcdPzbKKPL6xVH6dpTUHcoPjrK+fXHod+4ldYcyN2JtiYil7lDmRix1OzM3YqnbmbkRS93OzI1Y6nZmasRiMde5o7zG3mdvlNfY++yN8hp7n51nLFZ+nfqMxcqvcyP2GnufvYi9yN5nJ2KvsffZi9hr7H12IhZryk6NWKwpOzVisabs3FEuUffBArRzR3mRus/OM/Yie5+dZ+w19j57EXuRus9OxF5k7/NxxGK12qkRi9Vqp0YslradG7HYvY/G67+Lq2b+ZMTaEqPE7n2mjhK795k6Suze54dGufeMxe59fmyUO89Y7N5nZsRi0dypEYtFc6dGLBbNnRux19j77EWsLRGx3937aClft8oWH4+yFnm9RC36zZTor5eI8y+R51+inX+JH/1590urHyZN/9qqHmolPz8J9hbp4588yreT8FkLSIq8fq18ex8OPQy/j3lee0p2npzflz8vPiUfP2ab3wvncUriXjiPU5L3wnmcknYvnMcp6feUPEzJ94XVtaek3o/XxylZcPe683jtC+5e9xaO3QvncUoW3L3uLZwFd697C2fF3evOwllw97q3cO7d68OUSLl3r5spWXD3ujcld+11MyV37XUzJXb/xHmckrv2upmSu/a6mZK79rqZkrv2upmSBXevOwunLrh73Vk49Rq717ELf50SqfpzC6deY/c6dUqusXudOiV2T8njlFxj9/pDU7L3E+cau9cfm5KdnzjX2L1OXTjX2L1OXTjX2L3OXDhyjd3rzIUjC+5edxaO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",
  "file_map": {
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "22": {
      "source": "// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n",
      "path": "std/hash/poseidon/bn254/perm.nr"
    },
    "23": {
      "source": "// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n",
      "path": "std/hash/poseidon/bn254.nr"
    },
    "24": {
      "source": "pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n",
      "path": "std/hash/poseidon/mod.nr"
    },
    "61": {
      "source": "use binary_merkle_root::binary_merkle_root;\nuse ec::bjj::BabyJubJubParams;\nuse ec::Curve;\nuse ec::scalar_field::ScalarField;\nuse std::field::bn254::assert_lt;\nuse std::hash::poseidon::bn254::hash_2 as poseidon;\n\n// The maximum depth of the Merkle Tree the inclusion proof will be coming from.\n// This value can get updated by overwriting this line.\npub global MAX_DEPTH: u32 = 1;\n\n// Generator point of Baby Jubjub curve.\n// ref: https://github.com/noir-lang/noir-edwards/blob/main/src/test.nr#L6C8-L6C13\nglobal BASE8: [Field; 2] = [\n    5299619240641551281634865583518297030282874472190772894086521144482721001553,\n    16950150798460657717958625567821834550301663161624707787222815936182638968203,\n];\n\n// This is a 251 bit value.\nglobal L: Field = 2736030358979909402780800718157159386076813972158567259200215660948447373041;\n\n// There are 3 main steps in the Noir program.\n// - The first part generates the Semaphore identity by obtaining\n//   the public key from the secret key and consequently hash the public key.\n//   This resulting hash is the identity_commitment.\n// - In the second part, it is verified that the identity_commitment is indeed\n//   part of the merkle tree by calculating the merkleRoot using the merkle proof.\n// - In the third part the nullifier is generated by hashing the hashed_scope\n//   with the secret key.\n//\n// There are 4 public values: hashed scope, hashed message, the nullifier and the\n// the Merkle tree root. Whether the scope and message are actually hashed doesn't\n// affect the circuit; the names just match how they're used in the Semaphore SDK.\n//\n// The message is tied to the circuit by adding it as a (public) input to the circuit.\n//\n// Returns: (Merkle tree root, nullifier)\nfn main(\n    secret_key: Field,\n    index_bits: [u1; MAX_DEPTH], // these bits indicate the order of inputs for hashing of the merkle proof\n    hash_path: [Field; MAX_DEPTH], // the Merkle Tree inclusion proof\n    merkle_proof_length: u32, // the number of non-zero elements in hash_path\n    hashed_scope: pub Field,\n    hashed_message: pub Field,\n) -> pub (Field, Field) {\n    // Part 1\n    // Ensure secret_key < l.\n    assert_lt(secret_key, L);\n\n    // Identity generation.\n    // The public key is derived by multiplying the generator point with the secret key,\n    // interpreted as a scalar.\n    let generator: Curve<BabyJubJubParams> = Curve { x: BASE8[0], y: BASE8[1] };\n    // ScalarField is parameterised by the number of 4-bit slices it contains.\n    // Since secret key is already known to be max 251 bits, there are 63 slices.\n    let secret_scalar: ScalarField<63> = ScalarField::from(secret_key);\n    let pubkey = generator.mul(secret_scalar);\n\n    // Obtain the identity commitment by hashing the public key\n    let identity_commitment = poseidon([pubkey.x, pubkey.y]);\n\n    // Part 2\n    // Verifies membership by repeatedly hashing with the elements from the merkle proof.\n    // Depending on the index bit, we swap the siblings for hashing or not.\n    let root = binary_merkle_root(\n        poseidon,\n        identity_commitment,\n        merkle_proof_length,\n        index_bits,\n        hash_path,\n    );\n\n    // Part 3\n    // Obtain the nullifier by hashing the hashed scope and secret key.\n    let nullifier = poseidon([hashed_scope, secret_key]);\n\n    // Return the calculated Merkle tree root & nullifier\n    (root, nullifier)\n}\n\n#[test]\nfn pass_merkleproof_len1() {\n    let secret_key = 2736030358979909402780800718157159386076813972158567259200215660948447373040;\n    let mut index_bits = [0; MAX_DEPTH];\n    index_bits[0] = 1;\n    let mut hash_path = [0; MAX_DEPTH];\n    hash_path[0] = 17197790661637433027297685226742709599380837544520340689137581733613433332983;\n    let merkle_proof_length = 1;\n    let hashed_scope = 32;\n    let message_input = 43;\n\n    let (merkle_root_output, nullifier_output) = main(\n        secret_key,\n        index_bits,\n        hash_path,\n        merkle_proof_length,\n        hashed_scope,\n        message_input,\n    );\n\n    assert(\n        merkle_root_output\n            == 14749601632619677010117355190090900871659822873947496064081607008658671249718,\n    );\n    assert(\n        nullifier_output\n            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,\n    );\n}\n\n#[test]\nfn pass_merkleproof_len2() {\n    let secret_key = 2736030358979909402780800718157159386076813972158567259200215660948447373040;\n    let mut index_bits = [0; MAX_DEPTH];\n    index_bits[0] = 1;\n    index_bits[1] = 1;\n    let mut hash_path = [0; MAX_DEPTH];\n    hash_path[0] = 222;\n    hash_path[1] = 5580148635681152038824579634153994374025422922042242905608547916566050510583;\n    let merkle_proof_length = 2;\n    let hashed_scope = 32;\n    let message_input = 43;\n\n    let (merkle_root_output, nullifier_output) = main(\n        secret_key,\n        index_bits,\n        hash_path,\n        merkle_proof_length,\n        hashed_scope,\n        message_input,\n    );\n\n    assert(\n        merkle_root_output\n            == 15463896243170667872144918581954291954064138644202866266871757140238856236252,\n    );\n    assert(\n        nullifier_output\n            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,\n    );\n}\n\n#[test]\nfn pass_merkleproof_len10() {\n    let secret_key = 2736030358979909402780800718157159386076813972158567259200215660948447373040;\n    let mut index_bits = [1; MAX_DEPTH];\n    let mut hash_path = [0; MAX_DEPTH];\n    hash_path[0] = 1023;\n    hash_path[1] = 7703609393926148861806470850414101587282113463695008072842235608796379066550;\n    hash_path[2] = 11844355347052921836263554861941946966048634969958623466081587590542465759133;\n    hash_path[3] = 19139877065885635288462009770448247355705152266967089952432395406553642434273;\n    hash_path[4] = 15968895708437223385516840363948747630018846839139338811061474982723265688336;\n    hash_path[5] = 1157389113544196424312834359849712044068249869160475042631259223915679649526;\n    hash_path[6] = 9850169485007128596840836882853679679304108948486378818337816937810456934767;\n    hash_path[7] = 7328698264973484546168581905250553935177218888248684409634832044961836320061;\n    hash_path[8] = 3637363514134115024343666241307349483158812906758472113070175697206757306389;\n    hash_path[9] = 7516686158158401448998320090358910253731148596461412688165783659432576569650;\n    let merkle_proof_length = 10;\n    let hashed_scope = 32;\n    let message_input = 43;\n\n    let (merkle_root_output, nullifier_output) = main(\n        secret_key,\n        index_bits,\n        hash_path,\n        merkle_proof_length,\n        hashed_scope,\n        message_input,\n    );\n\n    assert(\n        merkle_root_output\n            == 2057311462964865392236711171061056405638996999335557516757935831793017666139,\n    );\n    assert(\n        nullifier_output\n            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,\n    );\n}\n\n#[test(should_fail)]\nfn fail_secret_key_outofrange() {\n    let secret_key = 2736030358979909402780800718157159386076813972158567259200215660948447373042;\n    let mut index_bits = [0; MAX_DEPTH];\n    index_bits[0] = 1;\n    let mut hash_path = [0; MAX_DEPTH];\n    hash_path[0] = 17197790661637433027297685226742709599380837544520340689137581733613433332983;\n    let merkle_proof_length = 1;\n    let hashed_scope = 32;\n    let message_input = 43;\n\n    let _ = main(\n        secret_key,\n        index_bits,\n        hash_path,\n        merkle_proof_length,\n        hashed_scope,\n        message_input,\n    );\n}\n",
      "path": "/Users/elena/Documents/hashcloak/clients/Aztec/semaphore_grant_related/semaphore-noir/packages/circuits-noir/src/main.nr"
    },
    "63": {
      "source": "// This circuit is designed to calculate the root of a binary Merkle\n// tree given a hash function, a leaf, its depth, and the necessary sibling\n// information (aka proof of membership).\n// A circuit is designed without the capability to iterate through\n// a dynamic array. To address this, a parameter with the static maximum\n// tree depth is defined (i.e. 'MAX_DEPTH'). And additionally, the circuit\n// receives a dynamic depth as an input, which is utilized in calculating the\n// true root of the Merkle tree. The actual depth of the Merkle tree\n// may be equal to or less than the static maximum depth.\npub fn binary_merkle_root<let MAX_DEPTH: u32>(\n    hasher: fn([Field; 2]) -> Field,\n    leaf: Field,\n    depth: u32,\n    indices: [u1; MAX_DEPTH],\n    siblings: [Field; MAX_DEPTH],\n) -> Field {\n    // Start from the leaf node\n    let mut node = leaf;\n\n    // Iterate through the Merkle proof up to MAX_DEPTH\n    for i in 0..MAX_DEPTH {\n        // Only compute hash if the current level is within the tree depth\n        if i < depth {\n            let sibling = siblings[i];\n\n            // Determine the ordering of node and sibling based on the index bit\n            // If indices[i] == 0, node is on the left; otherwise, it's on the right\n            let (left, right) = if indices[i] == 0 {\n                (node, sibling)\n            } else {\n                (sibling, node)\n            };\n\n            // Hash the pair to move one level up the tree\n            node = hasher([left, right]);\n        }\n    }\n\n    // Return the root computed\n    node\n}\n",
      "path": "/Users/elena/nargo/github.com/privacy-scaling-explorations/zk-kit.noir/binary-merkle-root-v0.0.1/packages/binary-merkle-root/src/lib.nr"
    },
    "65": {
      "source": "mod scalar_field;\nmod test;\nmod bjj;\n\npub use crate::scalar_field::ScalarField;\nuse std::ops::{Add, Neg, Sub};\n\npub struct Curve<Params> {\n    x: Field,\n    y: Field,\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### T R A I T S\n// ####################################################################################################################\n// ####################################################################################################################\n\n/// Parametrises a Twisted Edwards curve\ntrait TECurveParameterTrait {\n    fn a() -> Field; // twisted edward curve parameter a\n    fn d() -> Field; // twisted edward curve parameter d\n    fn gen() -> (Field, Field); // generator point x/y coordinates\n}\n\n/// Defines methods that a valid Curve implementation must satisfy\ntrait CurveTrait<Params>: Add + Sub + Eq + Neg + Default {\n    fn new(x: Field, y: Field) -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn dbl(self) -> Self;\n    fn mul<let NScalarSlices: u32>(self, x: ScalarField<NScalarSlices>) -> Self;\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self;\n\n    fn eq(self, x: Self) -> bool {\n        self == x\n    }\n    fn is_zero(self) -> bool {\n        self == Self::zero()\n    }\n\n    fn is_on_curve(self) -> bool;\n    fn assert_is_on_curve(self);\n    fn assert_equal(self, other: Self);\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### C O N S T R A I N E D    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> std::default::Default for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Returns point at infinity\n    ///\n    /// Cost: 0 gates\n    fn default() -> Self {\n        Curve::zero()\n    }\n}\n\nimpl<Params> std::ops::Add for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self + other`\n    ///\n    /// Cost: 7 gates\n    fn add(self, other: Self) -> Self {\n        Curve::add_internal(self, other, Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::ops::Neg for Curve<Params> {\n    /// Negate a point\n    ///\n    /// Cost: usually 0, will cost 1 gate if the `x` coordinate needs to be converted into a witness\n    fn neg(self) -> Self {\n        Curve { x: -self.x, y: self.y }\n    }\n}\n\nimpl<Params> std::ops::Sub for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self - other`\n    ///\n    /// Cost: 7 gates\n    fn sub(self, other: Self) -> Self {\n        Curve::add_internal(self, other.neg(), Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::cmp::Eq for Curve<Params> {\n    /// Compute `self == other`\n    ///\n    /// Cost: 6 gates\n    fn eq(self, other: Self) -> bool {\n        (self.x == other.x) & (self.y == other.y)\n    }\n}\n\nimpl<Params> std::convert::From<(Field, Field)> for Curve<Params> {\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    ///\n    /// Cost: 0 gates\n    fn from((x, y): (Field, Field)) -> Self {\n        Curve { x, y }\n    }\n}\n\nimpl<Params> CurveTrait<Params> for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n\n    /// Construct a new point\n    ///\n    /// If you know the x/y coords form a valid point DO NOT USE THIS METHOD\n    /// This method calls `assert_is_on_curve` which costs 3 gates.\n    /// Instead, directly construct via Curve{x, y} or use from((x, y))\n    ///\n    /// Cost: 3 gates\n    fn new(x: Field, y: Field) -> Self {\n        let result = Curve { x, y };\n        result.assert_is_on_curve();\n        result\n    }\n\n    /// Return the Identity element (point at infinity)\n    ///\n    /// Cost: 0 gates\n    fn zero() -> Self {\n        Curve { x: 0, y: 1 }\n    }\n\n    /// Return the Generator of the group\n    ///\n    /// Cost: 0 gates (assuming Params trait returns values known at compile time!)\n    fn one() -> Self {\n        let (x, y) = Params::gen();\n        Curve { x, y }\n    }\n\n    /// Validate a point is on the curve\n    ///\n    /// cheaper than `is_on_curve` (assert is cheaper than returning a bool)\n    ///\n    /// Cost: 3 gates\n    fn assert_is_on_curve(self) {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        assert(t2 == t3);\n    }\n\n    /// Constrain two points to equal each other\n    ///\n    /// Cheaper than `assert(self == other)` because no need to return a bool\n    ///\n    /// Cost: 0-2 gates (can do these asserts with just copy constraints)\n    fn assert_equal(self, other: Self) {\n        assert(self.x == other.x);\n        assert(self.y == other.y);\n    }\n\n    /// Return a bool that describes whether the point is on the curve\n    ///\n    /// If you don't need to handle the failure case, it is cheaper to call `assert_is_on_curve`\n    ///\n    /// Cost: 5 gates\n    fn is_on_curve(self) -> bool {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        (t2 == t3)\n    }\n\n    /// Compute `self + self`\n    ///\n    /// Cost: 5 gates\n    fn dbl(self) -> Self {\n        Curve::dbl_internal(self, Params::a(), Params::d())\n    }\n\n    /// Compute `self * scalar`\n    ///\n    /// Uses the Straus method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows:\n    ///      1: computing the Straus point lookup table (169 gates)\n    ///      2: 252 point doublings (1260 gates)\n    ///      3: 63 point additions (441 gates)\n    ///      4: 126 table reads with runtime index (252 gates)\n    ///\n    /// Cost: 2122 gates + cost of creating ScalarField (110 gates)\n    ///\n    /// TODO: use windowed non-adjacent form to remove 7 point additions when creating lookup table\n    fn mul<let NScalarSlices: u32>(self: Self, scalar: ScalarField<NScalarSlices>) -> Self {\n        // define a, d params locally to make code more readable (shouldn't affect performance)\n        let a = Params::a();\n        let d = Params::d();\n\n        // Construct tables of precomputed point coordinates.\n        let (table_x, table_y): ([Field; 16], [Field; 16]) = self.compute_straus_point_table(a, d);\n\n        // Initialize the accumulator with the point that maps to the first (most significant) scalar slice\n        let idx = scalar.base4_slices[0];\n        let mut accumulator: Self = Curve { x: table_x[idx], y: table_y[idx] };\n\n        // Execute a double-and-add subroutine\n        // 1. Compute `accumulator = accumulator * 16`\n        // 2. Extract 4-bits from the scalar multiplier and\n        //    use them to retrieve the corresponding point from our point table\n        // Note: this is similar to the \"double and add\" scalar multiplication method, except we use base16 instead of base2!\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            let idx: u8 = scalar.base4_slices[i];\n            let x = table_x[idx];\n            let y = table_y[idx];\n            accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n        }\n\n        // todo fix\n        if (scalar.skew) {\n            accumulator = accumulator - self;\n        }\n        accumulator\n    }\n\n    /// compute `points[0] * scalar[0] + ... + points[N-1] * scalar[N-1]`\n    ///\n    /// Is cheaper than `mul` when processing >1 point due to reduced number of point doublings\n    /// uses the Straus MSM method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows\n    /// PER POINT costs:\n    ///      1: computing the Straus point lookup table (169N gates)\n    ///      2: 63 point additions (441N gates)\n    ///      3: 126 table reads with runtime index (252N gates)\n    ///\n    /// Additional costs:\n    ///      1. 252 point doublings 1260 gates\n    ///\n    /// Cost: 1260 + 862N + cost of creating ScalarField (110N gates)\n    ///\n    /// TODO: use windowed non-adjacent form to remove 7 point additions per point when creating lookup table\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self {\n        let a = Params::a();\n        let d = Params::d();\n\n        // Generalized version of `mul` for multiple points.\n        let mut point_tables: [([Field; 16], [Field; 16]); N] = [([0; 16], [0; 16]); N];\n        for j in 0..N {\n            point_tables[j] = points[j].compute_straus_point_table(a, d);\n        }\n\n        let idx = scalars[0].base4_slices[0];\n        let mut accumulator: Self = Curve { x: point_tables[0].0[idx], y: point_tables[0].1[idx] };\n        for j in 1..N {\n            let idx = scalars[j].base4_slices[0];\n            let P = Curve { x: point_tables[j].0[idx], y: point_tables[j].1[idx] };\n            accumulator = accumulator.add_internal(P, a, d);\n        }\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            for j in 0..N {\n                let idx: u8 = scalars[j].base4_slices[i];\n                let x = point_tables[j].0[idx];\n                let y = point_tables[j].1[idx];\n                accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n            }\n        }\n\n        for j in 0..N {\n            if (scalars[j].skew == true) {\n                accumulator = accumulator - points[j];\n            }\n        }\n        accumulator\n    }\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### H E L P E R    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> Curve<Params> {\n\n    /// add two points together\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `add` :(\n    fn add_internal(self, other: Self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let x2 = other.x;\n        let y1 = self.y;\n        let y2 = other.y;\n        let (x, y, lambda) = unsafe { __add_unconstrained(x1, x2, y1, y2, a, d) };\n        let x1x2 = x1 * x2;\n        let x1y2 = x1 * y2;\n        std::as_witness(x1x2);\n        std::as_witness(x1y2);\n        let x_lhs = x * lambda * d + x - x1y2; // equals y1x2\n        let y_lhs = y * lambda * -d + y + x1x2 * a; // equals y1y2\n        let y1x2 = y1 * x2;\n        let y1y2 = y1 * y2;\n        std::as_witness(y1x2);\n        std::as_witness(y1y2);\n        let y1y2x1x2 = y1y2 * x1x2;\n        assert(x_lhs == y1x2);\n        assert(y_lhs == y1y2);\n        assert(y1y2x1x2 == lambda);\n        Self { x, y }\n    }\n\n    /// add a point to itself\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `dbl` :(\n    fn dbl_internal(self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let y1 = self.y;\n        let (x3, y3, _) = unsafe { __add_unconstrained(x1, x1, y1, y1, a, d) };\n        let x1x1a = x1 * x1 * a;\n        std::as_witness(x1x1a);\n        // t1 = a*x_1^2 + y_1^2\n        let t1 = y1 * y1 + x1x1a;\n        std::as_witness(t1);\n        // t3 = y_3 * (2 - a*x_1^2 + y_1^2) + 2*a*x_1^2\n        let t3 = y3 + y3 - t1 * y3 + x1x1a * 2;\n        // t3 == t1 implies y_3 * (2 - a*x_1^2 - y_1^2) + 2*a*x_1^2 == a*x_1^2 + y_1^2\n        // i.e. y_3 = y_1^2 - a*x_1^2 / (2 - a*x_1^2 - y_1^2)\n        assert(t3 == t1);\n        let t4 = x1 * y1;\n        std::as_witness(t4);\n        // x3 * t1 - t4 == t4 implies x_3 * (y_1^2 + a * x_1^2) = 2 * x_1 * y_1\n        // i.e. x_3 = 2 * x_1 * y_1 / (y_1^2 + a * x_1^2)\n        let t2 = x3 * t1 - t4;\n        assert(t2 == t4);\n        Self { x: x3, y: y3 }\n    }\n\n    /// Compute a 4-bit lookup table of point multiples for the Straus windowed scalar multiplication algorithm.\n    ///\n    /// Table contains [0, P, 2P, ..., 15P], which is used in the scalar mul algorithm to minimize the total number of required point additions\n    ///\n    /// It is cheaper to use ([Field; 16], [Field; 16]) than it is ([Curve; 16]).\n    /// This is because the compiler will represent [Curve; 16] in 1 ROM array (vs 2 for [Field; 16], [Field; 16]).\n    /// This means that any index into the ROM array for [Curve; 16] requires an additional arithmetic gate to process.\n    ///\n    ///      For example consider `let P: Curve = table[idx]`\n    ///      `table` will be a ROM array with 32 elements in it.\n    ///      The x-coordinates will be located at `2 * idx`\n    ///      The y-coordinates will be located at `2 * idx + 1`\n    ///      If `idx` is not known at compile time (for Straus it isnt), 2 arithmetic gates are required to evaluate `2 * idx`, `2 * idx + 1`\n    ///      before they can be used as arguments in a memory lookup protocol\n    ///\n    ///      Now consider `let P_x = table_x[idx]; let P_y = table_y[idx]`\n    ///      In this example, `idx` can be directly used as the argument into a memory lookup protocol for both tables.\n    ///\n    ///      For the Barretenberg backend, the cost of a Read-Only memory lookup is 2 gates,\n    ///      so splitting the x/y coordinates into separate tables means that the cost to lookup a point is 4 gates\n    ///      2 extra arithmetic gates would increase the cost by 50%, which we avoid by returning `([Field; 16], [Field; 16])` instead of `([Curve; 16])`\n    ///\n    /// Key cost components are as follows:\n    ///      1: Defining two size-16 lookup tables (2 gates per element, 32 elements = 64 gates)\n    ///      2: 15 point additions (7 * 5 = 105)\n    ///\n    /// Total Cost: 169 gates\n    ///\n    /// TODO: use windowed non-adjacent form to remove 8 point additions\n    fn compute_straus_point_table(self, a: Field, d: Field) -> ([Field; 16], [Field; 16]) {\n        let mut table_x: [Field; 16] = [0; 16];\n        let mut table_y: [Field; 16] = [0; 16];\n        table_x[8] = self.x;\n        table_y[8] = self.y;\n        let D = self.dbl_internal(a, d);\n        for i in 1..8 {\n            let Q = Self { x: table_x[7 + i], y: table_y[7 + i] };\n            let V = D.add_internal(Q, a, d);\n            table_x[8 + i] = V.x;\n            table_y[8 + i] = V.y;\n        }\n        for i in 0..8 {\n            table_x[i] = -table_x[15 - i];\n            table_y[i] = table_y[15 - i];\n        }\n        (table_x, table_y)\n    }\n}\n\n/// add points together, return output + lambda ter\nunconstrained fn __add_unconstrained(\n    x1: Field,\n    x2: Field,\n    y1: Field,\n    y2: Field,\n    a: Field,\n    d: Field,\n) -> (Field, Field, Field) {\n    let lambda = y1 * y2 * x1 * x2;\n    let y = (x1 * x2 * a - y1 * y2) / (lambda * d - 1);\n    let x = (x1 * y2 + y1 * x2) / (lambda * d + 1);\n    (x, y, lambda)\n}\n",
      "path": "/Users/elena/nargo/github.com/noir-lang/noir-edwards/v0.1.1/src/lib.nr"
    },
    "66": {
      "source": "/// ScalarField represents a scalar multiplier as a sequence of 4-bit slices\n///\n/// There is nuance to ScalarField, because twisted edwards curves generally have prime group orders that easily fit into a Field\n/// We can therefore obtain cheap conversions by simply summing up the bit slices and validate they equal the input scalar\n/// However...when converting arbitrary field elements (i.e. scalars that are multiples of a TE curve group order),\n/// we must perform additional checks when converting into 4-bit slices, as we must validate that the sum of the slices is smaller than the Field modulus (when evaluated over the integers)\n/// This is expensive and we would rather not do it! therefore ScalarField<N> is flexible.\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n///\n/// N.B. ScalarField bit values are not constrained to be smaller than the TE curve group order.\n/// ScalarField is used when performing scalar multiplications, where all operations wrap modulo the curve order\npub struct ScalarField<let N: u32> {\n    pub(crate) base4_slices: [u8; N],\n    pub(crate) skew: bool,\n}\n\nunconstrained fn get_wnaf_slices<let N: u32>(x: Field) -> ([u8; N], bool) {\n    let mut result: [u8; N] = [0; N];\n    let mut nibbles: [u8; N] = x.to_le_radix(16);\n\n    let skew: bool = nibbles[0] & 1 == 0;\n    nibbles[0] += skew as u8;\n    result[N - 1] = (nibbles[0] + 15) / 2;\n    for i in 1..N {\n        let mut nibble: u8 = nibbles[i];\n        result[N - 1 - i] = (nibble + 15) / 2;\n        if (nibble & 1 == 0) {\n            result[N - 1 - i] += 1;\n            result[N - i] -= 8;\n        }\n    }\n    (result, skew)\n}\n\nunconstrained fn from_wnaf_slices(x: [u8; 64], skew: bool) -> Field {\n    let mut result: Field = 0;\n\n    for i in 0..64 {\n        result *= 16;\n        result += (x[i] as Field) * 2 - 15;\n    }\n    result -= skew as Field;\n    result\n}\n\n#[test]\nfn test_wnaf() {\n    unsafe {\n        let result: Field = 0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0;\n        let (t0, t1) = get_wnaf_slices(result);\n        let expected = from_wnaf_slices(t0, t1);\n        assert(result == expected);\n    }\n}\n\ncomptime fn get_modulus_slices() -> (Field, Field) {\n    let bytes = std::field::modulus_be_bytes();\n    let num_bytes = std::field::modulus_num_bits() / 8;\n    let mut lo: Field = 0;\n    let mut hi: Field = 0;\n    for i in 0..(num_bytes / 2) {\n        hi *= 256;\n        hi += bytes[i] as Field;\n        lo *= 256;\n        lo += bytes[i + (num_bytes / 2)] as Field;\n    }\n    if (num_bytes & 1 == 1) {\n        lo *= 256;\n        lo += bytes[num_bytes - 1] as Field;\n    }\n    (lo, hi)\n}\n\nunconstrained fn get_borrow_flag(lhs_lo: Field, rhs_lo: Field) -> bool {\n    lhs_lo.lt(rhs_lo + 1)\n}\nimpl<let N: u32> std::convert::From<Field> for ScalarField<N> {\n\n    /// Construct from a field element\n    ///\n    /// if N >= 64 we perform extra checks to ensure the slice decomposition represents the same integral value as the input\n    /// (e.g. sum of slices != x + modulus)\n    fn from(x: Field) -> Self {\n        let mut result: Self = ScalarField { base4_slices: [0; N], skew: false };\n        let (slices, skew): ([u8; N], bool) = unsafe { get_wnaf_slices(x) };\n        result.base4_slices = slices;\n        result.skew = skew;\n        if (N < 64) {\n            let mut acc: Field = (slices[0] as Field) * 2 - 15;\n            for i in 1..N {\n                acc *= 16;\n                acc += (slices[i] as Field) * 2 - 15;\n            }\n            assert(acc - skew as Field == x);\n        } else {\n            // TODO: if num bits = 64, validate in sum of the bits is smaller than the Field modulus\n            let mut lo: Field = slices[(N / 2)] as Field;\n            let mut hi: Field = slices[0] as Field;\n            let mut borrow_shift = 1;\n            for i in 1..(N / 2) {\n                borrow_shift *= 16;\n                lo *= 16;\n                lo += (slices[(N / 2) + i] as Field) * 2 - 15;\n                hi *= 16;\n                hi += (slices[i] as Field) * 2 - 15;\n            }\n            if ((N & 1) == 1) {\n                borrow_shift *= 16;\n                lo *= 16;\n                lo += (slices[N - 1] as Field) * 2 - 15;\n            }\n            lo -= skew as Field;\n            // Validate that the integer represented by (lo, hi) is smaller than the integer represented by (plo, phi)\n            let (plo, phi) = comptime { get_modulus_slices() };\n            unsafe {\n                // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n                let borrow = get_borrow_flag(plo, lo) as Field;\n\n                let rlo = plo - lo + borrow * borrow_shift - 1; // -1 because we are checking a strict <, not <=\n                let rhi = phi - hi - borrow;\n                rlo.assert_max_bit_size::<(N / 2 + N % 2) * 4>();\n                rhi.assert_max_bit_size::<N / 2 * 4>();\n            }\n        }\n        for i in 0..N {\n            (result.base4_slices[i] as Field).assert_max_bit_size::<4>();\n        }\n        result\n    }\n}\n\nimpl<let N: u32> std::convert::Into<Field> for ScalarField<N> {\n\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    fn into(self: Self) -> Field {\n        let mut acc: Field = 0;\n        for i in 0..N {\n            acc = acc * 16;\n            acc = acc + (self.base4_slices[i] as Field) * 2 - 15;\n        }\n        acc -= self.skew as Field;\n        acc\n    }\n}\n\nimpl<let N: u32> ScalarField<N> {\n\n    pub fn new() -> Self {\n        Self { base4_slices: [0; N], skew: false }\n    }\n    fn get(self, idx: u64) -> u8 {\n        self.base4_slices[idx]\n    }\n}\n",
      "path": "/Users/elena/nargo/github.com/noir-lang/noir-edwards/v0.1.1/src/scalar_field.nr"
    }
  },
  "names": ["main"],
  "brillig_names": [
    "decompose_hint",
    "lte_hint",
    "get_wnaf_slices",
    "__add_unconstrained",
    "directive_integer_quotient"
  ]
}
