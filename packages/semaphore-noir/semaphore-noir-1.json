{
  "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
  "hash": 2958271058617502280,
  "abi": {
    "parameters": [
      { "name": "secret_key", "type": { "kind": "field" }, "visibility": "private" },
      {
        "name": "index_bits",
        "type": { "kind": "array", "length": 1, "type": { "kind": "integer", "sign": "unsigned", "width": 1 } },
        "visibility": "private"
      },
      {
        "name": "hash_path",
        "type": { "kind": "array", "length": 1, "type": { "kind": "field" } },
        "visibility": "private"
      },
      {
        "name": "merkle_proof_length",
        "type": { "kind": "integer", "sign": "unsigned", "width": 32 },
        "visibility": "private"
      },
      { "name": "hashed_scope", "type": { "kind": "field" }, "visibility": "public" },
      { "name": "hashed_message", "type": { "kind": "field" }, "visibility": "public" }
    ],
    "return_type": {
      "abi_type": { "kind": "tuple", "fields": [{ "kind": "field" }, { "kind": "field" }] },
      "visibility": "public"
    },
    "error_types": {
      "2920182694213909827": { "error_kind": "string", "string": "attempt to subtract with overflow" },
      "5019202896831570965": { "error_kind": "string", "string": "attempt to add with overflow" },
      "6485997221020871071": { "error_kind": "string", "string": "call to assert_max_bit_size" },
      "16761564377371454734": { "error_kind": "string", "string": "Array index out of bounds" },
      "17843811134343075018": { "error_kind": "string", "string": "Stack too deep" }
    }
  },
  "bytecode": "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",
  "debug_symbols": "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",
  "file_map": {
    "17": {
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n",
      "path": "std/field/bn254.nr"
    },
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "22": {
      "source": "// Instantiations of Poseidon permutation for the prime field of the same order as BN254\nuse crate::hash::poseidon::bn254::consts;\nuse crate::hash::poseidon::permute;\n\n#[field(bn254)]\npub fn x5_2(mut state: [Field; 2]) -> [Field; 2] {\n    state = permute(consts::x5_2_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_3(mut state: [Field; 3]) -> [Field; 3] {\n    state = permute(consts::x5_3_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_4(mut state: [Field; 4]) -> [Field; 4] {\n    state = permute(consts::x5_4_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_5(mut state: [Field; 5]) -> [Field; 5] {\n    state = permute(consts::x5_5_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_6(mut state: [Field; 6]) -> [Field; 6] {\n    state = permute(consts::x5_6_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_7(mut state: [Field; 7]) -> [Field; 7] {\n    state = permute(consts::x5_7_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_8(mut state: [Field; 8]) -> [Field; 8] {\n    state = permute(consts::x5_8_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_9(mut state: [Field; 9]) -> [Field; 9] {\n    state = permute(consts::x5_9_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_10(mut state: [Field; 10]) -> [Field; 10] {\n    state = permute(consts::x5_10_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_11(mut state: [Field; 11]) -> [Field; 11] {\n    state = permute(consts::x5_11_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_12(mut state: [Field; 12]) -> [Field; 12] {\n    state = permute(consts::x5_12_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_13(mut state: [Field; 13]) -> [Field; 13] {\n    state = permute(consts::x5_13_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_14(mut state: [Field; 14]) -> [Field; 14] {\n    state = permute(consts::x5_14_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_15(mut state: [Field; 15]) -> [Field; 15] {\n    state = permute(consts::x5_15_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_16(mut state: [Field; 16]) -> [Field; 16] {\n    state = permute(consts::x5_16_config(), state);\n\n    state\n}\n\n#[field(bn254)]\npub fn x5_17(mut state: [Field; 17]) -> [Field; 17] {\n    state = permute(consts::x5_17_config(), state);\n\n    state\n}\n",
      "path": "std/hash/poseidon/bn254/perm.nr"
    },
    "23": {
      "source": "// Instantiations of Poseidon constants, permutations and sponge for prime field of the same order as BN254\npub mod perm;\npub mod consts;\n\nuse crate::hash::poseidon::absorb;\n\n// Variable-length Poseidon-128 sponge as suggested in second bullet point of section 3 of https://eprint.iacr.org/2019/458.pdf\n#[field(bn254)]\npub fn sponge<let N: u32>(msg: [Field; N]) -> Field {\n    absorb(consts::x5_5_config(), [0; 5], 4, 1, msg)[1]\n}\n\n// Various instances of the Poseidon hash function\n// Consistent with Circom's implementation\n#[no_predicates]\npub fn hash_1(input: [Field; 1]) -> Field {\n    let mut state = [0; 2];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_2(state)[0]\n}\n\n#[no_predicates]\npub fn hash_2(input: [Field; 2]) -> Field {\n    let mut state = [0; 3];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_3(state)[0]\n}\n\n#[no_predicates]\npub fn hash_3(input: [Field; 3]) -> Field {\n    let mut state = [0; 4];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_4(state)[0]\n}\n\n#[no_predicates]\npub fn hash_4(input: [Field; 4]) -> Field {\n    let mut state = [0; 5];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_5(state)[0]\n}\n\n#[no_predicates]\npub fn hash_5(input: [Field; 5]) -> Field {\n    let mut state = [0; 6];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_6(state)[0]\n}\n\n#[no_predicates]\npub fn hash_6(input: [Field; 6]) -> Field {\n    let mut state = [0; 7];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_7(state)[0]\n}\n\n#[no_predicates]\npub fn hash_7(input: [Field; 7]) -> Field {\n    let mut state = [0; 8];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_8(state)[0]\n}\n\n#[no_predicates]\npub fn hash_8(input: [Field; 8]) -> Field {\n    let mut state = [0; 9];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_9(state)[0]\n}\n\n#[no_predicates]\npub fn hash_9(input: [Field; 9]) -> Field {\n    let mut state = [0; 10];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_10(state)[0]\n}\n\n#[no_predicates]\npub fn hash_10(input: [Field; 10]) -> Field {\n    let mut state = [0; 11];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_11(state)[0]\n}\n\n#[no_predicates]\npub fn hash_11(input: [Field; 11]) -> Field {\n    let mut state = [0; 12];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_12(state)[0]\n}\n\n#[no_predicates]\npub fn hash_12(input: [Field; 12]) -> Field {\n    let mut state = [0; 13];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_13(state)[0]\n}\n\n#[no_predicates]\npub fn hash_13(input: [Field; 13]) -> Field {\n    let mut state = [0; 14];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_14(state)[0]\n}\n\n#[no_predicates]\npub fn hash_14(input: [Field; 14]) -> Field {\n    let mut state = [0; 15];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_15(state)[0]\n}\n\n#[no_predicates]\npub fn hash_15(input: [Field; 15]) -> Field {\n    let mut state = [0; 16];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_16(state)[0]\n}\n\n#[no_predicates]\npub fn hash_16(input: [Field; 16]) -> Field {\n    let mut state = [0; 17];\n    for i in 0..input.len() {\n        state[i + 1] = input[i];\n    }\n\n    perm::x5_17(state)[0]\n}\n",
      "path": "std/hash/poseidon/bn254.nr"
    },
    "24": {
      "source": "pub mod bn254; // Instantiations of Poseidon for prime field of the same order as BN254\nuse crate::default::Default;\nuse crate::hash::Hasher;\n\n// A config struct defining the parameters of the Poseidon instance to use.\n//\n// A thorough writeup of this method (along with an unoptimized method) can be found at: https://spec.filecoin.io/algorithms/crypto/poseidon/\npub struct PoseidonConfig<let T: u32, let N: u32, let X: u32> {\n    // State width, should be equal to `T`\n    t: Field,\n    // Number of full rounds. should be even\n    rf: u8,\n    // Number of partial rounds\n    rp: u8,\n    // S-box power; depends on the underlying field\n    alpha: Field,\n    // The round constants for the\n    round_constants: [Field; N],\n    // The MDS matrix for the Poseidon instance\n    mds: [[Field; T]; T],\n    // An MDS matrix which also applies a basis transformation which allows\n    // sparse matrices to be used for the partial rounds.\n    //\n    // This should be applied instead of `mds` in the final full round.\n    presparse_mds: [[Field; T]; T],\n    // A set of sparse matrices used for MDS mixing for the partial rounds.\n    sparse_mds: [Field; X],\n}\n\npub fn config<let T: u32, let N: u32, let X: u32>(\n    t: Field,\n    rf: u8,\n    rp: u8,\n    alpha: Field,\n    round_constants: [Field; N],\n    mds: [[Field; T]; T],\n    presparse_mds: [[Field; T]; T],\n    sparse_mds: [Field; X],\n) -> PoseidonConfig<T, N, X> {\n    // Input checks\n    assert_eq(rf & 1, 0);\n    assert_eq((t as u8) * rf + rp, N as u8);\n    assert_eq(t, T as Field);\n    assert(alpha != 0);\n\n    PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds }\n}\n\npub fn permute<let T: u32, let N: u32, let X: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    mut state: [Field; T],\n) -> [Field; T] {\n    let PoseidonConfig { t, rf, rp, alpha, round_constants, mds, presparse_mds, sparse_mds } =\n        pos_conf;\n\n    for i in 0..state.len() {\n        state[i] += round_constants[i];\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..T {\n            state[i] += round_constants[T * (_r + 1) as u32 + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    for i in 0..T {\n        state[i] += round_constants[T * (rf / 2) as u32 + i];\n    }\n    state = apply_matrix(presparse_mds, state);\n\n    for i in 0..T {\n        crate::as_witness(state[i]);\n    }\n\n    for _r in 0..rp {\n        state[0] = state[0].pow_32(alpha);\n        state[0] += round_constants[(rf / 2 + 1) as u32 * T + _r as u32];\n        crate::as_witness(state[0]);\n        {\n            let mut newState0 = 0;\n            for j in 0..T {\n                newState0 += sparse_mds[(T * 2 - 1) * _r as u32 + j as u32] * state[j];\n            }\n            for k in 1..T {\n                state[k] += state[0] * sparse_mds[(t * 2 - 1) as u32 * _r as u32 + T + k - 1];\n            }\n            state[0] = newState0;\n\n            if (_r & 1 == 0) {\n                for k in 1..T {\n                    crate::as_witness(state[k]);\n                }\n            }\n        }\n    }\n\n    for _r in 0..rf / 2 - 1 {\n        state = sigma(state);\n        for i in 0..state.len() {\n            state[i] += round_constants[(rf / 2 + 1) as u32 * T + rp as u32 + (_r as u32) * T + i];\n        }\n        state = apply_matrix(mds, state);\n    }\n\n    state = sigma(state);\n    state = apply_matrix(mds, state);\n\n    state\n}\n\n// Performs matrix multiplication on a vector\nfn apply_matrix<let N: u32>(matrix: [[Field; N]; N], vec: [Field; N]) -> [Field; N] {\n    let mut out = [0; N];\n\n    for i in 0..N {\n        for j in 0..N {\n            out[i] += vec[j] * matrix[j][i];\n        }\n    }\n\n    out\n}\n\n// Corresponding absorption.\nfn absorb<let T: u32, let N: u32, let X: u32, let O: u32>(\n    pos_conf: PoseidonConfig<T, N, X>,\n    // Initial state; usually [0; O]\n    mut state: [Field; T],\n    rate: Field,\n    capacity: Field,\n    msg: [Field; O], // Arbitrary length message\n) -> [Field; T] {\n    assert_eq(pos_conf.t, rate + capacity);\n\n    let mut i = 0;\n\n    for k in 0..msg.len() {\n        // Add current block to state\n        state[capacity + i] += msg[k];\n        i = i + 1;\n        // Enough to absorb\n        if i == rate {\n            state = permute(pos_conf, state);\n            i = 0;\n        }\n    }\n    // If we have one more block to permute\n    if i != 0 {\n        state = permute(pos_conf, state);\n    }\n\n    state\n}\n\nfn sigma<let O: u32>(x: [Field; O]) -> [Field; O] {\n    let mut y = x;\n    for i in 0..O {\n        let t = y[i];\n        let tt = t * t;\n        let tttt = tt * tt;\n        y[i] *= tttt;\n    }\n    y\n}\n\npub struct PoseidonHasher {\n    _state: [Field],\n}\n\nimpl Hasher for PoseidonHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let mut result = 0;\n        let len = self._state.len();\n        assert(len < 16);\n        if len == 1 {\n            result = bn254::hash_1([self._state[0]]);\n        }\n        if len == 2 {\n            result = bn254::hash_2([self._state[0], self._state[1]]);\n        }\n        if len == 3 {\n            result = bn254::hash_3([self._state[0], self._state[1], self._state[2]]);\n        }\n        if len == 4 {\n            result = bn254::hash_4([self._state[0], self._state[1], self._state[2], self._state[3]]);\n        }\n        if len == 5 {\n            result = bn254::hash_5([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n            ]);\n        }\n        if len == 6 {\n            result = bn254::hash_6([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n            ]);\n        }\n        if len == 7 {\n            result = bn254::hash_7([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n            ]);\n        }\n        if len == 8 {\n            result = bn254::hash_8([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n            ]);\n        }\n        if len == 9 {\n            result = bn254::hash_9([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n            ]);\n        }\n        if len == 10 {\n            result = bn254::hash_10([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n            ]);\n        }\n        if len == 11 {\n            result = bn254::hash_11([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n            ]);\n        }\n        if len == 12 {\n            result = bn254::hash_12([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n            ]);\n        }\n        if len == 13 {\n            result = bn254::hash_13([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n            ]);\n        }\n        if len == 14 {\n            result = bn254::hash_14([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n            ]);\n        }\n        if len == 15 {\n            result = bn254::hash_15([\n                self._state[0],\n                self._state[1],\n                self._state[2],\n                self._state[3],\n                self._state[4],\n                self._state[5],\n                self._state[6],\n                self._state[7],\n                self._state[8],\n                self._state[9],\n                self._state[10],\n                self._state[11],\n                self._state[12],\n                self._state[13],\n                self._state[14],\n            ]);\n        }\n\n        result\n    }\n\n    #[inline_always]\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for PoseidonHasher {\n    fn default() -> Self {\n        PoseidonHasher { _state: &[] }\n    }\n}\n\nmod poseidon_tests {\n    use crate::hash::poseidon;\n\n    #[test]\n    fn reference_impl_test_vectors() {\n        // hardcoded test vectors from https://extgit.iaik.tugraz.at/krypto/hadeshash/-/blob/master/code/test_vectors.txt\n        {\n            let mut state = [0, 1, 2];\n            let mut expected = [\n                0x115cc0f5e7d690413df64c6b9662e9cf2a3617f2743245519e19607a4417189a,\n                0x0fca49b798923ab0239de1c9e7a4a9a2210312b6a2f616d18b5a87f9b628ae29,\n                0x0e7ae82e40091e63cbd4f16a6d16310b3729d4b6e138fcf54110e2867045a30c,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_3(state),\n                \"Failed to reproduce output for [0, 1, 2]\",\n            );\n        }\n        {\n            let mut state = [0, 1, 2, 3, 4];\n            let mut expected = [\n                0x299c867db6c1fdd79dcefa40e4510b9837e60ebb1ce0663dbaa525df65250465,\n                0x1148aaef609aa338b27dafd89bb98862d8bb2b429aceac47d86206154ffe053d,\n                0x24febb87fed7462e23f6665ff9a0111f4044c38ee1672c1ac6b0637d34f24907,\n                0x0eb08f6d809668a981c186beaf6110060707059576406b248e5d9cf6e78b3d3e,\n                0x07748bc6877c9b82c8b98666ee9d0626ec7f5be4205f79ee8528ef1c4a376fc7,\n            ];\n            assert_eq(\n                expected,\n                poseidon::bn254::perm::x5_5(state),\n                \"Failed to reproduce output for [0, 1, 2, 3, 4]\",\n            );\n        }\n    }\n}\n",
      "path": "std/hash/poseidon/mod.nr"
    },
    "61": {
      "source": "use ec::bjj::BabyJubJubParams;\nuse ec::Curve;\nuse ec::scalar_field::ScalarField;\nuse std::field::bn254::assert_lt;\nuse std::hash::poseidon::bn254::hash_2 as poseidon;\n\n// The maximum depth of the Merkle Tree the inclusion proof will be coming from.\n// This value can get updated by overwriting this line.\npub global MAX_DEPTH: u32 = 1;\n\n// Generator point of Baby Jubjub curve.\n// ref: https://github.com/noir-lang/noir-edwards/blob/main/src/test.nr#L6C8-L6C13\nglobal BASE8: [Field; 2] = [\n    5299619240641551281634865583518297030282874472190772894086521144482721001553,\n    16950150798460657717958625567821834550301663161624707787222815936182638968203,\n];\n\n// This is a 251 bit value.\nglobal L: Field = 2736030358979909402780800718157159386076813972158567259200215660948447373041;\n\n// There are 3 main steps in the Noir program.\n// - The first part generates the Semaphore identity by obtaining\n//   the public key from the secret key and consequently hash the public key.\n//   This resulting hash is the identity_commitment.\n// - In the second part, it is verified that the identity_commitment is indeed\n//   part of the merkle tree by calculating the merkleRoot using the merkle proof.\n// - In the third part the nullifier is generated by hashing the hashed_scope\n//   with the secret key.\n//\n// There are 4 public values: hashed scope, hashed message, the nullifier and the\n// the Merkle tree root. Whether the scope and message are actually hashed doesn't\n// affect the circuit; the names just match how they're used in the Semaphore SDK.\n//\n// The message is tied to the circuit by adding it as a (public) input to the circuit.\n//\n// Returns: (Merkle tree root, nullifier)\nfn main(\n    secret_key: Field,\n    index_bits: [u1; MAX_DEPTH], // these bits indicate the order of inputs for hashing of the merkle proof\n    hash_path: [Field; MAX_DEPTH], // the Merkle Tree inclusion proof\n    merkle_proof_length: u32, // the number of non-zero elements in hash_path\n    hashed_scope: pub Field,\n    hashed_message: pub Field,\n) -> pub (Field, Field) {\n    // Part 1\n    // Ensure secret_key < l.\n    assert_lt(secret_key, L);\n\n    // Identity generation.\n    // The public key is derived by multiplying the generator point with the secret key,\n    // interpreted as a scalar.\n    let generator: Curve<BabyJubJubParams> = Curve { x: BASE8[0], y: BASE8[1] };\n    // ScalarField is parameterised by the number of 4-bit slices it contains.\n    // Since secret key is already known to be max 251 bits, there are 63 slices.\n    let secret_scalar: ScalarField<63> = ScalarField::from(secret_key);\n    let pubkey = generator.mul(secret_scalar);\n\n    // Obtain the identity commitment by hashing the public key\n    let identity_commitment = poseidon([pubkey.x, pubkey.y]);\n\n    // Part 2\n    // Verifies membership by repeatedly hashing with the elements from the merkle proof.\n    // Depending on the index bit, we swap the siblings for hashing or not.\n    let mut node = identity_commitment;\n    for i in 0..MAX_DEPTH {\n        if i < merkle_proof_length {\n            let sibling = hash_path[i];\n            let (left, right) = if index_bits[i] == 0 {\n                (node, sibling)\n            } else {\n                (sibling, node)\n            };\n            node = poseidon([left, right]);\n        }\n    }\n\n    // Part 3\n    // Obtain the nullifier by hashing the hashed scope and secret key.\n    let nullifier = poseidon([hashed_scope, secret_key]);\n\n    // Return the calculated Merkle tree root & nullifier\n    (node, nullifier)\n}\n\n#[test]\nfn pass_merkleproof_len1() {\n    let secret_key = 2736030358979909402780800718157159386076813972158567259200215660948447373040;\n    let mut index_bits = [0; MAX_DEPTH];\n    index_bits[0] = 1;\n    let mut hash_path = [0; MAX_DEPTH];\n    hash_path[0] = 17197790661637433027297685226742709599380837544520340689137581733613433332983;\n    let merkle_proof_length = 1;\n    let hashed_scope = 32;\n    let message_input = 43;\n\n    let (merkle_root_output, nullifier_output) = main(\n        secret_key,\n        index_bits,\n        hash_path,\n        merkle_proof_length,\n        hashed_scope,\n        message_input,\n    );\n\n    assert(\n        merkle_root_output\n            == 14749601632619677010117355190090900871659822873947496064081607008658671249718,\n    );\n    assert(\n        nullifier_output\n            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,\n    );\n}\n\n#[test]\nfn pass_merkleproof_len2() {\n    let secret_key = 2736030358979909402780800718157159386076813972158567259200215660948447373040;\n    let mut index_bits = [0; MAX_DEPTH];\n    index_bits[0] = 1;\n    index_bits[1] = 1;\n    let mut hash_path = [0; MAX_DEPTH];\n    hash_path[0] = 222;\n    hash_path[1] = 5580148635681152038824579634153994374025422922042242905608547916566050510583;\n    let merkle_proof_length = 2;\n    let hashed_scope = 32;\n    let message_input = 43;\n\n    let (merkle_root_output, nullifier_output) = main(\n        secret_key,\n        index_bits,\n        hash_path,\n        merkle_proof_length,\n        hashed_scope,\n        message_input,\n    );\n\n    assert(\n        merkle_root_output\n            == 15463896243170667872144918581954291954064138644202866266871757140238856236252,\n    );\n    assert(\n        nullifier_output\n            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,\n    );\n}\n\n#[test]\nfn pass_merkleproof_len10() {\n    let secret_key = 2736030358979909402780800718157159386076813972158567259200215660948447373040;\n    let mut index_bits = [1; MAX_DEPTH];\n    let mut hash_path = [0; MAX_DEPTH];\n    hash_path[0] = 1023;\n    hash_path[1] = 7703609393926148861806470850414101587282113463695008072842235608796379066550;\n    hash_path[2] = 11844355347052921836263554861941946966048634969958623466081587590542465759133;\n    hash_path[3] = 19139877065885635288462009770448247355705152266967089952432395406553642434273;\n    hash_path[4] = 15968895708437223385516840363948747630018846839139338811061474982723265688336;\n    hash_path[5] = 1157389113544196424312834359849712044068249869160475042631259223915679649526;\n    hash_path[6] = 9850169485007128596840836882853679679304108948486378818337816937810456934767;\n    hash_path[7] = 7328698264973484546168581905250553935177218888248684409634832044961836320061;\n    hash_path[8] = 3637363514134115024343666241307349483158812906758472113070175697206757306389;\n    hash_path[9] = 7516686158158401448998320090358910253731148596461412688165783659432576569650;\n    let merkle_proof_length = 10;\n    let hashed_scope = 32;\n    let message_input = 43;\n\n    let (merkle_root_output, nullifier_output) = main(\n        secret_key,\n        index_bits,\n        hash_path,\n        merkle_proof_length,\n        hashed_scope,\n        message_input,\n    );\n\n    assert(\n        merkle_root_output\n            == 2057311462964865392236711171061056405638996999335557516757935831793017666139,\n    );\n    assert(\n        nullifier_output\n            == 17372857233400574021114979593304691729475458770275659856062929947081629926774,\n    );\n}\n\n#[test(should_fail)]\nfn fail_secret_key_outofrange() {\n    let secret_key = 2736030358979909402780800718157159386076813972158567259200215660948447373042;\n    let mut index_bits = [0; MAX_DEPTH];\n    index_bits[0] = 1;\n    let mut hash_path = [0; MAX_DEPTH];\n    hash_path[0] = 17197790661637433027297685226742709599380837544520340689137581733613433332983;\n    let merkle_proof_length = 1;\n    let hashed_scope = 32;\n    let message_input = 43;\n\n    let _ = main(\n        secret_key,\n        index_bits,\n        hash_path,\n        merkle_proof_length,\n        hashed_scope,\n        message_input,\n    );\n}\n",
      "path": "/Users/elena/Documents/hashcloak/clients/Aztec/semaphore_grant_related/semaphore-noir/packages/circuits-noir/src/main.nr"
    },
    "63": {
      "source": "mod scalar_field;\nmod test;\nmod bjj;\n\npub use crate::scalar_field::ScalarField;\nuse std::ops::{Add, Neg, Sub};\n\npub struct Curve<Params> {\n    x: Field,\n    y: Field,\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### T R A I T S\n// ####################################################################################################################\n// ####################################################################################################################\n\n/// Parametrises a Twisted Edwards curve\ntrait TECurveParameterTrait {\n    fn a() -> Field; // twisted edward curve parameter a\n    fn d() -> Field; // twisted edward curve parameter d\n    fn gen() -> (Field, Field); // generator point x/y coordinates\n}\n\n/// Defines methods that a valid Curve implementation must satisfy\ntrait CurveTrait<Params>: Add + Sub + Eq + Neg + Default {\n    fn new(x: Field, y: Field) -> Self;\n    fn zero() -> Self;\n    fn one() -> Self;\n    fn dbl(self) -> Self;\n    fn mul<let NScalarSlices: u32>(self, x: ScalarField<NScalarSlices>) -> Self;\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self;\n\n    fn eq(self, x: Self) -> bool {\n        self == x\n    }\n    fn is_zero(self) -> bool {\n        self == Self::zero()\n    }\n\n    fn is_on_curve(self) -> bool;\n    fn assert_is_on_curve(self);\n    fn assert_equal(self, other: Self);\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### C O N S T R A I N E D    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> std::default::Default for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Returns point at infinity\n    ///\n    /// Cost: 0 gates\n    fn default() -> Self {\n        Curve::zero()\n    }\n}\n\nimpl<Params> std::ops::Add for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self + other`\n    ///\n    /// Cost: 7 gates\n    fn add(self, other: Self) -> Self {\n        Curve::add_internal(self, other, Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::ops::Neg for Curve<Params> {\n    /// Negate a point\n    ///\n    /// Cost: usually 0, will cost 1 gate if the `x` coordinate needs to be converted into a witness\n    fn neg(self) -> Self {\n        Curve { x: -self.x, y: self.y }\n    }\n}\n\nimpl<Params> std::ops::Sub for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n    /// Compute `self - other`\n    ///\n    /// Cost: 7 gates\n    fn sub(self, other: Self) -> Self {\n        Curve::add_internal(self, other.neg(), Params::a(), Params::d())\n    }\n}\n\nimpl<Params> std::cmp::Eq for Curve<Params> {\n    /// Compute `self == other`\n    ///\n    /// Cost: 6 gates\n    fn eq(self, other: Self) -> bool {\n        (self.x == other.x) & (self.y == other.y)\n    }\n}\n\nimpl<Params> std::convert::From<(Field, Field)> for Curve<Params> {\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    ///\n    /// Cost: 0 gates\n    fn from((x, y): (Field, Field)) -> Self {\n        Curve { x, y }\n    }\n}\n\nimpl<Params> CurveTrait<Params> for Curve<Params>\nwhere\n    Params: TECurveParameterTrait,\n{\n\n    /// Construct a new point\n    ///\n    /// If you know the x/y coords form a valid point DO NOT USE THIS METHOD\n    /// This method calls `assert_is_on_curve` which costs 3 gates.\n    /// Instead, directly construct via Curve{x, y} or use from((x, y))\n    ///\n    /// Cost: 3 gates\n    fn new(x: Field, y: Field) -> Self {\n        let result = Curve { x, y };\n        result.assert_is_on_curve();\n        result\n    }\n\n    /// Return the Identity element (point at infinity)\n    ///\n    /// Cost: 0 gates\n    fn zero() -> Self {\n        Curve { x: 0, y: 1 }\n    }\n\n    /// Return the Generator of the group\n    ///\n    /// Cost: 0 gates (assuming Params trait returns values known at compile time!)\n    fn one() -> Self {\n        let (x, y) = Params::gen();\n        Curve { x, y }\n    }\n\n    /// Validate a point is on the curve\n    ///\n    /// cheaper than `is_on_curve` (assert is cheaper than returning a bool)\n    ///\n    /// Cost: 3 gates\n    fn assert_is_on_curve(self) {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        assert(t2 == t3);\n    }\n\n    /// Constrain two points to equal each other\n    ///\n    /// Cheaper than `assert(self == other)` because no need to return a bool\n    ///\n    /// Cost: 0-2 gates (can do these asserts with just copy constraints)\n    fn assert_equal(self, other: Self) {\n        assert(self.x == other.x);\n        assert(self.y == other.y);\n    }\n\n    /// Return a bool that describes whether the point is on the curve\n    ///\n    /// If you don't need to handle the failure case, it is cheaper to call `assert_is_on_curve`\n    ///\n    /// Cost: 5 gates\n    fn is_on_curve(self) -> bool {\n        let t0 = self.x * self.x;\n        let t1 = self.y * self.y;\n        std::as_witness(t0);\n        std::as_witness(t1);\n        let t2 = Params::a() * t0 + t1;\n        let t3 = 1 + Params::d() * t0 * t1;\n        (t2 == t3)\n    }\n\n    /// Compute `self + self`\n    ///\n    /// Cost: 5 gates\n    fn dbl(self) -> Self {\n        Curve::dbl_internal(self, Params::a(), Params::d())\n    }\n\n    /// Compute `self * scalar`\n    ///\n    /// Uses the Straus method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows:\n    ///      1: computing the Straus point lookup table (169 gates)\n    ///      2: 252 point doublings (1260 gates)\n    ///      3: 63 point additions (441 gates)\n    ///      4: 126 table reads with runtime index (252 gates)\n    ///\n    /// Cost: 2122 gates + cost of creating ScalarField (110 gates)\n    ///\n    /// TODO: use windowed non-adjacent form to remove 7 point additions when creating lookup table\n    fn mul<let NScalarSlices: u32>(self: Self, scalar: ScalarField<NScalarSlices>) -> Self {\n        // define a, d params locally to make code more readable (shouldn't affect performance)\n        let a = Params::a();\n        let d = Params::d();\n\n        // Construct tables of precomputed point coordinates.\n        let (table_x, table_y): ([Field; 16], [Field; 16]) = self.compute_straus_point_table(a, d);\n\n        // Initialize the accumulator with the point that maps to the first (most significant) scalar slice\n        let idx = scalar.base4_slices[0];\n        let mut accumulator: Self = Curve { x: table_x[idx], y: table_y[idx] };\n\n        // Execute a double-and-add subroutine\n        // 1. Compute `accumulator = accumulator * 16`\n        // 2. Extract 4-bits from the scalar multiplier and\n        //    use them to retrieve the corresponding point from our point table\n        // Note: this is similar to the \"double and add\" scalar multiplication method, except we use base16 instead of base2!\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            let idx: u8 = scalar.base4_slices[i];\n            let x = table_x[idx];\n            let y = table_y[idx];\n            accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n        }\n\n        // todo fix\n        if (scalar.skew) {\n            accumulator = accumulator - self;\n        }\n        accumulator\n    }\n\n    /// compute `points[0] * scalar[0] + ... + points[N-1] * scalar[N-1]`\n    ///\n    /// Is cheaper than `mul` when processing >1 point due to reduced number of point doublings\n    /// uses the Straus MSM method via lookup tables.\n    /// Assumes backend has an efficient implementation of a memory table abstraction\n    /// i.e. `let x = table[y]` is efficient even if `y` is not known at compile time\n    ///\n    /// Key cost components are as follows\n    /// PER POINT costs:\n    ///      1: computing the Straus point lookup table (169N gates)\n    ///      2: 63 point additions (441N gates)\n    ///      3: 126 table reads with runtime index (252N gates)\n    ///\n    /// Additional costs:\n    ///      1. 252 point doublings 1260 gates\n    ///\n    /// Cost: 1260 + 862N + cost of creating ScalarField (110N gates)\n    ///\n    /// TODO: use windowed non-adjacent form to remove 7 point additions per point when creating lookup table\n    fn msm<let N: u32, let NScalarSlices: u32>(\n        points: [Self; N],\n        scalars: [ScalarField<NScalarSlices>; N],\n    ) -> Self {\n        let a = Params::a();\n        let d = Params::d();\n\n        // Generalized version of `mul` for multiple points.\n        let mut point_tables: [([Field; 16], [Field; 16]); N] = [([0; 16], [0; 16]); N];\n        for j in 0..N {\n            point_tables[j] = points[j].compute_straus_point_table(a, d);\n        }\n\n        let idx = scalars[0].base4_slices[0];\n        let mut accumulator: Self = Curve { x: point_tables[0].0[idx], y: point_tables[0].1[idx] };\n        for j in 1..N {\n            let idx = scalars[j].base4_slices[0];\n            let P = Curve { x: point_tables[j].0[idx], y: point_tables[j].1[idx] };\n            accumulator = accumulator.add_internal(P, a, d);\n        }\n        for i in 1..NScalarSlices {\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            accumulator = accumulator.dbl_internal(a, d);\n            for j in 0..N {\n                let idx: u8 = scalars[j].base4_slices[i];\n                let x = point_tables[j].0[idx];\n                let y = point_tables[j].1[idx];\n                accumulator = accumulator.add_internal(Curve { x, y }, a, d);\n            }\n        }\n\n        for j in 0..N {\n            if (scalars[j].skew == true) {\n                accumulator = accumulator - points[j];\n            }\n        }\n        accumulator\n    }\n}\n\n// ####################################################################################################################\n// ####################################################################################################################\n// ### H E L P E R    F U N C T I O N S\n// ####################################################################################################################\n// ####################################################################################################################\nimpl<Params> Curve<Params> {\n\n    /// add two points together\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `add` :(\n    fn add_internal(self, other: Self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let x2 = other.x;\n        let y1 = self.y;\n        let y2 = other.y;\n        let (x, y, lambda) = unsafe { __add_unconstrained(x1, x2, y1, y2, a, d) };\n        let x1x2 = x1 * x2;\n        let x1y2 = x1 * y2;\n        std::as_witness(x1x2);\n        std::as_witness(x1y2);\n        let x_lhs = x * lambda * d + x - x1y2; // equals y1x2\n        let y_lhs = y * lambda * -d + y + x1x2 * a; // equals y1y2\n        let y1x2 = y1 * x2;\n        let y1y2 = y1 * y2;\n        std::as_witness(y1x2);\n        std::as_witness(y1y2);\n        let y1y2x1x2 = y1y2 * x1x2;\n        assert(x_lhs == y1x2);\n        assert(y_lhs == y1y2);\n        assert(y1y2x1x2 == lambda);\n        Self { x, y }\n    }\n\n    /// add a point to itself\n    ///\n    /// This method exists because of a Noir bug where `Params` cannot be accessed by an internal function\n    /// called from internal function. e.g. compiler error if `mul` impl tries to call `dbl` :(\n    fn dbl_internal(self, a: Field, d: Field) -> Self {\n        let x1 = self.x;\n        let y1 = self.y;\n        let (x3, y3, _) = unsafe { __add_unconstrained(x1, x1, y1, y1, a, d) };\n        let x1x1a = x1 * x1 * a;\n        std::as_witness(x1x1a);\n        // t1 = a*x_1^2 + y_1^2\n        let t1 = y1 * y1 + x1x1a;\n        std::as_witness(t1);\n        // t3 = y_3 * (2 - a*x_1^2 + y_1^2) + 2*a*x_1^2\n        let t3 = y3 + y3 - t1 * y3 + x1x1a * 2;\n        // t3 == t1 implies y_3 * (2 - a*x_1^2 - y_1^2) + 2*a*x_1^2 == a*x_1^2 + y_1^2\n        // i.e. y_3 = y_1^2 - a*x_1^2 / (2 - a*x_1^2 - y_1^2)\n        assert(t3 == t1);\n        let t4 = x1 * y1;\n        std::as_witness(t4);\n        // x3 * t1 - t4 == t4 implies x_3 * (y_1^2 + a * x_1^2) = 2 * x_1 * y_1\n        // i.e. x_3 = 2 * x_1 * y_1 / (y_1^2 + a * x_1^2)\n        let t2 = x3 * t1 - t4;\n        assert(t2 == t4);\n        Self { x: x3, y: y3 }\n    }\n\n    /// Compute a 4-bit lookup table of point multiples for the Straus windowed scalar multiplication algorithm.\n    ///\n    /// Table contains [0, P, 2P, ..., 15P], which is used in the scalar mul algorithm to minimize the total number of required point additions\n    ///\n    /// It is cheaper to use ([Field; 16], [Field; 16]) than it is ([Curve; 16]).\n    /// This is because the compiler will represent [Curve; 16] in 1 ROM array (vs 2 for [Field; 16], [Field; 16]).\n    /// This means that any index into the ROM array for [Curve; 16] requires an additional arithmetic gate to process.\n    ///\n    ///      For example consider `let P: Curve = table[idx]`\n    ///      `table` will be a ROM array with 32 elements in it.\n    ///      The x-coordinates will be located at `2 * idx`\n    ///      The y-coordinates will be located at `2 * idx + 1`\n    ///      If `idx` is not known at compile time (for Straus it isnt), 2 arithmetic gates are required to evaluate `2 * idx`, `2 * idx + 1`\n    ///      before they can be used as arguments in a memory lookup protocol\n    ///\n    ///      Now consider `let P_x = table_x[idx]; let P_y = table_y[idx]`\n    ///      In this example, `idx` can be directly used as the argument into a memory lookup protocol for both tables.\n    ///\n    ///      For the Barretenberg backend, the cost of a Read-Only memory lookup is 2 gates,\n    ///      so splitting the x/y coordinates into separate tables means that the cost to lookup a point is 4 gates\n    ///      2 extra arithmetic gates would increase the cost by 50%, which we avoid by returning `([Field; 16], [Field; 16])` instead of `([Curve; 16])`\n    ///\n    /// Key cost components are as follows:\n    ///      1: Defining two size-16 lookup tables (2 gates per element, 32 elements = 64 gates)\n    ///      2: 15 point additions (7 * 5 = 105)\n    ///\n    /// Total Cost: 169 gates\n    ///\n    /// TODO: use windowed non-adjacent form to remove 8 point additions\n    fn compute_straus_point_table(self, a: Field, d: Field) -> ([Field; 16], [Field; 16]) {\n        let mut table_x: [Field; 16] = [0; 16];\n        let mut table_y: [Field; 16] = [0; 16];\n        table_x[8] = self.x;\n        table_y[8] = self.y;\n        let D = self.dbl_internal(a, d);\n        for i in 1..8 {\n            let Q = Self { x: table_x[7 + i], y: table_y[7 + i] };\n            let V = D.add_internal(Q, a, d);\n            table_x[8 + i] = V.x;\n            table_y[8 + i] = V.y;\n        }\n        for i in 0..8 {\n            table_x[i] = -table_x[15 - i];\n            table_y[i] = table_y[15 - i];\n        }\n        (table_x, table_y)\n    }\n}\n\n/// add points together, return output + lambda ter\nunconstrained fn __add_unconstrained(\n    x1: Field,\n    x2: Field,\n    y1: Field,\n    y2: Field,\n    a: Field,\n    d: Field,\n) -> (Field, Field, Field) {\n    let lambda = y1 * y2 * x1 * x2;\n    let y = (x1 * x2 * a - y1 * y2) / (lambda * d - 1);\n    let x = (x1 * y2 + y1 * x2) / (lambda * d + 1);\n    (x, y, lambda)\n}\n",
      "path": "/Users/elena/nargo/github.com/noir-lang/noir-edwards/v0.1.1/src/lib.nr"
    },
    "64": {
      "source": "/// ScalarField represents a scalar multiplier as a sequence of 4-bit slices\n///\n/// There is nuance to ScalarField, because twisted edwards curves generally have prime group orders that easily fit into a Field\n/// We can therefore obtain cheap conversions by simply summing up the bit slices and validate they equal the input scalar\n/// However...when converting arbitrary field elements (i.e. scalars that are multiples of a TE curve group order),\n/// we must perform additional checks when converting into 4-bit slices, as we must validate that the sum of the slices is smaller than the Field modulus (when evaluated over the integers)\n/// This is expensive and we would rather not do it! therefore ScalarField<N> is flexible.\n/// ScalarField<63> enables cheap bitslice converions for scalar multipliers that must be <2^{252}\n/// ScalarField<64> enables bitslice conversions for arbitrary field elements\n///\n/// N.B. ScalarField bit values are not constrained to be smaller than the TE curve group order.\n/// ScalarField is used when performing scalar multiplications, where all operations wrap modulo the curve order\npub struct ScalarField<let N: u32> {\n    pub(crate) base4_slices: [u8; N],\n    pub(crate) skew: bool,\n}\n\nunconstrained fn get_wnaf_slices<let N: u32>(x: Field) -> ([u8; N], bool) {\n    let mut result: [u8; N] = [0; N];\n    let mut nibbles: [u8; N] = x.to_le_radix(16);\n\n    let skew: bool = nibbles[0] & 1 == 0;\n    nibbles[0] += skew as u8;\n    result[N - 1] = (nibbles[0] + 15) / 2;\n    for i in 1..N {\n        let mut nibble: u8 = nibbles[i];\n        result[N - 1 - i] = (nibble + 15) / 2;\n        if (nibble & 1 == 0) {\n            result[N - 1 - i] += 1;\n            result[N - i] -= 8;\n        }\n    }\n    (result, skew)\n}\n\nunconstrained fn from_wnaf_slices(x: [u8; 64], skew: bool) -> Field {\n    let mut result: Field = 0;\n\n    for i in 0..64 {\n        result *= 16;\n        result += (x[i] as Field) * 2 - 15;\n    }\n    result -= skew as Field;\n    result\n}\n\n#[test]\nfn test_wnaf() {\n    unsafe {\n        let result: Field = 0x123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0;\n        let (t0, t1) = get_wnaf_slices(result);\n        let expected = from_wnaf_slices(t0, t1);\n        assert(result == expected);\n    }\n}\n\ncomptime fn get_modulus_slices() -> (Field, Field) {\n    let bytes = std::field::modulus_be_bytes();\n    let num_bytes = std::field::modulus_num_bits() / 8;\n    let mut lo: Field = 0;\n    let mut hi: Field = 0;\n    for i in 0..(num_bytes / 2) {\n        hi *= 256;\n        hi += bytes[i] as Field;\n        lo *= 256;\n        lo += bytes[i + (num_bytes / 2)] as Field;\n    }\n    if (num_bytes & 1 == 1) {\n        lo *= 256;\n        lo += bytes[num_bytes - 1] as Field;\n    }\n    (lo, hi)\n}\n\nunconstrained fn get_borrow_flag(lhs_lo: Field, rhs_lo: Field) -> bool {\n    lhs_lo.lt(rhs_lo + 1)\n}\nimpl<let N: u32> std::convert::From<Field> for ScalarField<N> {\n\n    /// Construct from a field element\n    ///\n    /// if N >= 64 we perform extra checks to ensure the slice decomposition represents the same integral value as the input\n    /// (e.g. sum of slices != x + modulus)\n    fn from(x: Field) -> Self {\n        let mut result: Self = ScalarField { base4_slices: [0; N], skew: false };\n        let (slices, skew): ([u8; N], bool) = unsafe { get_wnaf_slices(x) };\n        result.base4_slices = slices;\n        result.skew = skew;\n        if (N < 64) {\n            let mut acc: Field = (slices[0] as Field) * 2 - 15;\n            for i in 1..N {\n                acc *= 16;\n                acc += (slices[i] as Field) * 2 - 15;\n            }\n            assert(acc - skew as Field == x);\n        } else {\n            // TODO: if num bits = 64, validate in sum of the bits is smaller than the Field modulus\n            let mut lo: Field = slices[(N / 2)] as Field;\n            let mut hi: Field = slices[0] as Field;\n            let mut borrow_shift = 1;\n            for i in 1..(N / 2) {\n                borrow_shift *= 16;\n                lo *= 16;\n                lo += (slices[(N / 2) + i] as Field) * 2 - 15;\n                hi *= 16;\n                hi += (slices[i] as Field) * 2 - 15;\n            }\n            if ((N & 1) == 1) {\n                borrow_shift *= 16;\n                lo *= 16;\n                lo += (slices[N - 1] as Field) * 2 - 15;\n            }\n            lo -= skew as Field;\n            // Validate that the integer represented by (lo, hi) is smaller than the integer represented by (plo, phi)\n            let (plo, phi) = comptime { get_modulus_slices() };\n            unsafe {\n                // Safety: `borrow`'s value is constrained to be correct by below range constraints.\n                let borrow = get_borrow_flag(plo, lo) as Field;\n\n                let rlo = plo - lo + borrow * borrow_shift - 1; // -1 because we are checking a strict <, not <=\n                let rhi = phi - hi - borrow;\n                rlo.assert_max_bit_size::<(N / 2 + N % 2) * 4>();\n                rhi.assert_max_bit_size::<N / 2 * 4>();\n            }\n        }\n        for i in 0..N {\n            (result.base4_slices[i] as Field).assert_max_bit_size::<4>();\n        }\n        result\n    }\n}\n\nimpl<let N: u32> std::convert::Into<Field> for ScalarField<N> {\n\n    /// Construct from tuple of field elements\n    ///\n    /// Use this method instead of `new` if you know x/y is on the curve\n    fn into(self: Self) -> Field {\n        let mut acc: Field = 0;\n        for i in 0..N {\n            acc = acc * 16;\n            acc = acc + (self.base4_slices[i] as Field) * 2 - 15;\n        }\n        acc -= self.skew as Field;\n        acc\n    }\n}\n\nimpl<let N: u32> ScalarField<N> {\n\n    pub fn new() -> Self {\n        Self { base4_slices: [0; N], skew: false }\n    }\n    fn get(self, idx: u64) -> u8 {\n        self.base4_slices[idx]\n    }\n}\n",
      "path": "/Users/elena/nargo/github.com/noir-lang/noir-edwards/v0.1.1/src/scalar_field.nr"
    }
  },
  "names": ["main"],
  "brillig_names": [
    "decompose_hint",
    "lte_hint",
    "get_wnaf_slices",
    "__add_unconstrained",
    "directive_integer_quotient"
  ]
}
