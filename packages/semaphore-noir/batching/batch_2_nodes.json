{
  "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
  "hash": 3709649294719061914,
  "abi": {
    "parameters": [
      {
        "name": "bp",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "struct",
            "path": "BatchProof",
            "fields": [
              { "name": "verification_key", "type": { "kind": "array", "length": 128, "type": { "kind": "field" } } },
              { "name": "proof", "type": { "kind": "array", "length": 456, "type": { "kind": "field" } } },
              { "name": "key_hash", "type": { "kind": "field" } }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "tY9LCsMgFEX38sYOatKE6lZKCcZPEETFT6GIe68JSQl0nOG5974Dr4CQc14mbZWLQJ8FjOMsaWcbFbhtUfTMrhQTCwnonRAE0gqgw/ioCJQ2EuiIK/qb4r7D+xb3ZPiNO1JfCPCF9gZz0MboZTp/1OI3C5rNRu6osuWnNn380Rz3PjguRQ5yNW1d038B",
  "file_map": {
    "29": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "61": {
      "source": "use dep::std::verify_proof;\n\nglobal N: u32 = 2;\n\n// A proof produced by a previous batch circuit\nstruct BatchProof {\n    verification_key: [Field; 128],\n    proof: [Field; 456],\n    key_hash: Field, // Apparently this is 0x00 for now, but we still make it dynamic\n}\n\n// Batch 2 Batch proofs into a single proof\n// Note: the inputs *cannot* be raw Semaphore proofs.\nfn main(bp: [BatchProof; N]) {\n    // Note that actual verification happens when this proof gets verified\n    for i in 0..N {\n        verify_proof(bp[i].verification_key, bp[i].proof, [], bp[i].key_hash);\n    }\n}\n",
      "path": "/Users/elena/Documents/hashcloak/clients/Aztec/semaphore_grant_related/semaphore-noir/packages/noir-proof-batch/circuits/batch_2_nodes/src/main.nr"
    }
  },
  "names": ["main"],
  "brillig_names": []
}
