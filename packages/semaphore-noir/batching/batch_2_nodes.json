{
  "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
  "hash": 10821117268598498290,
  "abi": {
    "parameters": [
      {
        "name": "bp",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "struct",
            "path": "BatchProof",
            "fields": [
              { "name": "verification_key", "type": { "kind": "array", "length": 128, "type": { "kind": "field" } } },
              { "name": "proof", "type": { "kind": "array", "length": 456, "type": { "kind": "field" } } },
              { "name": "key_hash", "type": { "kind": "field" } },
              { "name": "public_inputs_hash", "type": { "kind": "field" } }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" },
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "1d3Bjh3HrYDhd9Haiy6yiqz2q1xcBLItBwIEyZDlC1wYefccJzOOEynKQvqQ7p1G6iFpe36yePS769cXP7z67pc//+n12x/f/fzi2//59cWbd9+//PD63dvHV7++OP72Wz//9PLtb1/9/OHl+w8vvp3n+c2LV29/ePFt5fjLNy9+fP3m1ePXj19+9OjIGE/PjjzX7w/H+Zf//ebF+FT0yn76jq7zS6LHp6Kfaz59x3ken49e5/Ecvc7Rvz889ice3jGfA++o+OPDj1LyOqXM65SyrlNKXaeUvk4p+zqlnNcpZRwXqmVcqJYLNdxxoY47LtRyx4V67rhQ0x0X6rrjQm13XKjvxoX6blyo78aF+m5cqO/GhfpuXKjvxoX6blyo78aF+m5cqO/mhfpuXqjv5pU+YLhQ380L9d28UN/NL+27HXM/fzQWNf81fNvw24Y/vzj8759Kdo5/DT8PG37Y8GHDpw0/6U/OXDa8pXa2/Xe/bXhL7bLULkvtstQuS+2y1C5L7bLULjtrl521y1Jbltqy1Jaltiy1NW34ZcOXDW9nbVlq66Th+7Dhhw0fNrylti21baltS21batuekNvO2m1n7bazdltqd9rw9oS87Ql52xPyttRuS+221J6W2tNSe9oT8mln7Wln7Wln7WmpPe1ee9oT8mlPyOM4cHzL7TgCx08cf+L4C8cvHL9x/I3j26k7BuZ3DBw/cPzE8SeOj/kdmN+B+R2Y34H5jQPHx/M38PwNPH8D8xsLxy8cv3H8jeNjfhPzm5jfxPwm5jcnjo/nb+L5m3j+YoVqJN5/Jz4/T3x+nvj8jD2qMTG/E/M7Mb/YpRpYphrYphpYpxrYpxoL87vw/ouVqoGdqoGlqrEwvwvzi72qgcWqgc2qgdWqgd2qgeWqge2qUZjfwvsvFqwGNqwGVqxGY34b84stq4E1q4E9q4FFq4FNq4FVq4Fdq7Exvxvvv1i3Gti3Gli4GhvzuzG/2LkaWLoa2LoaWLsa2LsaWLwa2LwaJ+b3xPsvlq8Gtq8G1q/GafmN48DxB44fOH7i+BPHXzh+4fiN41t+47D7b2D/KrB/Fdi/ioH5HZhf7F8F9q8C+1eB/avA/lVg/yqwfxWB+Y3E8SeOv3D8wvExv4H5xf5VYP8qsH8V2L8K7F8F9q8C+1eBX2AV+A1Wgf2rwP5VYP8q8FusAr/GKrB/Fdi/CuxfBfavAvtXgf2rwP5VLMzvwvsv9q8C+1eB/atYmN+F+cX+VWD/KrB/Fdi/CuxfBfavAvtXUZjfwvsv9q8C+1eB/asozG9jfrF/Fdi/CuxfBfavAvtXgf2rwP5VNOa38f6L/avA/lVg/yo25ndjfrF/Fdi/CuxfBfavAvtXgf2rwP5VnJjfE++/2L8K7F8F9q/ixPyemF/sXyX2rxL7V4n9q8T+VR4Tx184Pr4A5cA3oGD/KrF/ldi/yoH5HZhf7F8l9q8S+1eJ/avE/lVi/yqxf5WB+Y2B4weOnzj+xPExv4H5xf5VYv8qsX+V2L9K7F8l9q8S+1eZmN9cOD4+P+sbBPUVgvgOwcSXCCb2rxL7V4n9q8T+VWL/KrF/ldi/yon5nXj/xf5VYv8qsX+V+EbBXJhf7F8l9q8S+1eJ/avE/lVi/yqxf5WF+S28/2L/KrF/ldi/Sny/YBbmF/tXif2rxP5VYv8qsX+V2L9K7F9lY34b77/Yv0rsXyX2rxLfNpgb84v9q8T+VWL/KrF/ldi/SuxfJfav8sT8nnj/xf5VYv8qsX+V+O7BPDG/2L9K7F8l9q8m9q8m9q8m9q8m9q/mYfmdx8LxC8dvHH/j+JjfgfnF/tXE/tXE/tXE/tXE/tXE/tXE/tUcmN9h99+J/auJ/auJ/auJ7x+cgfnF/tXE/tXE/tXE/tXE/tXE/tXE/tVMzG8mjo/Pz9i/mti/mvj+wYn9q4nffzXx+68mvn9w4vsHJ/av5sT8TszvxPxOvP9i/2ri919NfP/gxPcPzoX33y/3rx5H2Of4j9PgR/E/ye84up6+aYwRn89Q5zGeHq5z/FOGjx/eMZ9L31HxUTnrWuXUtcrpa5Wzr1XOealyPm2m/ffKGdcqJ65VTl6rnGt15bpWV65rdeW6Vleua3XlulZX7mt15b5WV+5rdeW+Vlfua3XlvlZX7mt15b5WV+5rdeW+Vlfe1+rK+1pdeV+rK+9rdeV9ra68r9WV97W68r5WV95f3pX/w+en+9QZzoNnGF8hw2c/5TyDZ0ieYfIMi2co/rPUPANn+jzxf4d1HDzD4BmCZ0ieYfIMi2fQTK+jeYbNM+g5vcbBM3CmB2d6cKYHZ3pwpkfxDM0zbJ6Bz+ngTMfgGYJnSJ5h8gyc6eBMB2c6ONPBmU5+9k4+p5PP6eRzOjnTuXgGfvZOfvZOfvZOzvTkTE/O9ORMT8705Gfvyef05HN68jk9OdOT79OLn70XP3svfvZenOnFmV6c6cWZXpzpxc/ei8/p4nO6+JwuznTxfbomz8DP3sXP3sWZLs50caabM92c6eZn7+ZzuifPwOd0c6ab79PNz97Nz96bn703Z3pzpjdnenOmN2d687P35nN68zm9+ZzmHtk6+T598rP3yc/eX8Uj+3wGzvTJmT450ydnmntkxT2y4h5ZcY+suEdWh2a6jsUzFM/QPMPmGTjTgzPNPbLiHllxj6y4R1bcIyvukRX3yGpwpofep4t7ZMU9suIeWQVnOjjT3CMr7pEV98iKe2TFPbLiHllxj6ySM53JM/CzN/fIintklZzp5Exzj6y4R1bcIyvukRX3yIp7ZMU9spqc6cn3ae6RFffIintktTjTizPNPbLiHllxj6y4R1bcIyvukRX3yKo408X3ae6RFffIintkVZzp4kxzj6y4R1bcIyvukRX3yIp7ZMU9smrOdPN9mntkxT2y4h5ZNWd6c6a5R1bcIyvukRX3yIp7ZMU9suIeWfH3kRV/H1lxj6y4R1bcIyv+PrLi7yMr7pEV98iKe2TFPbLiHllzj6y5R9aHZrqP5Bkmz7B4huIZmv8sbZ6BM809suYeWXOPrLlH1twja+6R9eBMj+YZNs+gz97NPbIOznRwprlH1twja+6RNffImntkzT2y5h5ZJ2c6B8/Az97cI2vukXVyppMzzT2y5h5Zc4+suUfW3CNr7pE198h6cqYn36e5R9bcI2vukfXkTC/ONPfImntkzT2y5h5Zc4+suUfW3CPrxZlefJ/mHllzj6y5R9bFmS7ONPfImntkzT2y5h5Zc4+suUfW3CPr5kw336e5R9bcI2vukXVzppszzT2y5h5Zc4+suUfW3CNr7pE198h6c6Y336e5R9bcI2vukTW/17L5vZbNPbLmHllzj6y5R9bcI2vukTX3yPahmd7H4BmCZ0ieYfIMi/8sFc/QPMPmGTjT3CPb3CPb3CPb3CPbgzM9Fs9QPEPzDJtn4EwHZ5p7ZJt7ZJt7ZJt7ZJt7ZJt7ZJt7ZDs406H36c09ss09ss09ss3vtdzJmeYe2eYe2eYe2eYe2eYe2eYe2eYe2Z6c6cn3ae6Rbe6Rbe6RbX6v5Z6cae6Rbe6Rbe6Rbe6Rbe6Rbe6Rbe6R7cWZXnyf5h7Z5h7Z5h7Z5vda7uJMc49sc49sc49sc49sc49sc49sc49sN2e6+T7NPbLNPbLNPbLN77XczZnmHtnmHtnmHtnmHtnmHtnmHtnmHtnenOnN92nukW3ukW3ukW1+r+XmHtnm7yPb/H1km99rufm9lpt7ZPvkTJ+c6ZMzfep9+uQe2cnfR3byey1Pfq/leUye4SswPWM9Z5jRH2X4NNNj9XOGOMbnM4ze+fxwn/WPh/PvGZpn2DzDqTP8G4/sa2YYPEPwDMkzTJ5h8Qyc6cGZHpzpwZkOznRwpoMzHZzp4EwHZzo408GZDs50cKaTM52c6eRMJ2c6OdPJmU7OdHKmkzOdnOnJmZ6c6cmZnpzpyZmenOnJmZ6c6cmZnpzpxZlenOnFmV6c6cWZXpzpxZlenOnFmV6c6eJMF2e6ONPFmS7OdHGmizNdnOniTBdnujnTzZluznRzppsz3Zzp5kw3Z7q/nOnYMZ4ejp3nRxm+nOmMfv47xYxz/DHDxw+vmcfTw2vOf/wDP/4C8hN/W/n4WP7p4X58evHHh3+rfR83rn3cuPa4ce1549rnjWtfN669blx737j2fePabzxXzxvP1fPGc/W88Vw9bzxXzxvP1fPGc/W88Vw9bzxXzxvP1fO+c3Ucx30H66P4+07WR/H3Ha2P4u87Wx/F33e4Poq/73R9FH/f8foo/r7z9VH8fQfso/g7T9hx5wk77jxhx50n7LjzhP0K/5PKf7H4O0/YcecJO+48YcddJ+zji+/ev37z5vWf//Tm3fcvP7x+9/bnx7c+fvv/Xr5//fK7N6+evvzxl7ff/+FPP/z/T89/8vz9P71/9/2rH355/+q3SH/7s0f4vwI=",
  "file_map": {
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "29": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "61": {
      "source": "use dep::std::verify_proof;\n\n// A proof produced by a previous batch circuit\nstruct BatchProof {\n    verification_key: [Field; 128],\n    proof: [Field; 456],\n    key_hash: Field, // Apparently this is 0x00 for now, but we still make it dynamic\n    public_inputs_hash: Field,\n}\n\n// Batch 2 Batch proofs into a single proof\n// Note: the inputs *cannot* be raw Semaphore proofs.\nfn main(bp: [BatchProof; 2]) -> pub Field {\n    // Note that actual verification happens when this proof gets verified\n    verify_proof(\n        bp[0].verification_key,\n        bp[0].proof,\n        [bp[0].public_inputs_hash],\n        bp[0].key_hash,\n    );\n    verify_proof(\n        bp[1].verification_key,\n        bp[1].proof,\n        [bp[1].public_inputs_hash],\n        bp[1].key_hash,\n    );\n\n    // Hash hashes of public_inputs together\n    let mut public_input_bytes = [0 as u8; 64];\n    for i in 0..32 {\n        // bp[0].public_inputs_hash\n        public_input_bytes[i] = bp[0].public_inputs_hash.to_be_bytes::<32>()[i];\n        // bp[1].public_inputs_hash\n        public_input_bytes[i + 32] = bp[1].public_inputs_hash.to_be_bytes::<32>()[i];\n    }\n\n    Field::from_be_bytes(keccak256::keccak256(public_input_bytes, 64))\n}\n",
      "path": "/Users/elena/Documents/hashcloak/clients/Aztec/semaphore_grant_related/semaphore-noir/packages/noir-proof-batch/circuits/batch_2_nodes_new/src/main.nr"
    },
    "63": {
      "source": "mod tests;\n\nuse std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n",
      "path": "/Users/elena/nargo/github.com/noir-lang/keccak256/v0.1.0/src/keccak256.nr"
    }
  },
  "names": ["main"],
  "brillig_names": ["directive_to_radix", "directive_invert", "directive_integer_quotient"]
}
