{
  "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
  "hash": 10287730344585659700,
  "abi": {
    "parameters": [
      {
        "name": "sp",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "struct",
            "path": "SemaphoreProof",
            "fields": [
              { "name": "verification_key", "type": { "kind": "array", "length": 128, "type": { "kind": "field" } } },
              { "name": "proof", "type": { "kind": "array", "length": 456, "type": { "kind": "field" } } },
              { "name": "public_inputs", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } },
              { "name": "key_hash", "type": { "kind": "field" } }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": null,
    "error_types": {}
  },
  "bytecode": "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peik6KPoouihaJ5onWicaJtommiZaJhol2iWaJVolGiTaJJokWiQaI9ojmiNaIxoi2iKaIloiGiHaIZohWiEaINogmiBaIBof2h+aH1ofGh7aHpoeWh4aHdodmh1aHRoc2hyaHFocGhvaG5obWhsaGtoamhpaGhoZ2hmaGVoZGhjaGJoYWhgaF9oXmhdaFxoW2haaFloWGhXaFZoVWhUaFNoUmhRaFBoT2hOaE1oTGhLaEpoSWhIaEdoRmhFaERoQ2hCaEFoQGg/aD5oPWg8aDtoOmg5aDhoN2g2aDVoNGgzaDJoMWgwaC9oLmgtaCxoK2gqaCloKGgnaCZoJWgkaCNoImghaCBoH2gdaBxoG2gaaBloGGgXaBZoFWgUaBNoEmgRaBBoD2gOaA1oDGgLaApoCWgIaAdoBmgFaARoA2gCaAFoANj+2fzZ+tn42fbZ9Nny2fDZ7tns2erZ6Nnm2eTZ4tng2d7Z3N9s7ZGCbZ3f9LOls6GznbOZs5WzkbONs4mzhbOBs32zebN1s3GzbbNps2WzYbNds1mzVbNRs02zSbNFs0GzPbM5szWzMbMtsymzJbMhsx2zGbMVsxGzDbMJswWzAbP9svmy9bLxsu2y6bLlsuGy3bLZstWy0bLNssmyxbLBsr2yubK1srGyrbKpsqWyobKdspmylbKRso2yibKFsoGyfbJ5snWycbJtsmmyZbJhsl2yWbJVslGyTbJJskWyQbI9sjmyNbIxsi2yKbIlsiGyHbIZshWyEbINsgmyBbIBsv2x+bH1sfGx7bHpseWx4bHdsdmx1bHRsc2xybHFscGxvbG5sbWxsbGtsamxpbGhsZ2xmbGVsZGxjbGJsYWxgbF9sXmxdbFxsW2xabFlsWGxXbFZsVWxUbFNsUmxRbFBsT2xObE1sTGxLbEpsSWxIbEdsRmxFbERsQ2xCbEFsQGx/bD5sPWw8bDtsOmw5bDhsN2w2bDVsNGwzbDJsMWwwbC9sLmwtbCxsK2wqbClsKGwnbCZsJWwkbCNsImwhbCBsH2webB1sHGwbbBpsGWwYbBdsFmwVbBRsE2wSbBFsEGwPbA5sDWwMbAtsCmwJbAhsB2wGbAVsBGwDbAJsAWwAfD2z5s/b/288fO2z5s+b/m84fN2z5s9b/W80fM2z5s8b/G8wfP2zpv7m7f2yMHbOn/g5y2dN3Teznkz562cN3LexnkT5y2cN3Devnnz5q2bN27etnnT5i2bN2zernmz5q2aN2repnmT5i2aN2jennlz5q2ZN2belnlT5i2ZN2Tejnkz5q2YN2LehnkT5i2YN2Defnnz5a2XN17ednnT5S2XN1zebnmz5a2WN1reZnmT5S2WN1jeXnlz5a2VN1beVnlT5S2VN1TeTnkz5a2UN1LeRnkT5S2UN1DePnnz5K2TN07eNnnT5C2TN0zeLnmz5K2SN0reJnmT5C2SN0jeHnlz5K2RN0beFnlT5C2RN0TeDnkz5K2QN0LeBnkT5C2QN0De/njz462PNz7e9njT4y2PNzze7niz462ONzre5niT4y2ONzje3nhz462NNzbe1nhT4y2NNzTezngz462MNzLexngT4y2MNzDevnjz4q2LNy7etnjT4i2LNyzerniz4o2KtynepHiL4g3qf339Hx6G0uswSgAA",
  "debug_symbols": "tY9LCsMgFEX38sYOYj6lcSulBL9BEBU/hSLuvSYkNNBxh+fe+w68AkKyvC7aKheBPAoYx2nSzjYq0O1R9NRuFBMNCcg4dgikFUCm+1QRKG0kkBuu6GeKhx4fWzzM33E/1ycC/Ed7Axa0MXpdrh+1+EWDpszIA1W2/NKmtz+b894Hx6XIQW6mvWv6Dw==",
  "file_map": {
    "29": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "61": {
      "source": "use dep::std::verify_proof;\n\nglobal N: u32 = 2;\n\nstruct SemaphoreProof {\n    verification_key: [Field; 128],\n    proof: [Field; 456],\n    public_inputs: [Field; 4],\n    key_hash: Field, // Apparently this is 0x00 for now, but we still make it dynamic\n}\n\n// Batch 2 Semaphore proofs into a single proof\nfn main(sp: [SemaphoreProof; N]) {\n    // Note that actual verification happens when this proof gets verified\n    for i in 0..N {\n        verify_proof(\n            sp[i].verification_key,\n            sp[i].proof,\n            sp[i].public_inputs,\n            sp[i].key_hash,\n        );\n    }\n}\n",
      "path": "/Users/elena/Documents/hashcloak/clients/Aztec/semaphore_grant_related/semaphore-noir/packages/noir-proof-batch/circuits/batch_2_leaves/src/main.nr"
    }
  },
  "names": ["main"],
  "brillig_names": []
}
