{
  "noir_version": "1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a",
  "hash": 10182520560918891410,
  "abi": {
    "parameters": [
      {
        "name": "sp",
        "type": {
          "kind": "array",
          "length": 2,
          "type": {
            "kind": "struct",
            "path": "SemaphoreProof",
            "fields": [
              { "name": "verification_key", "type": { "kind": "array", "length": 128, "type": { "kind": "field" } } },
              { "name": "proof", "type": { "kind": "array", "length": 456, "type": { "kind": "field" } } },
              { "name": "public_inputs", "type": { "kind": "array", "length": 4, "type": { "kind": "field" } } },
              { "name": "key_hash", "type": { "kind": "field" } }
            ]
          }
        },
        "visibility": "private"
      }
    ],
    "return_type": { "abi_type": { "kind": "field" }, "visibility": "public" },
    "error_types": {}
  },
  "bytecode": "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",
  "debug_symbols": "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jnfVjnfVjnfVzvF0n+Uj/GTuXbXjXbVzPN3H0+1dteNdteNdteNdteNdteNdteNdtROe7vB7t3fVjnfVjnfVTni609PtXbXjXbXjXbXjXbXjXbXjXbXjXbWTnu70e7d31Y531Y531U55usvT7V21412141214121412141214121057u9nu3d9WOd9WOd9VOe7rb0+1dteNdteNdteNdteNdteNdteNdtTOe7vF7t3fVjnfVjnfVzvV0X0+3d9WOd9WOd9WOd9WOd9WOd9WOd9XCP1ct/HPVwrtq4V21eIWPSP+NKh/RPmJ8hKfbu2rhXbXwrlp4Vy2Wp3uljygf0T5ifISne3u6vasW3lUL76qFd9XCu2rhXbXwrlpsT/fme3d4Vy28qxbeVYvj6T6ebu+qhXfVwrtq4V218K5aeFctvKsW4ekOv3d7Vy28qxbeVYvwdIen27tq4V218K5aeFctvKsW3lUL76pFerrT793eVQvvqoV31aI83eXp9q5aeFctvKsW3lUL76qFd9XCu2rRnu72e7d31cK7auFdtWhPd3u6vasW3lUL76qFd9XCu2rhXbXwrlqMp3v83u1dtfCuWnhXLcbTfT3d3lUL76qFd9XCu2rhXbXwrlp4Vy2up/vyvTu9q5beVUvvqqV/B2i+wkekjygf0T5ifATv3eldtfSuWi5P9zo+InxE+ojyEZ7u5en2rlp6Vy29q5beVUvvqqV31dK7ark93bt9xPgIP5l7Vy39O0DzeLq9q5beVUvvqqV31dK7auldtfSuWoanO/ze7V219K5aelct/TtAMzzd3lVL76qld9XSu2rpXbX0rlp6Vy3T051+7/auWnpXLb2rlv4doFmebu+qpXfV0rtq6V219K5aelctvauW5ekuv3d7Vy29q5beVUv/DtBsT7d31dK7auldtfSuWnpXLb2rlt5Vy/F0j9+7vauW3lVL76qlfwdojqfbu2rpXbX0rlp6Vy29q5beVUvvquX1dF+/d3tXLb2rVt5VK/8O0PKuWvnnqtUrfET6iPIR7b9R4/8pPN3L072Wj/B0++eqlX8HaPl3gNYqH/Ed6I6dnyNi9/uIX6a7X+dzRMdXIlbPf3341n99+HyKuDzi77hq3zVi+YjtI46PCB+RPqJ8RPsIT/f2dB9P9/F0H0/38XQfT/fxdB9P9/F0H0/38XSHpzs83eHpDk93eLrD0x2e7vB0h6c7PN3p6U5Pd3q609Odnu70dKenOz3d6elOT3d5usvTXZ7u8nSXp7s83eXpLk93ebrL092e7vZ0t6e7Pd3t6W5Pd3u629Pdnu72dI+nezzd4+keT/d4usfTPZ7u8XSPp3s83dfTfT3d19N9Pd3X03093dfTfT3d19N9Od39evmI5SO2jzg+InxE+ojyEe0jxkd4upene3m6l6d7ebqXp3t5upene3m6vavW3lVr76q1d9Xau2rtXbX2rlp7V629q9beVWvvqrV31dq7au1dtfauWntXrb2r1t5Va++qtXfV2rtq7V219q5ae1etvavW3lVr76q1d9Xau2rtXbX2rlp7V629q9beVWvvqrV31dq7au1dtfauWntXrb2r1t5Va++qtXfV2rtq7V219q5ae1etvavW3lVr76q1d9Xau2rtXbX2rlp7V629q9beVWvvqrV31dq7au1dtfauWntXrb2r1t5Va++qtXfV2rtq7V219q5ae1etvavW3lVr76q1d9Xau2rtXbX2rlp7V629q9beVRvvqo131ca7auNdtXmFj0gfUT6ifcT4CE+3d9XGu2rjXbXxrtp4V228qzbeVRvvqo131ca7auNdtfGu2nhXbbyrNt5VG++qjXfVxrtq41218a7aeFdtvKs23lUb76qNd9XGu2rjXbXxrtp4V228qzbeVRvvqo131ca7auNdtfGu2nhXbbyrNt5VG++qjXfVxrtq41218a7aeFdtvKs23lUb76qNd9XGu2rjXbXxrtp4V228qzbeVRvvqo131ca7auNdtfGu2nhXbbyrNt5VG++qjXfVxrtq41218a7aeFdtvKs23lUb76qNd9XGu2rjXbXxrtp4V228qzbeVRvvqo131ca7auNdtfGu2nhXbbyrNt5VG++qjXfVxrtq17tq17tq17tq17tq9xU+In3Et9O9Z69PH95v/+HofcS3073vfH4p5Hmdfh8xPuLyiO/gqn01YvmI7SOOjwgfkT6ifISne3m6l6d7e7q3p3t7uren+zu4auc166eI+77rfQdX7ez+/G7cs+/67xHvP5xxXp8+nBH/1ejX/MKH++0L/+nDfc+7t+7e72DB/YqX7498+fnIl78f+PLfwTb8FS+/PvLl90e+/PnIl4+PfPmP3GHPR+6w5yN32PORO+z5yB02PnKHjY/cYeMjd9j4yB32O5jVv+LlP3KHjY/cYeMjd9j4yB02PnKHzY/cYfMjd9j8yB02P3KH/Q7/d8OvePmP3GHzI3fY/MgdNj9yh82P3GHrI3fY+sgdtj5yh62P3GG/w/9h9Otc/u0X//CXH//4xx//+f/88c+//93ffvzzn/769lvf/vL//d1ffvzdP/zxD59++U//+qff/7e/+7f/9y+f/87n3/8vf/nz7//wj//6lz/8x0n/+ffejv//",
  "file_map": {
    "18": {
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n",
      "path": "std/field/mod.nr"
    },
    "29": {
      "source": "pub mod hash;\npub mod aes128;\npub mod array;\npub mod slice;\npub mod merkle;\npub mod ecdsa_secp256k1;\npub mod ecdsa_secp256r1;\npub mod embedded_curve_ops;\npub mod sha256;\npub mod sha512;\npub mod field;\npub mod collections;\npub mod compat;\npub mod convert;\npub mod option;\npub mod string;\npub mod test;\npub mod cmp;\npub mod ops;\npub mod default;\npub mod prelude;\npub mod uint128;\npub mod runtime;\npub mod meta;\npub mod append;\npub mod mem;\npub mod panic;\npub mod hint;\n\nuse convert::AsPrimitive;\n\n// Oracle calls are required to be wrapped in an unconstrained function\n// Thus, the only argument to the `println` oracle is expected to always be an ident\n#[oracle(print)]\nunconstrained fn print_oracle<T>(with_newline: bool, input: T) {}\n\nunconstrained fn print_unconstrained<T>(with_newline: bool, input: T) {\n    print_oracle(with_newline, input);\n}\n\npub fn println<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(true, input);\n    }\n}\n\npub fn print<T>(input: T) {\n    // Safety: a print statement cannot be constrained\n    unsafe {\n        print_unconstrained(false, input);\n    }\n}\n\npub fn verify_proof<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n) {\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, 0);\n}\n\npub fn verify_proof_with_type<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {\n    if !crate::runtime::is_unconstrained() {\n        crate::assert_constant(proof_type);\n    }\n    verify_proof_internal(verification_key, proof, public_inputs, key_hash, proof_type);\n}\n\n#[foreign(recursive_aggregation)]\nfn verify_proof_internal<let N: u32, let M: u32, let K: u32>(\n    verification_key: [Field; N],\n    proof: [Field; M],\n    public_inputs: [Field; K],\n    key_hash: Field,\n    proof_type: u32,\n) {}\n\n// Asserts that the given value is known at compile-time.\n// Useful for debugging for-loop bounds.\n#[builtin(assert_constant)]\npub fn assert_constant<T>(x: T) {}\n\n// Asserts that the given value is both true and known at compile-time\n#[builtin(static_assert)]\npub fn static_assert<let N: u32>(predicate: bool, message: str<N>) {}\n\npub fn wrapping_add<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\npub fn wrapping_sub<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    AsPrimitive::as_(x.as_() + 340282366920938463463374607431768211456 - y.as_())\n}\n\npub fn wrapping_mul<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\n#[builtin(as_witness)]\npub fn as_witness(x: Field) {}\n\nmod tests {\n    #[test(should_fail_with = \"custom message\")]\n    fn test_static_assert_custom_message() {\n        super::static_assert(1 == 2, \"custom message\");\n    }\n}\n",
      "path": "std/lib.nr"
    },
    "61": {
      "source": "use dep::std::verify_proof;\n\nstruct SemaphoreProof {\n    verification_key: [Field; 128],\n    proof: [Field; 456],\n    public_inputs: [Field; 4],\n    key_hash: Field, // Apparently this is 0x00 for now, but we still make it dynamic\n}\n\n// Batch 2 Semaphore proofs into a single proof\nfn main(sp: [SemaphoreProof; 2]) -> pub Field {\n    // Note that actual verification happens when this proof gets verified\n    verify_proof(\n        sp[0].verification_key,\n        sp[0].proof,\n        sp[0].public_inputs,\n        sp[0].key_hash,\n    );\n\n    verify_proof(\n        sp[1].verification_key,\n        sp[1].proof,\n        sp[1].public_inputs,\n        sp[1].key_hash,\n    );\n    \n    // hash nullifiers, roots, scope, message together\n    let mut public_input_bytes = [0 as u8; 256];\n    for i in 0..32 {\n        //proof_1_scope\n        public_input_bytes[i] = sp[0].public_inputs[0].to_be_bytes::<32>()[i];\n        //proof_2_scope\n        public_input_bytes[i + 32] = sp[1].public_inputs[0].to_be_bytes::<32>()[i];\n        //proof_1_message\n        public_input_bytes[i + 64] = sp[0].public_inputs[1].to_be_bytes::<32>()[i];\n        //proof_2_message\n        public_input_bytes[i + 96] = sp[1].public_inputs[1].to_be_bytes::<32>()[i];\n        //proof_1_root\n        public_input_bytes[i + 128] = sp[0].public_inputs[2].to_be_bytes::<32>()[i];\n        //proof_2_root\n        public_input_bytes[i + 160] = sp[1].public_inputs[2].to_be_bytes::<32>()[i];\n        //proof_1_nullifier\n        public_input_bytes[i + 192] = sp[0].public_inputs[3].to_be_bytes::<32>()[i];\n        //proof_2_nullifier\n        public_input_bytes[i + 224] = sp[1].public_inputs[3].to_be_bytes::<32>()[i];\n    }\n\n    Field::from_be_bytes(keccak256::keccak256(public_input_bytes, 256))\n}\n",
      "path": "/Users/elena/Documents/hashcloak/clients/Aztec/semaphore_grant_related/semaphore-noir/packages/noir-proof-batch/circuits/batch_2_leaves_new/src/main.nr"
    },
    "63": {
      "source": "mod tests;\n\nuse std::runtime::is_unconstrained;\nuse std::hash::keccak::keccakf1600;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[no_predicates]\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n\n    // Copy input to block bytes. For that we'll need at least input bytes (N)\n    // but we want it to be padded to a multiple of BLOCK_SIZE_IN_BYTES.\n    let mut block_bytes = [0; ((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let mut sliced_buffer =\n        [0; (((N / BLOCK_SIZE_IN_BYTES) + 1) * BLOCK_SIZE_IN_BYTES) / WORD_SIZE];\n    for i in 0..sliced_buffer.len() {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer[i] = sliced as u64;\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer[j];\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer[j];\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer[i * LIMBS_PER_BLOCK + j];\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n",
      "path": "/Users/elena/nargo/github.com/noir-lang/keccak256/v0.1.0/src/keccak256.nr"
    }
  },
  "names": ["main"],
  "brillig_names": ["directive_to_radix", "directive_invert", "directive_integer_quotient"]
}
